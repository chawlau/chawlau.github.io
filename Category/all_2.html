<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  eredin-blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="eredin-blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; eredin-blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html">C++基础与提高</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html">设计模式之美</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
        
            <li><a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Linux性能优化实战</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15776263556217.html">
                
                  <h1>协程和异步</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>同步</h4>

<ul>
<li>指代码调用IO操作时，必须等待IO操作完成后才返回的调用方式</li>
<li>异步是指代码调用IO操作时，不必等IO操作完成就返回的调用方式</li>
</ul>

<h4>阻塞和非阻塞</h4>

<ul>
<li>阻塞是指调用函数时候当前线程被挂起。</li>
<li>阻塞是指调用函数时候当前线程不会被挂起，而是立即返回</li>
</ul>

<h4>回调函数</h4>

<ul>
<li>如果回调函数执行不正常该如何？</li>
<li>如如果回调里面还要嵌套回调怎么办？</li>
<li>要嵌套很多层怎么か？</li>
<li>如果嵌套了多层，其中某个环节出错了会造成什么后果？</li>
<li>如果有个数据需要被每个回调都处理怎么办？</li>
<li>怎么使用当前函数中的局部变量？</li>
</ul>

<h4>需求</h4>

<ul>
<li>采用同步的方式去编写异步的代码</li>
<li>使用单线程去切换任务：</li>
<li>线程是由操作系统切换的，单线程切换意味着我们需要程序员自己去调度任务</li>
<li>不在需要锁，并发性高，如果单线程内切换函数，性能远高于线程切换，并发性更高</li>
</ul>

<h4>生成器</h4>

<ul>
<li> next 和 send</li>
<li> send可以传递值进入生成器内部,同时还可以重启生成器进入到下一个yield位置</li>
</ul>

<pre class="line-numbers"><code class="language-python">def gen_func():
    html = yield &quot;http://projectedu.com&quot;
    print(html)
    yield 2
    yield 3
    return &#39;bobby&#39;

if __name__ == &#39;__main__&#39;:
    gen = gen_func()
    url = next(gen)
    html = &quot;bobby&quot;
    gen.send(html)
</code></pre>

<ul>
<li>第一次调用send的时候不能调用一个非None值，因为生成器还没有执行到那一行代码</li>
<li>next则可以</li>
</ul>

<pre class="line-numbers"><code class="language-python">def gen_func():
    html = yield &quot;http://projectedu.com&quot;
    print(html)
    yield 2
    yield 3
    return &#39;bobby&#39;

if __name__ == &#39;__main__&#39;:
    gen = gen_func()
    # url = next(gen)
    gen.send(None)
    html = &quot;bobby&quot;
    print(gen.send(html))
</code></pre>

<ul>
<li>GeneratorExit是继承BaseException, Exception</li>
</ul>

<h4>throw</h4>

<pre class="line-numbers"><code class="language-python">def gen_func():
    try:
        html = yield &quot;http://projectedu.com&quot;
    except Exception as e:
        pass
    yield 2
    yield 3
    return &#39;bobby&#39;

if __name__ == &#39;__main__&#39;:
    gen = gen_func()
    print(next(gen))
    gen.throw(Exception, &#39;download error&#39;)
    print(next(gen))
    gen.throw(Exception, &#39;download error&#39;)
</code></pre>

<h4>yield from</h4>

<ul>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/29 21:32 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15775908801763.html">
                
                  <h1>Command</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>行为变化模式</h4>

<ul>
<li>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化“模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</li>
</ul>

<h4>动机</h4>

<ul>
<li>在软件构建过程中，“行为请求者”与“行为实现者通常呈现一种“紧耦合”。但在某些场合一一比如需要对行为进行“记录、撤销/重（undo/redo)、事务”等处理,这种无法抵御变化的紧耦合是不合适 的</li>
<li>在这种情况下，如何将“行为请求者“与“行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li>
</ul>

<h4>模式定义</h4>

<ul>
<li>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撇销的操作。</li>
</ul>

<h4>结构</h4>

<ul>
<li><img src="media/15775908801763/15811582346417.jpg" alt="" style="width:787px;"/></li>
</ul>

<h4>要点总结</h4>

<ul>
<li>Command 模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象</li>
<li>实现 Command 接口的具体命令对象 Concrete Command 有时侯根据需要可能会保存一些额外的状态信息。通过使用 Composite 模式可以将多个“命令“封装为ー个“复合命令“Macro Command</li>
<li>Command 模式与 C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command 以面向对象中的“接口-实现”来定义行为接口规范，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。</li>
<li>编译时多态</li>
<li>范形编程+函数对象解决了迭代器模式和命令模式</li>
<li>设计模式是弥补语言设计的不足出现的</li>
</ul>

<h4>优缺点</h4>

<h5>优点</h5>

<ul>
<li>将调用操作的类与知道如何执行该操作的对象解耦；</li>
<li>提供队列系统后，可以创建一系列命令；</li>
<li>添加新命令更加容易，并且无需更改现有代码；</li>
<li>还可以使用命令模式来定义回滚系统，例如，在向导示例中，我们可以编写一个回滚方法。</li>
</ul>

<h6>缺点：</h6>

<ul>
<li>为了实现目标，需要大量的类和对象进行协作。应用程序开发人员为了正确开发这些类，需要倍加小心；</li>
<li>每个单独的命令都是一个ConcreteCommand类，从而增加了需要实现和维护的类的数量。</li>
</ul>

<h4>cpp_code</h4>

<pre class="line-numbers"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

class Command {
    public:
    virtual void execute() = 0;
    Command() {}
};

class Barbecue {
    public:
    void bake_mutton() {cout &lt;&lt; &quot;bake mutton \n&quot;;}
    void bake_chicken() {cout &lt;&lt; &quot;bake chicken\n&quot;;}
};

class MuttonCommand : public Command {
    public:
    MuttonCommand(Barbecue* barbecue) : barbecue_(barbecue) {}

    void execute() {
        this-&gt;barbecue_-&gt;bake_mutton();
    }
    private:
    Barbecue* barbecue_ = nullptr;
};

class ChickenCommand : public Command {
    public:
    ChickenCommand(Barbecue* barbecue) : barbecue_(barbecue) {}

    void execute() {
        this-&gt;barbecue_-&gt;bake_chicken();
    }
    private:
    Barbecue* barbecue_ = nullptr;
};

class Waiter {
    public:
    Waiter() {}

    void AddOrder(Command* cmd) {
        this-&gt;orders.push_back(cmd);
    }

    void DelOrder(Command* cmd) {
        this-&gt;orders.remove(cmd);
    }

    void Notify() {
        for (auto it : this-&gt;orders) {
            it-&gt;execute();
        }
    }
    private:
    list&lt;Command*&gt; orders;
};

int main() {
    auto boy = new Barbecue();
    Command* cmd1 = new MuttonCommand(boy);
    Command* cmd2 = new MuttonCommand(boy);
    Command* cmd3 = new ChickenCommand(boy);
    auto waiter = new Waiter();
    waiter-&gt;AddOrder(cmd1);
    waiter-&gt;AddOrder(cmd2);
    waiter-&gt;AddOrder(cmd3);
    waiter-&gt;Notify();
}
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package desian_pattern_practise


import &quot;fmt&quot;

type Command interface {
    ExecuteCommand()
}

type Barbecue struct {}

func (b *Barbecue) BakeMutton() {
    fmt.Println(&quot;BakeMutton&quot;)
}

func (b *Barbecue) BakeChicken() {
    fmt.Println(&quot;BakeChicken&quot;)
}

type MuttonCommand struct {
    *Barbecue
}

func NewMuttonCommand(boy *Barbecue) *MuttonCommand {
    return &amp;MuttonCommand{
        Barbecue: boy,
    }
}

func (m *MuttonCommand) ExecuteCommand() {
    m.Barbecue.BakeMutton()
}

type BakeCommand struct {
    *Barbecue
}

func NewBakeCommand(boy *Barbecue) *BakeCommand {
    return &amp;BakeCommand{
        Barbecue: boy,
    }
}

func (b *BakeCommand) ExecuteCommand() {
    b.Barbecue.BakeChicken()
}

type Waiter struct {
    orders map[Command]bool
}

func NewWaiter() *Waiter {
    return &amp;Waiter{
        orders: make(map[Command]bool),
    }
}

func (w *Waiter) AddOrder(cmd Command) {
    w.orders[cmd] = true
}

func (w *Waiter) CancelOrder(cmd Command) {
    delete(w.orders, cmd)
}

func (w *Waiter) Notify() {
    for k, _ := range w.orders {
        k.ExecuteCommand()
    }
}
func TestBakeCommand_ExecuteCommand(t *testing.T) {
    boy := &amp;Barbecue{}

    cmd1, cmd2  := NewMuttonCommand(boy), NewMuttonCommand(boy)
    cmd3 := NewBakeCommand(boy)

    waiter := NewWaiter()
    waiter.AddOrder(cmd1)

    waiter.AddOrder(cmd2)

    waiter.AddOrder(cmd3)

    waiter.CancelOrder(cmd1)
    waiter.Notify()
}
</code></pre>

<h4>python_demo</h4>

<pre class="line-numbers"><code class="language-python">from abc import ABCMeta, abstractmethod

class Command(metaclass=ABCMeta):

    @abstractmethod
    def execute_command(self):
        pass

class Barbecue(object):

    def bake_mutton(self):
        print(&quot;bake mutton&quot;)

    def bake_chicken(self):
        print(&quot;bake chicken&quot;)

class MuttonCommand(Command):

    def __init__(self, barbecue):
        self.barbecue = barbecue

    def execute_command(self):
        self.barbecue.bake_mutton()


class ChickenCommand(Command):

    def __init__(self, barbecue):
        self.barbecue = barbecue

    def execute_command(self):
        self.barbecue.bake_chicken()

class Waiter(object):

    def __init__(self):
        self.__orders = []

    def add_order(self, cmd):
        self.__orders.append(cmd)

    def cancel_order(self, cmd):
        self.__orders.remove(cmd)

    def notify(self):
        for order in self.__orders:
            order.execute_command()

if __name__ == &#39;__main__&#39;:
    boy = Barbecue()

    cmd1 = MuttonCommand(boy)
    cmd2 = MuttonCommand(boy)
    cmd3 = ChickenCommand(boy)

    waiter = Waiter()

    waiter.add_order(cmd1)
    waiter.add_order(cmd2)
    waiter.add_order(cmd3)

    waiter.notify()
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/29 11:41 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15771449820188.html">
                
                  <h1>单一职责模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>单一职责划分标准</h4>

<ul>
<li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</li>
<li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</li>
<li>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；</li>
<li>比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；</li>
<li>类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来</li>
</ul>

<h4>单一职责</h4>

<ul>
<li>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</li>
</ul>

<h4>耦合和内聚</h4>

<ul>
<li>1 内聚和耦合其实是对一个意思（即合在一块）从相反方向的两种阐述。</li>
<li>2 内聚是从功能相关来谈，主张高内聚。把功能高度相关的内容不必要地分离开，就降低了内聚性，成了低内聚。</li>
<li>3 耦合是从功能无关来谈，主张低耦合。把功能明显无关的内容随意地结合起来，就增加了耦合性，成了高耦合</li>
</ul>

<h4>职责单一判断</h4>

<ul>
<li>类中的代码行数、函数或者属性过多；</li>
<li>类依赖的其他类过多，或者依赖类的其他类过多；</li>
<li>私有方法过多；比较难给类起一个合适的名字；</li>
<li>类中大量的方法都是集中操作类中的某几个属性。</li>
</ul>

<h4>对扩展开放和对修改关闭</h4>

<pre class="line-numbers"><code class="language-cpp">//
// Created by eredinliu on 2020-01-05.
//

#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

class AlertRule {
public:
    int64_t getMatchRule(string&amp; api) {
        return 10;
    }
};

class Notification{
public:
    void notify(int64_t level, const string&amp; msg) {
        cout &lt;&lt; &quot;level &quot; &lt;&lt; level &lt;&lt; &quot; msg &quot; &lt;&lt; msg &lt;&lt; endl;
    }
};

class ApiStateInfo;

class AlertHandle {
public:
    AlertHandle(AlertRule* rule, Notification* noti): _rule(rule), _noti(noti){}

    virtual void check(ApiStateInfo* stateInfo) = 0;


    AlertRule* getRule() {
        return _rule;
    }

    Notification* getNoti() {
        return _noti;
    }

private:
    AlertRule* _rule;
    Notification* _noti;
};

class ApiStateInfo {
public:
    string api;
    int64_t reqCount;
    int64_t errCount;
    int64_t duration;
    int64_t timeOut;
    ApiStateInfo(const string&amp; _api, int64_t _reqCount, int64_t _errCount,
            int64_t _duration, int64_t _timeOut) : api(_api), reqCount
            (_reqCount), errCount
            (_errCount),duration(_duration), timeOut(_timeOut) {}
};

class Alert {
public:
    void addAlertHandle(AlertHandle* handle) {
        this-&gt;handleList.push_back(handle);
    }

    void check(ApiStateInfo* stateInfo) {
        for (auto handler : handleList) {
            handler-&gt;check(stateInfo);
        }
    }

private:
    list&lt;AlertHandle*&gt; handleList{};
};

class TpsAlertHandler : public AlertHandle {
public:
    using AlertHandle::AlertHandle;

    void check(ApiStateInfo* stateInfo) {
        int64_t tps = stateInfo-&gt;reqCount / stateInfo-&gt;duration;
        if (tps &gt; AlertHandle::getRule()-&gt;getMatchRule(stateInfo-&gt;api)) {
           AlertHandle::getNoti()-&gt;notify(-1, &quot;TpsAlert Handle&quot;);
        }
    }
};

class ErrorAlertHandler : public AlertHandle {
public:
    using AlertHandle::AlertHandle;

    void check(ApiStateInfo* stateInfo) {
        if (stateInfo-&gt;errCount &gt; AlertHandle::getRule()-&gt;getMatchRule(
                stateInfo-&gt;api)) {
            AlertHandle::getNoti()-&gt;notify(-2, &quot;ErrAlert Handle&quot;);
        }
    }
};

class TimeOutAlertHandler : public AlertHandle {
public:
    using AlertHandle::AlertHandle;

    void check(ApiStateInfo* stateInfo) {
        if (stateInfo-&gt;timeOut &gt; AlertHandle::getRule()-&gt;getMatchRule(
                stateInfo-&gt;api)) {
            AlertHandle::getNoti()-&gt;notify(-3, &quot;TimeOutAlert Handle&quot;);
        }
    }
};

class ApplicationContext {
public:
    ApplicationContext() {
        _rule = new AlertRule();
        _noti = new Notification();
        _alert = new Alert();
        _alert-&gt;addAlertHandle(new TpsAlertHandler(_rule, _noti));
        _alert-&gt;addAlertHandle(new ErrorAlertHandler(_rule, _noti));
        _alert-&gt;addAlertHandle(new TimeOutAlertHandler(_rule, _noti));
    }

    Alert* getAlert() {
        return _alert;
    }

private:
    AlertRule* _rule;
    Notification* _noti;
    Alert* _alert;
};

int main() {
    ApiStateInfo* stateInfo = new ApiStateInfo(&quot;Money&quot;, 10000, 20 ,30, 60);
    ApplicationContext* ctx = new ApplicationContext();
    ctx-&gt;getAlert()-&gt;check(stateInfo);
}
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package design_pattern

import &quot;fmt&quot;

type AlertRule struct {
}

func (*AlertRule) getMatchRule(api string) int64 {
    return 10;
}

type Notification struct {
}

func (*Notification) notify(level int64, msg string) {
    fmt.Println(&quot;level&quot;, level, &quot; msg&quot;, msg)
}

type ApiStateInfo struct {
    api string
    reqCount, errCount, duration, timeOut  int64
}

type AlertHandle interface {
    check(*ApiStateInfo)
}

type Alert struct {
    handleList []AlertHandle
}

func (a *Alert) addAlertHandle(handle AlertHandle) {
    a.handleList = append(a.handleList, handle)
}

func (a *Alert) check(info *ApiStateInfo) {
    for _, v := range a.handleList {
        v.check(info)
    }
}

type TpsAlertHandler struct {
    *AlertRule
    *Notification
}

func (t *TpsAlertHandler) check(info *ApiStateInfo) {
    tps := info.reqCount / info.duration

    if tps &gt; t.AlertRule.getMatchRule(info.api) {
        t.Notification.notify(-1, &quot;TpsAlert Handle&quot;)
    }
}

type ErrorAlertHandler struct {
    *AlertRule
    *Notification
}

func (t *ErrorAlertHandler) check(info *ApiStateInfo) {
    tps := info.reqCount / info.duration

    if tps &gt; t.AlertRule.getMatchRule(info.api) {
        t.Notification.notify(-2, &quot;ErrorAlert Handle&quot;)
    }
}

type TimeOutAlertHandler struct {
    *AlertRule
    *Notification
}

func (t *TimeOutAlertHandler) check(info *ApiStateInfo) {
    tps := info.reqCount / info.duration

    if tps &gt; t.AlertRule.getMatchRule(info.api) {
        t.Notification.notify(-3, &quot;TimeOutAlert Handle&quot;)
    }
}

type ApplicationContext struct {
    rule *AlertRule
    noti *Notification
    alert *Alert
}

func NewAppContext() *ApplicationContext {
    ctx := &amp;ApplicationContext{
        rule: &amp;AlertRule{},
        noti: &amp;Notification{},
        alert: &amp;Alert{},
    }

    tpsHandler := &amp;TpsAlertHandler{
        AlertRule: ctx.rule,
        Notification: ctx.noti,
    }

    errHandler := &amp;ErrorAlertHandler{
        AlertRule: ctx.rule,
        Notification: ctx.noti,
    }

    timeOutHandler := &amp;TimeOutAlertHandler{
        AlertRule: ctx.rule,
        Notification: ctx.noti,
    }

    ctx.alert.addAlertHandle(tpsHandler)
    ctx.alert.addAlertHandle(errHandler)
    ctx.alert.addAlertHandle(timeOutHandler)
    return ctx
}

import &quot;testing&quot;

func TestAlert(t *testing.T) {
    stateInfo := &amp;ApiStateInfo{&quot;Money&quot;, 10000, 20, 30, 60}
    ctx := NewAppContext()
    ctx.alert.check(stateInfo)
}
</code></pre>

<h4>指导思想</h4>

<ul>
<li>为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</li>
<li>提高代码扩展性 多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）。</li>
<li>多态、依赖注入、基于接口而非实现编程</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/24 07:49 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html'>设计模式之美</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15768853718636.html">
                
                  <h1>Chain of Responsibility</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>模式定义</h4>

<ul>
<li>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止</li>
</ul>

<h4>结构</h4>

<ul>
<li><img src="media/15768853718636/15806441423658.jpg" alt="" style="width:799px;"/></li>
</ul>

<h4>要点总结</h4>

<ul>
<li>Chain of Responsibility 7 模式的应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只有一个“，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化</li>
<li>应用了 Chain of Responsibility 模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。</li>
<li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li>
<li>这里发出这个请求的客户端并不知道这当中的哪一个对象最终处理这个请求，这样系统的更改可以在不影响客户端的情况下动态地重新组织和分配责任</li>
</ul>

<h4>cpp_demo</h4>

<pre class="line-numbers"><code class="language-cpp">//
// Created by eredinliu on 2020-02-03.
//

#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
using namespace std;

class Request {
public:
    Request(const string&amp; name, const string&amp; reason, int day_off) :
            name_(name), reason_(reason), day_off_(day_off) {}
    string name_, reason_;
    int day_off_;
};

class Responsible {
public:
    void SetSuperior(Responsible* superior) {this-&gt;superior_ = superior;}
    Responsible() {}

    bool SuperiorHandle(Request* request) {
        if (this-&gt;superior_ != nullptr) {
            return this-&gt;superior_-&gt;HandleRequest(request);
        }

        cout &lt;&lt; &quot;Out of power, reject \n&quot;;
        return false;
    }

    virtual bool HandleRequest(Request* request) = 0;

private:
    Responsible* superior_;
};

class Supervisor : public  Responsible {
public:
    bool HandleRequest(Request* request) {
        if (request-&gt;day_off_ &gt; 0 &amp;&amp; request-&gt;day_off_ &lt;= 2) {
            cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; permit \n&quot;;
            return true;
        }

        return this-&gt;SuperiorHandle(request);
    }
};

class Depmanager : public  Responsible {
public:
    bool HandleRequest(Request* request) {
        if (request-&gt;day_off_ &gt; 2 &amp;&amp; request-&gt;day_off_ &lt;= 5) {
            cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; permit \n&quot;;
            return true;
        }

        return this-&gt;SuperiorHandle(request);
    }
};

class CEO : public  Responsible {
public:
    bool HandleRequest(Request* request) {
        if (request-&gt;day_off_ &gt; 5 &amp;&amp; request-&gt;day_off_ &lt;= 12) {
            cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; permit \n&quot;;
            return true;
        }

        return this-&gt;SuperiorHandle(request);
    }
};

int main() {
    Responsible* ceo = new CEO();
    Responsible* dep = new Depmanager();
    Responsible* super = new Supervisor();
    dep-&gt;SetSuperior(ceo);
    super-&gt;SetSuperior(dep);

    Request* req = new Request(&quot;ming&quot;, &quot;sick&quot;, 10);
    super-&gt;HandleRequest(req);
}
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package design_pattern

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type Request struct {
    name, reason string
    dayOff int
}

type Responsible interface {
    HandlerRequest(*Request) bool
}

type Manager struct {
    superior Responsible
}

func (m *Manager) HandlerRequest(*Request) bool {
    return true
}

func (m *Manager) SetSuperior(superior Responsible) {
    m.superior = superior
}

func (m *Manager) SuperHandle(r *Request) bool {
    if m.superior != nil {
      return m.superior.HandlerRequest(r)
    }

    fmt.Println(&quot;out of power, reject&quot;)
    return false
}

type Supervisor struct {
    *Manager
}

func (s *Supervisor) HandlerRequest(r *Request) bool {
    
    if r.dayOff &gt; 0 &amp;&amp; r.dayOff &lt;=2 {
        fmt.Println(reflect.TypeOf(s).String() + &quot; Permit&quot;)
        return true
    }

    return s.SuperHandle(r)
}

func NewSupervisor() *Supervisor {
    return &amp;Supervisor{
        Manager: &amp;Manager{},
    }
}

type DepManager struct {
    *Manager
}

func (s *DepManager) HandlerRequest(r *Request) bool {

    if r.dayOff &gt; 2 &amp;&amp; r.dayOff &lt;=5 {
        fmt.Println(reflect.TypeOf(s).String() + &quot; Permit&quot;)
        return true
    }

    return s.SuperHandle(r)
}

func NewDepManager() *DepManager {
    return &amp;DepManager{
        Manager: &amp;Manager{},
    }
}

type CEO struct {
    *Manager
}

func (s *CEO) HandlerRequest(r *Request) bool {

    if r.dayOff &gt; 5 &amp;&amp; r.dayOff &lt;=22 {
        fmt.Println(reflect.TypeOf(s).String() + &quot; Permit&quot;)
        return true
    }

    return s.SuperHandle(r)
}

func NewCEO() *CEO{
    return &amp;CEO{
        Manager: &amp;Manager{},
    }
}

func TestRequestChain(t *testing.T) {
    c1 := NewCEO()
    c1.SetSuperior(nil)
    c2 := NewDepManager()
    c2.SetSuperior(c1)
    c3 := NewSupervisor()
    c3.SetSuperior(c2)

    request := &amp;Request{
        name: &quot;ming&quot;,
        reason: &quot;sick&quot;,
        dayOff: 23,
    }

    c3.HandlerRequest(request)
}
</code></pre>

<h4>python_code</h4>

<pre class="line-numbers"><code class="language-python">from abc import ABCMeta, abstractmethod

class Request(object):

    def __init__(self, name, reason, dayOff):
        self.name, self.reason, self.dayOff = name, reason, dayOff

class Responsible(metaclass=ABCMeta):

    @abstractmethod
    def HandleRequest(self, request):
        pass

    def __init__(self):
        self.__superior = None

    def set_superior(self, superior):
        self.__superior = superior

    def super_handler(self, request):
        if not self.__superior is None:
            return self.__superior.HandleRequest(request)

        print(&quot;out of power, reject&quot;)
        return False


class Supervisor(Responsible):

    def HandleRequest(self, request):
        if request.dayOff &gt; 0 and request.dayOff &lt;= 2:
           print(type(self).__name__ + &#39; permit&#39;)
           return True

        return self.super_handler(request)


class DepManager(Responsible):

    def HandleRequest(self, request):
        if request.dayOff &gt; 2 and request.dayOff &lt;= 5:
            print(type(self).__name__ + &#39; permit&#39;)
            return True

        return self.super_handler(request)

class CEO(Responsible):

    def HandleRequest(self, request):
        if request.dayOff &gt; 2 and request.dayOff &lt;= 5:
            print(type(self).__name__ + &#39; permit&#39;)
            return True

        return self.super_handler(request)


if __name__ == &#39;__main__&#39;:
    c1 = CEO()
    c2 = DepManager()
    c2.set_superior(c1)
    c3 = Supervisor()
    c3.set_superior(c2)

    req = Request(&quot;ming&quot;, &quot;sick&quot;, 2)
    c3.HandleRequest(req)
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/21 07:42 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15768019255107.html">
                
                  <h1>进程间通讯</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>三类queue</h4>

<pre class="line-numbers"><code class="language-python">from multiprocessing import Process, Queue
from queue import Queue
from multiprocessing import Manager
</code></pre>

<h4>进程间通讯</h4>

<pre class="line-numbers"><code class="language-python">import time
from multiprocessing import Process, Queue, Pool, Manager, Pipe


def producer(queue):
    queue.put(&quot;a&quot;)
    time.sleep(2)

def consumer(queue):
    time.sleep(2)
    data = queue.get()
    print(data)

if __name__ == &quot;__main__&quot;:
    queue = Queue(10)
    my_producer = Process(target=producer, args=(queue,))
    my_consumer = Process(target=consumer, args=(queue,))
    my_producer.start()
    my_consumer.start()
    my_producer.join()
    my_consumer.join()
</code></pre>

<h4>进程池间通讯</h4>

<pre class="line-numbers"><code class="language-python">import time
from multiprocessing import Process, Queue, Pool
# from queue import Queue
from multiprocessing import Manager

Manager().Queue()

def producer(queue):
    queue.put(&#39;a&#39;)
    time.sleep(2)

def consumer(queue):
    time.sleep(2)
    data = queue.get()
    print(data)

if __name__ == &#39;__main__&#39;:
    queue = Manager().Queue(10)
    pool = Pool(2)

    pool.apply_async(producer, args=(queue,))
    pool.apply_async(consumer, args=(queue,))

    pool.close()
    pool.join()
</code></pre>

<h4>Pipe通讯</h4>

<pre class="line-numbers"><code class="language-python">import time
from multiprocessing import Process, Queue, Pool, Manager, Pipe

def producer(pipe):
    pipe.send(&#39;bobby&#39;)
    pipe.send(&#39;ok&#39;)
    pipe.send(&#39;hello&#39;)

def consumer(pipe):
    print(pipe.recv())
    print(pipe.recv())
    print(pipe.recv())

if __name__ == &#39;__main__&#39;:
    recv_pipe, send_pipe = Pipe()
    my_pro = Process(target=producer, args=(send_pipe,))
    my_con = Process(target=consumer, args=(recv_pipe,))

    my_pro.start()
    my_con.start()
    my_pro.join()
    my_pro.join()
</code></pre>

<ul>
<li>pipe性能是高于queue</li>
</ul>

<h4>共享内存</h4>

<pre class="line-numbers"><code class="language-python">import time
from multiprocessing import Process, Queue, Pool, Manager, Pipe

def add_data(p_dict, key, value):
    p_dict[key] = value

if __name__ == &#39;__main__&#39;:
    progress_dict = Manager().dict()

    first_pro = Process(target=add_data, args=(progress_dict, &quot;bobby1&quot;, 22))
    second_pro = Process(target=add_data, args=(progress_dict, &quot;bobby2&quot;, 23))
    third_pro = Process(target=add_data, args=(progress_dict, &quot;bobby3&quot;, 24))

    first_pro.start()
    second_pro.start()
    third_pro.start()
    first_pro.join()
    second_pro.join()
    third_pro.join()
    print(progress_dict)
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/20 08:32 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15768004391774.html">
                
                  <h1>多进程同步</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>多进程</h4>

<pre class="line-numbers"><code class="language-python">import multiprocessing

import time

def get_html(n):
    time.sleep(n)
    print(&#39;sub_progress success&#39;)
    return n

if __name__ == &#39;__main__&#39;:
    progress = multiprocessing.Process(target=get_html, args=(2,))
    print(progress.pid)
    progress.start()
    print(progress.pid)
    progress.join()
    print(&#39;main progress end&#39;)
</code></pre>

<h4>进城池获取结果</h4>

<pre class="line-numbers"><code class="language-python">import multiprocessing

import time

def get_html(n):
    time.sleep(n)
    print(&#39;sub_progress success&#39;)
    return n

if __name__ == &#39;__main__&#39;:
    pool = multiprocessing.Pool(multiprocessing.cpu_count())
    result = pool.apply_async(get_html, args=(3,))
    pool.close()
    pool.join() //前面必须有close
    print(result.get())
</code></pre>

<h4>imap&amp;imap_unordered</h4>

<pre class="line-numbers"><code class="language-python">import multiprocessing
import  time
def get_html(n):
    time.sleep(n)
    print(&#39;sub_process sucess&#39;)
    return n

if __name__ == &#39;__main__&#39;:
    pool = multiprocessing.Pool(multiprocessing.cpu_count())

//不按顺序输出结果，谁先完成，谁先输出
    for result in pool.imap_unordered(get_html, [1,5,3]):
        print(&#39;{} sleep success&#39;.format(result))
//按照列表顺序输出结果
    for result in pool.imap(get_html, [1, 5, 3]):
        print(&#39;{} sleep success&#39;.format(result))
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/20 08:07 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15765398211231.html">
                
                  <h1>迭代器模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>动机</h4>

<ul>
<li><p>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访词其中包含的元素；同时这种“透明遍历”也为同一种算法在多种集合对象上进行操作”提供了可能。</p></li>
<li><p>使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。</p></li>
</ul>

<h4>要点总结</h4>

<ul>
<li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支</li>
<li>持同样的算法在不同的集合结构上进行操作。</li>
<li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/17 07:43 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758501024510.html">
                
                  <h1>多线程同步</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>死锁情况</h4>

<pre class="line-numbers"><code class="language-python">#2. 锁会引起死锁
#死锁的情况 A（a，b）
A(a、b)
acquire (a)
acquire (b)

B(a、b)
acquire (a)
acquire (b)
</code></pre>

<h4>可重入的锁</h4>

<ul>
<li>同一个线程里面，可以连续调用多次acquire,一定要注意acquire的次数</li>
<li>RLock可重入锁</li>
</ul>

<pre class="line-numbers"><code class="language-python">from threading import Lock, RLock, Condition

total = 0
lock = RLock()

def add():
    global lock
    global total
    for i in range(10000):
        lock.acquire()
        lock.acquire()
        total += 1
        lock.release()
        lock.release()

def desc():
    global total
    global lock
    for i in range(10000):
        # lock.acquire()
        lock.acquire()
        total -= 1
        lock.release()
        # lock.release()

import threading

thread1 = threading.Thread(target=add)
thread2 = threading.Thread(target=desc)

thread1.start()
thread2.start()
thread2.join()
thread2.join()
print(&quot;total {}&quot;.format(total))
</code></pre>

<h4>协同</h4>

<pre class="line-numbers"><code class="language-python">import threading

class XiaoAi(threading.Thread):
    def __init__(self, lock):
        super().__init__(name=&quot;xiaoai&quot;)
        self.lock = lock

    def run(self):
        self.lock.acquire()
        print(&quot;{}. at &quot;.format(self.name))
        self.lock.release()

        self.lock.acquire()
        print(&quot;{}. ok &quot;.format(self.name))
        self.lock.release()

class TianMao(threading.Thread):
    def __init__(self, lock):
        super().__init__(name=&quot;tiaomao&quot;)
        self.lock = lock

    def run(self):
        self.lock.acquire()
        print(&quot;{} : xiaoai roomate&quot;.format(self.name))
        self.lock.release()

        self.lock.acquire()
        print(&quot;{} : let&#39;s talk&quot;.format(self.name))
        self.lock.release()

if __name__ == &#39;__main__&#39;:
    lock = threading.Lock()
    thread1 = XiaoAi(lock)
    thread2 = TianMao(lock)
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
</code></pre>

<ul>
<li>condition启动顺序很重要,在调用with cond之后才能调用wait或者notify方法</li>
<li>condition有两层锁， 一把底层锁会在线程调用了wait方法的时候释放， 上面的锁会在每次调用wait的时候分配一把并放入到cond的等待队列中，等到notify方法的唤醒<br/>
xiaoai.start()</li>
</ul>

<pre class="line-numbers"><code class="language-python">import threading

class XiaoAi(threading.Thread):
    def __init__(self, cond):
        super().__init__(name=&quot;xiaoai&quot;)
        self.cond = cond

    def run(self):
        with self.cond:
            self.cond.wait()
            print(&#39;{}: 在 &#39;.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print(&#39;{}: 好阿 &#39;.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print(&#39;{}: 君住长江尾 &#39;.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print(&#39;{}: 共饮长江水 &#39;.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print(&#39;{}: 此恨何时已 &#39;.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print(&#39;{}: 定不负相思意 &#39;.format(self.name))
            self.cond.notify()

class TianMao(threading.Thread):
    def __init__(self, cond):
        super().__init__(name=&quot;天猫精灵&quot;)
        self.cond = cond

    def run(self):
        with self.cond:
            print(&#39;{}: 小爱同学 &#39;.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print(&#39;{}: 我们来对古诗吧 &#39;.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print(&#39;{}: 我住长江头 &#39;.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print(&#39;{}: 日日思君不见君 &#39;.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print(&#39;{}: 此水几时休 &#39;.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print(&#39;{}: 只愿君心似我心 &#39;.format(self.name))
            self.cond.notify()
            self.cond.wait()

if __name__ == &#39;__main__&#39;:
    from concurrent import futures
    cond = threading.Condition()
    xiaoai = XiaoAi(cond)
    tianmao = TianMao(cond)

    xiaoai.start()
    tianmao.start()
</code></pre>

<h4>ThreadPoolExcutor</h4>

<pre class="line-numbers"><code class="language-python">from concurrent.futures import ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED
from concurrent.futures import Future
from multiprocessing import Pool


import time

def get_html(times):
    time.sleep(times)
    print(&#39;get page {} process&#39;.format(times))
    return times

executor = ThreadPoolExecutor(max_workers=2)
</code></pre>

<h5>执行任务获取结果</h5>

<pre class="line-numbers"><code class="language-python">task1 = executor.submit(get_html, (3))
task2 = executor.submit(get_html, (2))
#
print(task1.result())
print(task2.cancel()) //取消结果
</code></pre>

<h5>多任务</h5>

<pre class="line-numbers"><code class="language-python">urls = [3, 2, 4]

all_task = [executor.submit(get_html, (url)) for url in urls]

for future in as_completed(all_task):
    data = future.result()
    print(&#39;get {} page&#39;.format(data))


#通过excutor获取已经完成的task
for data in executor.map(get_html, urls):
    print(&#39;get {} page&#39;.format(data))
</code></pre>

<h5>wait获取结果</h5>

<pre class="line-numbers"><code class="language-python">#wait
wait(all_task, return_when=FIRST_COMPLETED)
print(&#39;main&#39;)
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09 08:08 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15758463705532.html">
                
                  <h1>GIL</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>概念</h4>

<ul>
<li>全局解释器锁</li>
<li>CPython</li>
<li>GIL使得同一时刻只有一个线程在一个CPU上执行字节码</li>
<li>无法将多个线程映射到多个CPU上执行</li>
</ul>

<h4>释放的时机</h4>

<ul>
<li>根据执行字节码的行数或者执行的时间片来进行释放</li>
<li>遇到IO操作的时候释放</li>
</ul>

<h4>线程调度</h4>

<ul>
<li>对于IO操作来说，多线程和多进程性能差别不大</li>
</ul>

<h4>thread_demo</h4>

<pre class="line-numbers"><code class="language-python">import time
import threading


def get_detail_html(url):
    print(&quot;get detail html started&quot;)
    time.sleep(2)
    print(&quot;get detail html end&quot;)


def get_detail_url(url):
    print(&quot;get detail url started&quot;)
    time.sleep(2)
    print(&quot;get detail url end&quot;)

if __name__ == &quot;__main__&quot;:
   thread1 = threading.Thread(target=get_detail_html, args=(&quot;&quot;,))
   thread2 = threading.Thread(target=get_detail_url, args=(&quot;&quot;,))
   thread1.setDaemon(True)
   # thread2.setDaemon(True)
   start_time = time.time()
   thread1.start()
   thread2.start()

   print(&quot;last time : {}&quot;.format(time.time() - start_time))
</code></pre>

<h4>thread_join</h4>

<pre class="line-numbers"><code class="language-python">def get_detail_html(url):
    print(&quot;get detail html started&quot;)
    time.sleep(2)
    print(&quot;get detail html end&quot;)


def get_detail_url(url):
    print(&quot;get detail url started&quot;)
    time.sleep(4)
    print(&quot;get detail url end&quot;)

if __name__ == &quot;__main__&quot;:
   thread1 = threading.Thread(target=get_detail_html, args=(&quot;&quot;,))
   thread2 = threading.Thread(target=get_detail_url, args=(&quot;&quot;,))
   # thread1.setDaemon(True)
   # thread2.setDaemon(True)
   start_time = time.time()
   thread1.start()
   thread2.start()
   thread1.join()
   thread2.join()

   print(&quot;last time : {}&quot;.format(time.time() - start_time))
</code></pre>

<ul>
<li>deque在字节码的层面是安全的</li>
</ul>

<h4>集成Thread来实现多线程</h4>

<pre class="line-numbers"><code class="language-python">import time
import threading

class GetDetailHtml(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)

    def run(self):
        print(&quot;get detail html started&quot;)
        time.sleep(2)
        print(&quot;get detail html end&quot;)

class GetDetailUrl(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)

    def run(self):
        print(&quot;get detail url started&quot;)
        time.sleep(4)
        print(&quot;get detail url end&quot;)

if __name__ == &quot;__main__&quot;:
    thread1 = GetDetailHtml(&quot;get_detail_html&quot;)
    thread2 = GetDetailUrl(&quot;get_detail_url&quot;)
    start_time = time.time()
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()

    print(&quot;last time : {}&quot;.format(time.time() - start_time))

</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/09 07:06 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755898090270.html">
                
                  <h1>Composite</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>Composite</h4>

<ul>
<li>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</li>
</ul>

<h4>动机</h4>

<ul>
<li>在软件在某些情況下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</li>
<li>如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象样来处理复杂的对象容器？</li>
</ul>

<h4>结构</h4>

<ul>
<li><img src="media/15755898090270/15807244643257.jpg" alt="" style="width:828px;"/></li>
</ul>

<h4>要点</h4>

<ul>
<li>Composite 模式采用树形结构来实现普遍存在的对象容器从 i 致地く意用）处運对案和对象容器无需笑心处的是单个的对象，还的对象容器。</li>
<li>将“客户代码与复杂的对象容器结构“解耦是 Composite 的核心，解耦之后，客户代码将与纯粹的抽象接口-而非对象容器的内部实现机构-产生依赖，从而更能应对变化</li>
<li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li>
</ul>

<h4>Cpp_demo</h4>

<pre class="line-numbers"><code class="language-cpp">//
// Created by 刘超 on 2019-12-06.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;

using namespace std;

class Component {
public:
    virtual ~Component(){};
    virtual void Operation() = 0;
};

class Composite : public Component {
public:
    Composite(const string&amp; _name) : name(_name) {}
    ~Composite() {}

    void Operation() {
        for (auto&amp; iter : comList) {
            std::cout &lt;&lt; &quot;Composite Operation&quot; &lt;&lt; std::endl;
            iter-&gt;Operation();
        }
    }
    void Add(Component* com) {
        comList.push_back(com);
    }
    void Remove(Component* com) {
        comList.remove(com);
    }

private:
    list&lt;Component*&gt; comList;
    string name;
};

class Leaf : public Component {
public:
    Leaf(const string&amp; name) : _name(name) {}
    ~Leaf() {
        cout &lt;&lt; &quot;Leaf::~leaf()&quot; &lt;&lt; endl;
    }
    void Operation() {
        std::cout &lt;&lt; name &lt;&lt; &quot; Operation&quot; &lt;&lt; std::endl;
    }

private:
    string _name;
};

int main() {
    Composite* root = new Composite(&quot;root&quot;);
    Composite* node1 = new Composite(&quot;node1&quot;);
    Composite* node2 = new Composite(&quot;node2&quot;);
    Composite* node3 = new Composite(&quot;node3&quot;);
    Composite* node4 = new Composite(&quot;node4&quot;);
    Leaf* lf1 = new Leaf(&quot;lf1&quot;);
    Leaf* lf2 = new Leaf(&quot;lf2&quot;);

    root-&gt;Add(node1);
    node1-&gt;Add(node2);
    node2-&gt;Add(lf1);

    root-&gt;Add(node3);
    node3-&gt;Add(node4);
    node4-&gt;Add(lf2);
    root-&gt;Operation();
}
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package design_pattern

import (
    &quot;fmt&quot;
)

type IComponent interface {
    Display(dep int)
}

func (l *Leaf) Display(dep int) {
    fmt.Println(RetString(dep) + l.name)
}

type Leaf struct {
    name string
}

func RetString(depth int) string {
    var ret []byte
    for i := 0; i &lt; depth; i++ {
        ret = append(ret, &#39;-&#39;)
    }

    return string(ret)
}

func NewLeaf(name string) *Leaf {
    return &amp;Leaf{name: name}
}

type Composite struct {
    name string
    comList map[IComponent]bool
}

func NewComposite(name string) *Composite {
    return  &amp;Composite{
        comList: make(map[IComponent]bool),
        name: name,
    }
}

func (c *Composite) Add(i IComponent) {
    c.comList[i] = true
}

func (c *Composite) Remove(i IComponent) {
    delete(c.comList, i)
}

func (c *Composite) Display(dep int) {

    fmt.Println(RetString(dep) + c.name)
    for k, _ := range c.comList {
        k.Display(dep + 1)
    }
}
</code></pre>

<h4>python_code</h4>

<pre class="line-numbers"><code class="language-python">from abc import ABCMeta, abstractmethod

class Component(metaclass=ABCMeta):

    @abstractmethod
    def display(self):
        pass

class Composite(Component):

    def __init__(self, name):
        self.com_list = []
        self.__name = name

    def add(self, com):
        self.com_list.append(com)

    def remove(self, com):
        self.com_list.remove(com)

    def display(self):
        print(&#39;{} display&#39;.format(self.__name))
        for com in self.com_list:
            com.display()

class Leaf(Component):

    def __init__(self, name):
        self.__name = name

    def display(self):
        print(&#39;{} display&#39;.format(self.__name))

if __name__ == &#39;__main__&#39;:
    root = Composite(&quot;root&quot;)

    node1 = Composite(&quot;node1&quot;)
    node2 = Composite(&quot;node2&quot;)
    node3 = Composite(&quot;node3&quot;)
    node4 = Composite(&quot;node4&quot;)

    lf1 = Leaf(&quot;lf1&quot;)
    lf2 = Leaf(&quot;lf2&quot;)
    lf3 = Leaf(&quot;lf3&quot;)

    root.add(node1)
    node1.add(node2)
    node2.add(lf1)

    root.add(node3)
    node3.add(node4)
    node4.add(lf2)

    root.add(node4)

    root.display()

    print(&quot;=============================&quot;)
    root.remove(node1)
    root.display()
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/06 07:50 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_1.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_3.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>eredin-blog</h1>
                <div class="site-des">生命的意义是成为你自己！</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html"><strong>C++基础与提高</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html"><strong>设计模式之美</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
        
            <a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Linux性能优化实战</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15814649492497.html">Simple Factory</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814189410719.html">代码的可测试性</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814188057978.html">重构</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813811739408.html">tuple 使用</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813101435484.html">列表&字典&集合进阶用法</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
