<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	设计模式 -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-11-21T07:16:28+08:00" itemprop="datePublished">2019/11/21 07:16 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15742917885791.html" itemprop="url">
		中介模式</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8A%A8%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动机</h4>
<ul>
<li>在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li>
<li>在这种情況下，我们可使用一个“中介对象”来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</li>
</ul>
<h4><a id="%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模式定义</h4>
<ul>
<li>用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互</li>
<li>编译时依赖改成运行时依赖</li>
</ul>
<h4><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h4>
<p><img src="media/15742917885791/15803924036000.jpg" alt="" style="width:758px;" /></p>
<p><img src="media/15742917885791/15742924128916.jpg" alt="" style="width:986px;" /></p>
<h4><a id="%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>要点总结</h4>
<ul>
<li>
<p>将多个对象间复杂的关联关系解耦，Mediator 模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联“为“多个对象和一个中介者关联“，简化了系统的维护，抵御了可能的变化。</p>
</li>
<li>
<p>随着控制逻辑的复杂化，Mediator 具体对象的实现可能相当复杂。这时候可以对 Mediator 对象进行分解处理。</p>
</li>
<li>
<p>Facade 模式是解耦系统（单向）的对象关联关系；Mediator 模式是解耦系统内各个对象之间（双向）的关联关系。</p>
</li>
</ul>
<h4><a id="golang-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang_demo</h4>
<pre><code class="language-go">package desian_pattern_practise

import (
	&quot;reflect&quot;
	&quot;strings&quot;
	&quot;sync&quot;
)

var (
	mediator *Mediator
	monce sync.Once
)
type IColleague interface {
	GetMediator()
}

type Colleague struct {
	mediator IMediator
}


type IMediator interface {
	Execute(IColleague)
}

type Mediator struct {
	cd, cpu, videoCard, soundCard IColleague
}

func (m *Mediator) SetCD(cd IColleague) {
	m.cd = cd
}

func (m *Mediator) SetCpu(cpu IColleague) {
	m.cpu = cpu
}

func (m *Mediator) SetVideoCard(videoCard IColleague) {
	m.videoCard = videoCard
}

func (m *Mediator) SetSoundCard(soundCard IColleague) {
	m.soundCard = soundCard
}

func GetMediator() *Mediator {
	monce.Do(func() {
		mediator = &amp;Mediator{}
	})
	return mediator
}

func (m *Mediator) Execute(i IColleague) {
	switch i.(type) {
	case *CDDriver:
		m.cpu.(*Cpu).Process(i.(*CDDriver).data)
	case *Cpu:
		m.soundCard.(*SoundCard).Play(i.(*Cpu).audio)
		m.videoCard.(*VideoCard).Display(i.(*Cpu).video)
	}
}

type CDDriver struct {
	*Colleague
	data string
}

func NewCDDriver() *CDDriver {
	return &amp;CDDriver{
		Colleague: &amp;Colleague{
			mediator: GetMediator(),
		},
	}
}

func (c *CDDriver) GetMediator() {}

func (c *CDDriver) ReadData() {
	c.data = &quot;music, image&quot;
	println(reflect.TypeOf(c).String() + &quot; reading data&quot;)
	c.mediator.Execute(c)
}

type Cpu struct {
	*Colleague
	video, audio string
}

func NewCpu() *Cpu{
	return &amp;Cpu {
		Colleague: &amp;Colleague{
			mediator: GetMediator(),
		},
	}
}

func (c *Cpu) GetMediator() {}

func (c *Cpu) Process(data string) {
	sp := strings.Split(data, &quot;,&quot;)
	c.video = sp[1]
	c.audio = sp[0]
	println(reflect.TypeOf(c).String() + &quot; video &quot; + c.video + &quot; audio &quot;, c.audio)
	c.mediator.Execute(c)
}

type VideoCard struct {
	*Colleague
}

func NewVideoCard() *VideoCard{
	return &amp;VideoCard {
		Colleague: &amp;Colleague{
			mediator: GetMediator(),
		},
	}
}

func (v *VideoCard) GetMediator() {}

func (v *VideoCard) Display(data string) {
	println(reflect.TypeOf(v).String() + &quot; display data &quot;, data)
	v.mediator.Execute(v)
}

type SoundCard struct {
	*Colleague
}

func NewSoundCard() *SoundCard {
	return &amp;SoundCard {
		Colleague: &amp;Colleague{
			mediator: GetMediator(),
		},
	}
}

func (v *SoundCard) GetMediator() {}

func (v *SoundCard) Play(data string) {
	println(reflect.TypeOf(v).String() + &quot; play data &quot;, data)
	v.mediator.Execute(v)
}

package desian_pattern_practise

import &quot;testing&quot;

func TestMediator_Execute(t *testing.T) {
	cd:= NewCDDriver()
	cpu := NewCpu()
	soundCard := NewSoundCard()
	videoCard := NewVideoCard()
	GetMediator().SetCD(cd)
	GetMediator().SetCpu(cpu)
	GetMediator().SetSoundCard(soundCard)
	GetMediator().SetVideoCard(videoCard)
	cd.ReadData()
}
</code></pre>
<h4><a id="cpp-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cpp_demo</h4>
<pre><code class="language-C++">//
// Created by eredinliu on 2020-01-31.
//
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;typeinfo&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include &lt;vector&gt;

using namespace std;
using namespace boost;

class Mediator;
class Colleague {
public:
    Colleague(Mediator* _mediator) : mediator(_mediator) {}

protected:
    Mediator* mediator;
};

class Cpu;
class CDDriver;
class VideoCard;
class SoundCard;

class Mediator {
public:
    static Mediator* mediator;

    static Mediator* GetMediator() {
        static once_flag flag;
        call_once(flag, [&amp;](){mediator = new Mediator();});
        return mediator;
    }

    void SetCD(CDDriver* cd) {this-&gt;cd = cd;}

    void SetCpu(Cpu* cpu) {this-&gt;cpu = cpu;}

    void SetVideoCard(VideoCard* video) {this-&gt;videoCard = video;}

    void SetSoundCard(SoundCard* sound) {this-&gt;soundCard = sound;}

    void Execute(Colleague* colleague);
private:
    CDDriver* cd;
    Cpu* cpu;
    VideoCard *videoCard;
    SoundCard *soundCard;
    Mediator() {}
};

Mediator* Mediator::mediator = nullptr;

class CDDriver : public Colleague {
public:
    CDDriver(Mediator* _mediator) : Colleague(_mediator) {}

    void ReadData() {
        this-&gt;data = &quot;Music,Image&quot;;
        cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; reading data&quot; &lt;&lt; endl;
        this-&gt;mediator-&gt;Execute(this);
    }

    string&amp; GetData() {
        return this-&gt;data;
    }
private:
    string data;
};

class Cpu : public Colleague {
public:
    friend class Mediator;
    Cpu(Mediator* _mediator) : Colleague(_mediator) {}

    void Process(string&amp; data) {
        vector&lt;string&gt; str_vec;
        split(str_vec, data, is_any_of(&quot;,&quot;));
        this-&gt;video = str_vec[1];
        this-&gt;sound = str_vec[0];
        cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; video &quot; &lt;&lt; this-&gt;video &lt;&lt; &quot; sound &quot;
        &lt;&lt; this-&gt;sound &lt;&lt; endl;
        this-&gt;mediator-&gt;Execute(this);
    }

    string&amp; GetVideo() {return this-&gt;video;}

    string&amp; GetSound() {return this-&gt;sound;}
private:
    string video, sound;
};

class VideoCard : public Colleague {
public:
    VideoCard(Mediator* _mediator) : Colleague(_mediator) {}

    void Process(string&amp; data) {
        cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; display &quot; &lt;&lt; data &lt;&lt; endl;
        this-&gt;mediator-&gt;Execute(this);
    }
};

class SoundCard : public Colleague {
public:
    SoundCard(Mediator* _mediator) : Colleague(_mediator) {}

    void Process(string&amp; data) {
        cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; play &quot; &lt;&lt; data &lt;&lt; endl;
        this-&gt;mediator-&gt;Execute(this);
    }
};

void Mediator::Execute(Colleague* colleague) {
    if (colleague == cd) {
        cpu-&gt;Process(cd-&gt;GetData());
    } else if (colleague == cpu){
        soundCard-&gt;Process(cpu-&gt;GetSound());
        videoCard-&gt;Process(cpu-&gt;GetVideo());
    }
}

int main() {
    Mediator* mediator = Mediator::GetMediator();
    CDDriver* cd = new CDDriver(mediator);
    Cpu* cpu = new Cpu(mediator);
    SoundCard* soundCard = new SoundCard(mediator);
    VideoCard* videoCard = new VideoCard(mediator);
    mediator-&gt;SetCD(cd);
    mediator-&gt;SetCpu(cpu);
    mediator-&gt;SetSoundCard(soundCard);
    mediator-&gt;SetVideoCard(videoCard);
    cd-&gt;ReadData();
}
</code></pre>
<h4><a id="python-code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>python_code</h4>
<pre><code class="language-python">from abc import ABCMeta, abstractmethod

class Colleague(object):

    def __init__(self, mediator):
        self.mediator = mediator


def singleton(cls, *args, **kwargs):
    instance = {}

    def __singleton(*args, **kwargs):
        if cls not in instance:
            instance[cls] = cls(*args, **kwargs)
        return instance[cls]

    return __singleton

@singleton
class Mediator(object):

    def __init__(self):
        self.__cd = self.__cpu = self.__video_card = self.__sound_card = None

    def set_cd(self, cd):
        self.__cd  = cd

    def set_cpu(self, cpu):
        self.__cpu = cpu

    def set_video_card(self, video_card):
        self.__video_card = video_card

    def set_sound_card(self, sound_card):
        self.__sound_card = sound_card

    def execute(self, colleague):
        if colleague == self.__cd:
            self.__cpu.process(self.__cd.get_data())
        elif colleague == self.__cpu:
            self.__sound_card.process(colleague.get_sound())
            self.__video_card.process(colleague.get_video())

class CDDriver(Colleague):

    def __init__(self, mediator):
        super().__init__(mediator)
        self.__data = ''

    def read_data(self):
        self.__data = 'Music,Image'
        print(type(self).__name__, &quot; reading data&quot;)
        self.mediator.execute(self)

    def get_data(self):
        return self.__data

class Cpu(Colleague):

    def __init__(self, mediator):
        super().__init__(mediator)
        self.__video = self.__sound = ''

    def process(self, data):
        ret = data.split(',')
        self.__video = ret[1]
        self.__sound = ret[0]
        print(type(self).__name__, &quot; video {} sound {}&quot;.format(self.__video, 
                                                               self.__sound))

        self.mediator.execute(self)

    def get_video(self):
        return self.__video

    def get_sound(self):
        return self.__sound


class VideoCard(Colleague):

    def __init__(self, mediator):
        super().__init__(mediator)

    def process(self, data):
        print(type(self).__name__, &quot; display {}&quot;.format(data))


class SoundCard(Colleague):

    def __init__(self, mediator):
        super().__init__(mediator)

    def process(self, data):
        print(type(self).__name__, &quot; play {}&quot;.format(data))

if __name__ == '__main__':
    mediator = Mediator()
    cd = CDDriver(mediator)
    cpu = Cpu(mediator)
    sound_card = SoundCard(mediator)
    video_card = VideoCard(mediator)
    mediator.set_cd(cd)
    mediator.set_cpu(cpu)
    mediator.set_sound_card(sound_card)
    mediator.set_video_card(video_card)
    cd.read_data()
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-29T11:41:20+08:00" itemprop="datePublished">2019/12/29 11:41 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15775908801763.html" itemprop="url">
		Command</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%A1%8C%E4%B8%BA%E5%8F%98%E5%8C%96%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>行为变化模式</h4>
<ul>
<li>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化“模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</li>
</ul>
<h4><a id="%E5%8A%A8%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动机</h4>
<ul>
<li>在软件构建过程中，“行为请求者”与“行为实现者通常呈现一种“紧耦合”。但在某些场合一一比如需要对行为进行“记录、撤销/重（undo/redo)、事务”等处理,这种无法抵御变化的紧耦合是不合适 的</li>
<li>在这种情况下，如何将“行为请求者“与“行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li>
</ul>
<h4><a id="%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模式定义</h4>
<ul>
<li>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撇销的操作。</li>
</ul>
<h4><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h4>
<ul>
<li><img src="media/15775908801763/15811582346417.jpg" alt="" style="width:787px;" /></li>
</ul>
<h4><a id="%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>要点总结</h4>
<ul>
<li>Command 模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象</li>
<li>实现 Command 接口的具体命令对象 Concrete Command 有时侯根据需要可能会保存一些额外的状态信息。通过使用 Composite 模式可以将多个“命令“封装为ー个“复合命令“Macro Command</li>
<li>Command 模式与 C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command 以面向对象中的“接口-实现”来定义行为接口规范，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。</li>
<li>编译时多态</li>
<li>范形编程+函数对象解决了迭代器模式和命令模式</li>
<li>设计模式是弥补语言设计的不足出现的</li>
</ul>
<h4><a id="%E4%BC%98%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优缺点</h4>
<h5><a id="%E4%BC%98%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优点</h5>
<ul>
<li>将调用操作的类与知道如何执行该操作的对象解耦；</li>
<li>提供队列系统后，可以创建一系列命令；</li>
<li>添加新命令更加容易，并且无需更改现有代码；</li>
<li>还可以使用命令模式来定义回滚系统，例如，在向导示例中，我们可以编写一个回滚方法。</li>
</ul>
<h6><a id="%E7%BC%BA%E7%82%B9%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缺点：</h6>
<ul>
<li>为了实现目标，需要大量的类和对象进行协作。应用程序开发人员为了正确开发这些类，需要倍加小心；</li>
<li>每个单独的命令都是一个ConcreteCommand类，从而增加了需要实现和维护的类的数量。</li>
</ul>
<h4><a id="cpp-code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cpp_code</h4>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

class Command {
    public:
    virtual void execute() = 0;
    Command() {}
};

class Barbecue {
    public:
    void bake_mutton() {cout &lt;&lt; &quot;bake mutton \n&quot;;}
    void bake_chicken() {cout &lt;&lt; &quot;bake chicken\n&quot;;}
};

class MuttonCommand : public Command {
    public:
    MuttonCommand(Barbecue* barbecue) : barbecue_(barbecue) {}

    void execute() {
        this-&gt;barbecue_-&gt;bake_mutton();
    }
    private:
    Barbecue* barbecue_ = nullptr;
};

class ChickenCommand : public Command {
    public:
    ChickenCommand(Barbecue* barbecue) : barbecue_(barbecue) {}

    void execute() {
        this-&gt;barbecue_-&gt;bake_chicken();
    }
    private:
    Barbecue* barbecue_ = nullptr;
};

class Waiter {
    public:
    Waiter() {}

    void AddOrder(Command* cmd) {
        this-&gt;orders.push_back(cmd);
    }

    void DelOrder(Command* cmd) {
        this-&gt;orders.remove(cmd);
    }

    void Notify() {
        for (auto it : this-&gt;orders) {
            it-&gt;execute();
        }
    }
    private:
    list&lt;Command*&gt; orders;
};

int main() {
    auto boy = new Barbecue();
    Command* cmd1 = new MuttonCommand(boy);
    Command* cmd2 = new MuttonCommand(boy);
    Command* cmd3 = new ChickenCommand(boy);
    auto waiter = new Waiter();
    waiter-&gt;AddOrder(cmd1);
    waiter-&gt;AddOrder(cmd2);
    waiter-&gt;AddOrder(cmd3);
    waiter-&gt;Notify();
}
</code></pre>
<h4><a id="golang-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang_demo</h4>
<pre><code class="language-go">package desian_pattern_practise


import &quot;fmt&quot;

type Command interface {
	ExecuteCommand()
}

type Barbecue struct {}

func (b *Barbecue) BakeMutton() {
	fmt.Println(&quot;BakeMutton&quot;)
}

func (b *Barbecue) BakeChicken() {
	fmt.Println(&quot;BakeChicken&quot;)
}

type MuttonCommand struct {
	*Barbecue
}

func NewMuttonCommand(boy *Barbecue) *MuttonCommand {
	return &amp;MuttonCommand{
		Barbecue: boy,
	}
}

func (m *MuttonCommand) ExecuteCommand() {
	m.Barbecue.BakeMutton()
}

type BakeCommand struct {
	*Barbecue
}

func NewBakeCommand(boy *Barbecue) *BakeCommand {
	return &amp;BakeCommand{
		Barbecue: boy,
	}
}

func (b *BakeCommand) ExecuteCommand() {
	b.Barbecue.BakeChicken()
}

type Waiter struct {
	orders map[Command]bool
}

func NewWaiter() *Waiter {
	return &amp;Waiter{
		orders: make(map[Command]bool),
	}
}

func (w *Waiter) AddOrder(cmd Command) {
	w.orders[cmd] = true
}

func (w *Waiter) CancelOrder(cmd Command) {
	delete(w.orders, cmd)
}

func (w *Waiter) Notify() {
	for k, _ := range w.orders {
		k.ExecuteCommand()
	}
}
func TestBakeCommand_ExecuteCommand(t *testing.T) {
	boy := &amp;Barbecue{}

	cmd1, cmd2  := NewMuttonCommand(boy), NewMuttonCommand(boy)
	cmd3 := NewBakeCommand(boy)

	waiter := NewWaiter()
	waiter.AddOrder(cmd1)

	waiter.AddOrder(cmd2)

	waiter.AddOrder(cmd3)

	waiter.CancelOrder(cmd1)
	waiter.Notify()
}
</code></pre>
<h4><a id="python-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>python_demo</h4>
<pre><code class="language-python">from abc import ABCMeta, abstractmethod

class Command(metaclass=ABCMeta):

    @abstractmethod
    def execute_command(self):
        pass

class Barbecue(object):

    def bake_mutton(self):
        print(&quot;bake mutton&quot;)

    def bake_chicken(self):
        print(&quot;bake chicken&quot;)

class MuttonCommand(Command):

    def __init__(self, barbecue):
        self.barbecue = barbecue

    def execute_command(self):
        self.barbecue.bake_mutton()


class ChickenCommand(Command):

    def __init__(self, barbecue):
        self.barbecue = barbecue

    def execute_command(self):
        self.barbecue.bake_chicken()

class Waiter(object):

    def __init__(self):
        self.__orders = []

    def add_order(self, cmd):
        self.__orders.append(cmd)

    def cancel_order(self, cmd):
        self.__orders.remove(cmd)

    def notify(self):
        for order in self.__orders:
            order.execute_command()

if __name__ == '__main__':
    boy = Barbecue()

    cmd1 = MuttonCommand(boy)
    cmd2 = MuttonCommand(boy)
    cmd3 = ChickenCommand(boy)

    waiter = Waiter()

    waiter.add_order(cmd1)
    waiter.add_order(cmd2)
    waiter.add_order(cmd3)

    waiter.notify()
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-21T07:42:51+08:00" itemprop="datePublished">2019/12/21 07:42 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15768853718636.html" itemprop="url">
		Chain of Responsibility</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模式定义</h4>
<ul>
<li>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止</li>
</ul>
<h4><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h4>
<ul>
<li><img src="media/15768853718636/15806441423658.jpg" alt="" style="width:799px;" /></li>
</ul>
<h4><a id="%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>要点总结</h4>
<ul>
<li>Chain of Responsibility 7 模式的应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只有一个“，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化</li>
<li>应用了 Chain of Responsibility 模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。</li>
<li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li>
<li>这里发出这个请求的客户端并不知道这当中的哪一个对象最终处理这个请求，这样系统的更改可以在不影响客户端的情况下动态地重新组织和分配责任</li>
</ul>
<h4><a id="cpp-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cpp_demo</h4>
<pre><code class="language-C++">//
// Created by eredinliu on 2020-02-03.
//

#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
using namespace std;

class Request {
public:
    Request(const string&amp; name, const string&amp; reason, int day_off) :
            name_(name), reason_(reason), day_off_(day_off) {}
    string name_, reason_;
    int day_off_;
};

class Responsible {
public:
    void SetSuperior(Responsible* superior) {this-&gt;superior_ = superior;}
    Responsible() {}

    bool SuperiorHandle(Request* request) {
        if (this-&gt;superior_ != nullptr) {
            return this-&gt;superior_-&gt;HandleRequest(request);
        }

        cout &lt;&lt; &quot;Out of power, reject \n&quot;;
        return false;
    }

    virtual bool HandleRequest(Request* request) = 0;

private:
    Responsible* superior_;
};

class Supervisor : public  Responsible {
public:
    bool HandleRequest(Request* request) {
        if (request-&gt;day_off_ &gt; 0 &amp;&amp; request-&gt;day_off_ &lt;= 2) {
            cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; permit \n&quot;;
            return true;
        }

        return this-&gt;SuperiorHandle(request);
    }
};

class Depmanager : public  Responsible {
public:
    bool HandleRequest(Request* request) {
        if (request-&gt;day_off_ &gt; 2 &amp;&amp; request-&gt;day_off_ &lt;= 5) {
            cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; permit \n&quot;;
            return true;
        }

        return this-&gt;SuperiorHandle(request);
    }
};

class CEO : public  Responsible {
public:
    bool HandleRequest(Request* request) {
        if (request-&gt;day_off_ &gt; 5 &amp;&amp; request-&gt;day_off_ &lt;= 12) {
            cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; permit \n&quot;;
            return true;
        }

        return this-&gt;SuperiorHandle(request);
    }
};

int main() {
    Responsible* ceo = new CEO();
    Responsible* dep = new Depmanager();
    Responsible* super = new Supervisor();
    dep-&gt;SetSuperior(ceo);
    super-&gt;SetSuperior(dep);

    Request* req = new Request(&quot;ming&quot;, &quot;sick&quot;, 10);
    super-&gt;HandleRequest(req);
}
</code></pre>
<h4><a id="golang-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang_demo</h4>
<pre><code class="language-go">package design_pattern

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type Request struct {
	name, reason string
	dayOff int
}

type Responsible interface {
	HandlerRequest(*Request) bool
}

type Manager struct {
	superior Responsible
}

func (m *Manager) HandlerRequest(*Request) bool {
	return true
}

func (m *Manager) SetSuperior(superior Responsible) {
	m.superior = superior
}

func (m *Manager) SuperHandle(r *Request) bool {
	if m.superior != nil {
	  return m.superior.HandlerRequest(r)
	}

	fmt.Println(&quot;out of power, reject&quot;)
	return false
}

type Supervisor struct {
	*Manager
}

func (s *Supervisor) HandlerRequest(r *Request) bool {
	
	if r.dayOff &gt; 0 &amp;&amp; r.dayOff &lt;=2 {
		fmt.Println(reflect.TypeOf(s).String() + &quot; Permit&quot;)
		return true
	}

	return s.SuperHandle(r)
}

func NewSupervisor() *Supervisor {
	return &amp;Supervisor{
		Manager: &amp;Manager{},
	}
}

type DepManager struct {
	*Manager
}

func (s *DepManager) HandlerRequest(r *Request) bool {

	if r.dayOff &gt; 2 &amp;&amp; r.dayOff &lt;=5 {
		fmt.Println(reflect.TypeOf(s).String() + &quot; Permit&quot;)
		return true
	}

	return s.SuperHandle(r)
}

func NewDepManager() *DepManager {
	return &amp;DepManager{
		Manager: &amp;Manager{},
	}
}

type CEO struct {
	*Manager
}

func (s *CEO) HandlerRequest(r *Request) bool {

	if r.dayOff &gt; 5 &amp;&amp; r.dayOff &lt;=22 {
		fmt.Println(reflect.TypeOf(s).String() + &quot; Permit&quot;)
		return true
	}

	return s.SuperHandle(r)
}

func NewCEO() *CEO{
	return &amp;CEO{
		Manager: &amp;Manager{},
	}
}

func TestRequestChain(t *testing.T) {
	c1 := NewCEO()
	c1.SetSuperior(nil)
	c2 := NewDepManager()
	c2.SetSuperior(c1)
	c3 := NewSupervisor()
	c3.SetSuperior(c2)

	request := &amp;Request{
		name: &quot;ming&quot;,
		reason: &quot;sick&quot;,
		dayOff: 23,
	}

	c3.HandlerRequest(request)
}
</code></pre>
<h4><a id="python-code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>python_code</h4>
<pre><code class="language-python">from abc import ABCMeta, abstractmethod

class Request(object):

    def __init__(self, name, reason, dayOff):
        self.name, self.reason, self.dayOff = name, reason, dayOff

class Responsible(metaclass=ABCMeta):

    @abstractmethod
    def HandleRequest(self, request):
        pass

    def __init__(self):
        self.__superior = None

    def set_superior(self, superior):
        self.__superior = superior

    def super_handler(self, request):
        if not self.__superior is None:
            return self.__superior.HandleRequest(request)

        print(&quot;out of power, reject&quot;)
        return False


class Supervisor(Responsible):

    def HandleRequest(self, request):
        if request.dayOff &gt; 0 and request.dayOff &lt;= 2:
           print(type(self).__name__ + ' permit')
           return True

        return self.super_handler(request)


class DepManager(Responsible):

    def HandleRequest(self, request):
        if request.dayOff &gt; 2 and request.dayOff &lt;= 5:
            print(type(self).__name__ + ' permit')
            return True

        return self.super_handler(request)

class CEO(Responsible):

    def HandleRequest(self, request):
        if request.dayOff &gt; 2 and request.dayOff &lt;= 5:
            print(type(self).__name__ + ' permit')
            return True

        return self.super_handler(request)


if __name__ == '__main__':
    c1 = CEO()
    c2 = DepManager()
    c2.set_superior(c1)
    c3 = Supervisor()
    c3.set_superior(c2)

    req = Request(&quot;ming&quot;, &quot;sick&quot;, 2)
    c3.HandleRequest(req)
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-11-02T08:09:12+08:00" itemprop="datePublished">2019/11/02 08:09 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15726533521164.html" itemprop="url">
		Strategy</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h5><a id="%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模式定义</h5>
<ul>
<li>定义一系列算法，把它们一个个封装起来，并且使它们可互相替換（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。《设计模式》GoF</li>
</ul>
<h5><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h5>
<ul>
<li><img src="media/15726533521164/15808956032984.jpg" alt="" style="width:674px;" /></li>
</ul>
<h5><a id="%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>要点总结</h5>
<p>要点总结</p>
<ul>
<li>Strategy。及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切換。</li>
<li>Strategy 模式提供了用条件判断语句以外的另一种选择，消除条件判断语，就是在解耦合。含有许多条件判断语句的代码通常都需要 Strategy 模式。</li>
<li>if else 出现的条件后，就是策略模式出现的机会，如果if else 条件保持绝对不变的情况下，不适用策略模式</li>
<li>如果 Strategyy 对象没有实例变量，那么各个上下文可以共享同 Strategy 对象，从而节省对象开销</li>
</ul>
<h5><a id="%E5%8A%A8%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动机</h5>
<ul>
<li>代码段最好放在高级缓存</li>
<li>代码过长会占用CPU高级缓存的位置</li>
<li>适用扩展的算法应对变化</li>
</ul>
<h4><a id="cpp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cpp</h4>
<pre><code class="language-C++">//
// Created by eredinliu on 2020-02-05.
//

#include &lt;iostream&gt;

using namespace std;

class Context;
class Strategy {
public:
    virtual void Pay(Context* ctx) = 0;
    Strategy() {}
};

class Context {
public:
    friend class Bank;
    friend class Cash;
    Context() {}
    Context(const string&amp; name, const string card_id,float money) :
            name_(name), card_id_(card_id),
            money_(money){}

    void SetStrategy(Strategy* strategy) {
        this-&gt;strategy_ = strategy;
    }

    void Pay() {
        if (this-&gt;strategy_ != nullptr) {
            this-&gt;strategy_-&gt;Pay(this);
        }
    }
private:
    Strategy* strategy_ = nullptr;
    string name_, card_id_;
    float money_;
};

class Bank : public Strategy {
public:
    void Pay(Context* ctx) {
        cout &lt;&lt; &quot;Pay &quot; &lt;&lt; ctx-&gt;money_ &lt;&lt; &quot; to &quot; &lt;&lt; ctx-&gt;name_ &lt;&lt; &quot; by bank &quot;
             &lt;&lt; ctx-&gt;card_id_ &lt;&lt; endl;
    }
};

class Cash : public Strategy {
public:
    void Pay(Context* ctx) {
        cout &lt;&lt; &quot;Pay &quot; &lt;&lt; ctx-&gt;money_ &lt;&lt; &quot; to &quot; &lt;&lt; ctx-&gt;name_ &lt;&lt; &quot; by cash \n&quot;;
    }
};

int main() {
    Context* ctx = new Context(&quot;ming&quot;, &quot;01234&quot;, 523.0);
    Strategy* bank = new Bank();
    ctx-&gt;SetStrategy(bank);
    ctx-&gt;Pay();
    Strategy* cash = new Cash();
    ctx-&gt;SetStrategy(cash);
    ctx-&gt;Pay();
}
</code></pre>
<h5><a id="golang" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang</h5>
<pre><code class="language-go">package strategy

import &quot;fmt&quot;

type PaymentContext struct {
	Name, CardID string
	Money        int
	payment      PaymentStrategy
}

func NewPaymentContext(name, cardid string, money int, payment PaymentStrategy) *PaymentContext {
	return &amp;PaymentContext{
		Name:    name,
		CardID:  cardid,
		Money:   money,
		payment: payment,
	}
}

func (p *PaymentContext) Pay() {
	p.payment.Pay(p)
}

type PaymentStrategy interface {
	Pay(*PaymentContext)
}

type Cash struct{}

func (*Cash) Pay(ctx *PaymentContext) {
	fmt.Printf(&quot;Pay $%d to %s by cash&quot;, ctx.Money, ctx.Name)
}

type Bank struct{}

func (*Bank) Pay(ctx *PaymentContext) {
	fmt.Printf(&quot;Pay $%d to %s by bank account %s&quot;, ctx.Money, ctx.Name, ctx.CardID)
}

func TestPayByCash(t *testing.T) {
	ctx := NewPaymentContext(&quot;Ada&quot;, &quot;&quot;, 123, &amp;Cash{})
	ctx.Pay()
	// Output:
	// Pay $123 to Ada by cash
}

func TestPayByBank(t *testing.T) {
	ctx := NewPaymentContext(&quot;Bob&quot;, &quot;0002&quot;, 888, &amp;Bank{})
	ctx.Pay()
	// Output:
	// Pay $888 to Bob by bank account 0002
}
</code></pre>
<h4><a id="python-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>python_demo</h4>
<pre><code class="language-python">from abc import ABCMeta, abstractmethod

class Strategy(metaclass=ABCMeta):
    @abstractmethod
    def algorithm(self):
        pass

class ConcreteA(Strategy):
    def algorithm(self):
        print(&quot;ConcreteA&quot;)

class ConcreteB(Strategy):
    def algorithm(self):
        print(&quot;ConcreteB&quot;)

class ConcreteC(Strategy):
    def algorithm(self):
        print(&quot;ConcreteC&quot;)

class Context(object):

    def __init__(self, strategy):
        self.strategy = strategy

    def execute(self):
        self.strategy.algorithm()

    def set_execute(self, strategy):
        self.strategy = strategy

if __name__ == '__main__':
    c1 = ConcreteA()
    c2 = ConcreteB()
    c3 = ConcreteC()
    context = Context(c1)
    context.execute()
    context.set_execute(c2)
    context.execute()
    context.set_execute(c3)
    context.execute()
</code></pre>
<h4><a id="python-demo2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>python_demo2</h4>
<pre><code class="language-python">from abc import ABCMeta, abstractmethod

class PaymentStrategy(metaclass=ABCMeta):
    def pay(payment_context):
        pass

class Cash(PaymentStrategy):

    def __init__(self, name, money):
        self.money, self.name  = money, name
    def pay(self):
        print(&quot;Pay {} to {} by cash&quot;.format(self.money, self.name))

class Bank(PaymentStrategy):
    def __init__(self, name, money, card):
        self.money, self.name, self.card = money, name, card
    def pay(self):
        print(&quot;Pay {} to {} by bank {}&quot;.format(self.money, self.name,
                                            self.card))

class Context(object):

    def __init__(self, strategy):
        self.strategy = strategy

    def pay(self):
        self.strategy.pay()

    def set_strategy(self, strategy):
        self.strategy = strategy

if __name__ == '__main__':
    cash = Cash(&quot;Ada&quot;, 123)
    bank = Bank(&quot;Bob&quot;, 124, &quot;0001&quot;)
    ctx = Context(cash)
    ctx.pay()
    ctx.set_strategy(bank)
    ctx.pay()
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-11-02T08:10:24+08:00" itemprop="datePublished">2019/11/02 08:10 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15726534242869.html" itemprop="url">
		Observer</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组件协作模式</h4>
<ul>
<li><img src="media/15726534242869/15726538652702.jpg" alt="" style="width:930px;" /></li>
</ul>
<h4><a id="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多重继承</h4>
<ul>
<li>一个是主的继承类</li>
<li>其他都是抽象的接口</li>
</ul>
<h4><a id="%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模式定义</h4>
<ul>
<li>定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</li>
</ul>
<h4><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h4>
<ul>
<li><img src="media/15726534242869/15726577987603.jpg" alt="" style="width:887px;" /></li>
<li><img src="media/15726534242869/15801778196036.jpg" alt="" style="width:972px;" /></li>
<li>Subject和Object是稳定的</li>
<li>ConcreteSubject和ConcreteObserver</li>
</ul>
<h4><a id="%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>要点总结</h4>
<ul>
<li>
<p>使用面向对象的抽象，Observer 模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。</p>
</li>
<li>
<p>目标发送通知时，无需指定观察者，通知（可以携带通知信息作</p>
</li>
<li>
<p>为参数）会自动传播。</p>
</li>
<li>
<p>观察者自己決定是否需要订阋通知，目标对象对此无所知。Observers 模式是基于事件的 UI 框架中非常常用的设计模式，也是</p>
</li>
<li>
<p>MVC 模式的一个重要组成部分。</p>
</li>
</ul>
<h4><a id="code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>code</h4>
<pre><code class="language-go">package observer

import &quot;fmt&quot;

type Subject struct {
	observers []Observer
	context   string
}

func NewSubject() *Subject {
	return &amp;Subject{
		observers: make([]Observer, 0),
	}
}

func (s *Subject) Attach(o Observer) {
	s.observers = append(s.observers, o)
}

func (s *Subject) notify() {
	for _, o := range s.observers {
		o.Update(s)
	}
}

func (s *Subject) UpdateContext(context string) {
	s.context = context
	s.notify()
}

type Observer interface {
	Update(*Subject)
}

type Reader struct {
	name string
}

func NewReader(name string) *Reader {
	return &amp;Reader{
		name: name,
	}
}

func (r *Reader) Update(s *Subject) {
	fmt.Printf(&quot;%s receive %s\n&quot;, r.name, s.context)
}

package observer

func ExampleObserver() {
	subject := NewSubject()
	reader1 := NewReader(&quot;reader1&quot;)
	reader2 := NewReader(&quot;reader2&quot;)
	reader3 := NewReader(&quot;reader3&quot;)
	subject.Attach(reader1)
	subject.Attach(reader2)
	subject.Attach(reader3)

	subject.UpdateContext(&quot;observer mode&quot;)
	// Output:
	// reader1 receive observer mode
	// reader2 receive observer mode
	// reader3 receive observer mode
}
</code></pre>
<h4><a id="python-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>python_demo</h4>
<pre><code class="language-python">from abc import ABCMeta, abstractmethod


class Subject(metaclass=ABCMeta):
    @abstractmethod
    def attach(self, observer):
        pass

    @abstractmethod
    def notify(self):
        pass


class Boss(Subject):

    def __init__(self):
        self.observers = []
        self.action = ''

    def attach(self, observer):
        self.observers.append(observer)

    def notify(self):
        for val in self.observers:
            val.update()

    def set_section(self):
        self.action = 'Boss is come back'


class IObject(metaclass=ABCMeta):
    @abstractmethod
    def update(self):
        pass

    def __init__(self, name, subject):
        self.name, self.subject = name, subject


class StockObserver(IObject):

    def update(self):
        print('{} close stock and work {}'.format(self.name,
                                                  self.subject.action))


class NBAObserver(IObject):

    def update(self):
        print('{} close NBA and work {}'.format(self.name,
                                                  self.subject.action))

if __name__ == '__main__':
    boss = Boss()

    observer1 = StockObserver(&quot;Jim&quot;, boss)
    observer2 = NBAObserver(&quot;Bob&quot;, boss)

    boss.attach(observer1)
    boss.attach(observer2)

    boss.set_section()
    boss.notify()
</code></pre>
<h4><a id="python-demo3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>python_demo3</h4>
<pre><code class="language-python">from  abc import ABCMeta, abstractmethod

class Observable(object):

    def __init__(self):
        self.__observers = []

    def add(self, observer):
        self.__observers.append(observer)

    def remove(self, observer):
        self.__observers.remove(observer)

    def notify(self, object=0):
        for o in self.__observers:
            o.update(self, object)

class WaterHeater(Observable):

    def __init__(self):
        super().__init__()
        self.__temperature = 25

    def get_temperature(self):
        return self.__temperature

    def set_temperature(self, temp):
        self.__temperature = temp
        print(&quot;current temperature is {} C&quot;.format(self.__temperature))
        self.notify()

class Observer(metaclass=ABCMeta):

    @abstractmethod
    def update(self, observable, object=0):
        pass

class WasingMode(Observer):

    def update(self, observable, object=0):
        if isinstance(observable, WaterHeater) and observable.get_temperature()\
                &gt;=50 and observable.get_temperature() &lt;= 70:
            print('water temperature is suit for bath')

class DrinkingMode(Observer):

    def update(self, observable, object):
        if isinstance(observable, WaterHeater) and observable.get_temperature()\
                &gt;= 100:
            print('water temperature is suit for drink')

def test_water():
    water = WaterHeater()
    wash_mode = WasingMode()
    drink_mode = DrinkingMode()
    water.add(wash_mode)
    water.add(drink_mode)
    water.set_temperature(40)
    water.set_temperature(60)
    water.set_temperature(100)

#test_water()

class Account(Observable):
    ip_region = {
        &quot;104.47.18.9&quot;: 'hangzhou',
        '67.218.147.69': 'LA',
        '33.12.33.123': 'shanghai'
    }
    def __init__(self):
        super().__init__()
        self.__ip = {}
        self.__region = {}

    def login(self, name, ip):
        region = self.__get_region(ip)
        if self.__is_long_distance(name, region):
            self.notify({'name': name, 'ip':ip, 'region':region})
        self.__region[name] = region
        self.__ip = ip

    def __get_region(self, ip):
        region = Account.ip_region.get(ip)
        return '' if region is None else region

    def __is_long_distance(self, name, region):
        latest_region = self.__region.get(name)
        return latest_region is not None and latest_region != region

class SmsSender(Observer):

    def update(self, observable, object):
        print('msg send name {} region {} login ip {} '.format(
            object['name'], object['region'], object['ip']))

class MailSender(Observer):

    def update(self, observable, object):
        print('mail send name {} region {} login ip {}'.format(
            object['name'], object['region'], object['ip']
        ))

def test_region():
    account = Account()
    account.add(SmsSender())
    account.add(MailSender())
    account.login('Tony', '104.47.18.9')
    account.login('Tony', '67.218.147.69')
    account.login('Tony', '33.12.33.123')

test_region()
</code></pre>
<h4><a id="golang-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang_demo</h4>
<pre><code class="language-go">package desian_pattern_practise

type ISubject interface {
	Attach(IObserver)
	Detach(IObserver)
	Notify()
}

type IObserver interface {
	Update()
}

type Observer struct {
	sub ISubject
}

type Subject struct {
	observer map[IObserver]bool
	temp float64
}

func (w *Subject) Attach(IObserver IObserver) {
	w.observer[IObserver] = true
}

func (w *Subject) Detach(IObserver IObserver) {
	delete(w.observer, IObserver)
}

func (w *Subject) Notify() {
	for k, _ := range w.observer {
		k.Update()
	}
}

type WaterHeater struct {
	*Subject
	temp float64
}

func NewWaterHeater() *WaterHeater {
	return &amp;WaterHeater {
		Subject: &amp;Subject{
			observer: make(map[IObserver]bool),
		},
		temp: 25.0,
	}
}

func (w *WaterHeater) SetTemperature(temp float64) {
	w.temp = temp
	w.Notify()
}

type WashingMode struct {
	*Observer
}

func NewWashingMode(sub ISubject) *WashingMode {
	return &amp;WashingMode{
		Observer: &amp;Observer{sub},
	}
}

func (w *WashingMode) Update() {
	if w.sub.(*WaterHeater).temp &gt;= 50 &amp;&amp;  w.sub.(*WaterHeater).temp &lt;= 70 {
		println(&quot;Subject temperature is suitable for bath&quot;)
	}
}


type DrinkingMode struct {
	*Observer
}

func (w *DrinkingMode) Update() {
	if w.sub.(*WaterHeater).temp &gt;= 100 {
		println(&quot;Subject temperature is suitable for drink&quot;)
	}
}

func NewDrinkingMode(sub ISubject) *DrinkingMode {
	return &amp;DrinkingMode{
		Observer: &amp;Observer{sub},
	}
}

var ip_region = map[string]string {
 &quot;104.47.18.9&quot;: &quot;hangzhou&quot;,
 &quot;67.218.147.69&quot;: &quot;LA&quot;,
 &quot;33.12.33.123&quot;: &quot;shanghai&quot;,
}

type Account struct {
	*Subject
	ip string
	region map[string]string
}

func (a *Account) Login(name, ip string) {
	region, ok := ip_region[ip]

	if !ok {
		println(&quot;not in record&quot;)
		return
	}

	if a.isLongDistance(name, region) {
		a.region[name] = region
		a.ip = ip
		a.Notify()
		return
	}

	a.region[name] = region
	a.ip = ip
}

func NewAccount() *Account {
	return &amp;Account{
		Subject: &amp;Subject{
			observer: make(map[IObserver]bool),
		},
		region: make(map[string]string),
	}
}


func (a *Account) isLongDistance(name, region string) bool {
	if val, ok := a.region[name]; ok {
		return val != region
	}
	return false
}

type SmsSender struct {
	*Observer
}

func (s *SmsSender) Update() {
	ip := s.sub.(*Account).ip
	var name, region string
	for k, v := range s.sub.(*Account).region {
		name, region = k, v
	}
	println(&quot;msg send name &quot;, name, &quot; ip &quot;, ip, &quot; region &quot;, region)
}

func NewSmsSender(sub ISubject) *SmsSender {
	return  &amp;SmsSender{
		Observer: &amp;Observer{sub},
	}
}

type MailSender struct {
	*Observer
}

func (s *MailSender) Update() {
	ip := s.sub.(*Account).ip
	var name, region string
	for k, v := range s.sub.(*Account).region {
		name, region = k, v
	}
	println(&quot;mail send name &quot;, name, &quot; ip &quot;, ip, &quot; region &quot;, region)
}

func NewMailSender(sub ISubject) *MailSender {
	return  &amp;MailSender{
		Observer: &amp;Observer{sub},
	}
}

func TestDrinkingMode_Update(t *testing.T) {
	water := NewWaterHeater()

	washMode := NewWashingMode(water)
	drinkingMode := NewDrinkingMode(water)
	water.Attach(washMode)
	water.Attach(drinkingMode)
	water.SetTemperature(40)
	water.SetTemperature(60)
	water.SetTemperature(100)
}

func TestAccount(t *testing.T) {
	account := NewAccount()
	sms := NewSmsSender(account)
	mail := NewMailSender(account)
	account.Attach(sms)
	account.Attach(mail)
	account.Login(&quot;Tony&quot;, &quot;104.47.18.9&quot;)
	account.Login(&quot;Tony&quot;, &quot;67.218.147.69&quot;)
	account.Login(&quot;Tony&quot;, &quot;33.12.33.123&quot;)
}

</code></pre>
<h4><a id="cpp-code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cpp_code</h4>
<pre><code class="language-cpp">//
// Created by eredinliu on 2020-01-28.
//

#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;map&gt;

using namespace std;

class Observable;

class Observer {
public:
    virtual void Update(Observable*) = 0;
};

class Observable {
public:
    std::list&lt;Observer*&gt; observers;

public:
    void Add(Observer* obj) {
        this-&gt;observers.push_back(obj);
    }

    void Remove(Observer* obj) {
        this-&gt;observers.remove(obj);
    }

    void Notify() {
        for (auto&amp; it : this-&gt;observers) {
            it-&gt;Update(this);
        }
    }
};

class WaterHeater : public  Observable {
private:
    float temperature = 25;

public:
    float GetTemperature() {
        return this-&gt;temperature;
    }

    void SetTemperature(float val) {
        this-&gt;temperature = val;
        this-&gt;Notify();
        cout &lt;&lt; &quot; current temperatue &quot; &lt;&lt; this-&gt;temperature &lt;&lt; &quot; C&quot; &lt;&lt; endl;
    }
};

class WashingMode : public Observer {
public:
    void Update(Observable* obj) {
        WaterHeater* waterHeater = reinterpret_cast&lt;WaterHeater*&gt;(obj);
        if (waterHeater-&gt;GetTemperature() &gt;= 50 &amp;&amp;
            waterHeater-&gt;GetTemperature() &lt;=70) {
            cout &lt;&lt; &quot;temperature suitable for bath&quot; &lt;&lt; endl;
        }
    }
};

class DrinkingMode: public Observer {
public:
    void Update(Observable* obj) {
        WaterHeater* waterHeater = reinterpret_cast&lt;WaterHeater*&gt;(obj);
        if (waterHeater-&gt;GetTemperature() &gt;= 100) {
            cout &lt;&lt; &quot;temperature suitable for drinking&quot; &lt;&lt; endl;
        }
    }
};

map&lt;string, string&gt; ip_region  {
        {&quot;104.47.18.9&quot;, &quot;hangzhou&quot;},
        {&quot;67.218.147.69&quot;, &quot;LA&quot;},
        {&quot;33.12.33.123&quot;, &quot;shanghai&quot;}
};

class Account : public Observable {
public:
    void Login(const string&amp; name, const string&amp; ip) {
        if (ip_region.count(ip) &lt;= 0) {
            cout &lt;&lt; &quot;not in record&quot; &lt;&lt; endl;
            return;
        }

        string region = ip_region[ip];
        if (isLongDistance(name, region)) {
            this-&gt;region[name] = region;
            this-&gt;ip = ip;
            this-&gt;Notify();
        }


        this-&gt;region[name] = region;
        this-&gt;ip = ip;
    }

    bool isLongDistance(const string&amp; name, string&amp; region) {
        if (this-&gt;region.count(name) &gt; 0) {
            return this-&gt;region[name] != region;
        }
        return false;
    }

    map&lt;string, string&gt; GetRegion(){
        return this-&gt;region;
    }

    const string GetIP() {
        return this-&gt;ip;
    }

private:
    map&lt;string, string&gt; region;
    string ip;
};

class SmsSender : public Observer {
public:
    void Update(Observable* obj) {
        Account* account = reinterpret_cast&lt;Account*&gt;(obj);
        auto ip = account-&gt;GetIP();
        string name, region;

        for (auto&amp; it : account-&gt;GetRegion()) {
            name, region = it.first, it.second;
        }

        cout &lt;&lt; &quot;msg send name &quot; &lt;&lt; name &lt;&lt; &quot; ip &quot; &lt;&lt; ip &lt;&lt; &quot; region&quot; &lt;&lt;
        region &lt;&lt; endl;
    }
};

class MailSender : public Observer {
public:
    void Update(Observable* obj) {
        Account* account = reinterpret_cast&lt;Account*&gt;(obj);
        auto ip = account-&gt;GetIP();
        string name, region;

        for (auto&amp; it : account-&gt;GetRegion()) {
            name, region = it.first, it.second;
        }

        cout &lt;&lt; &quot;mail send name &quot; &lt;&lt; name &lt;&lt; &quot; ip &quot; &lt;&lt; ip &lt;&lt; &quot; region&quot; &lt;&lt;
        region &lt;&lt; endl;
    }
};

int main() {
    WaterHeater* waterHeater = new WaterHeater();
    Observer* washingMode = new WashingMode();
    Observer* drinkingMode = new DrinkingMode();
    waterHeater-&gt;Add(washingMode);
    waterHeater-&gt;Add(drinkingMode);
    waterHeater-&gt;SetTemperature(40);
    waterHeater-&gt;SetTemperature(60);
    waterHeater-&gt;SetTemperature(100);
    waterHeater-&gt;Remove(drinkingMode);
    waterHeater-&gt;SetTemperature(102);



    Account* account = new Account();
    Observer* sms = new SmsSender();
    Observer* mail = new MailSender();
    account-&gt;Add(sms);
    account-&gt;Add(mail);
    account-&gt;Login(&quot;Tony&quot;, &quot;104.47.18.9&quot;);
    account-&gt;Login(&quot;Tony&quot;, &quot;67.218.147.69&quot;);
    account-&gt;Remove(mail);
    account-&gt;Login(&quot;Tony&quot;, &quot;33.12.33.123&quot;);
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-11-03T08:30:29+08:00" itemprop="datePublished">2019/11/03 08:30 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15727410293846.html" itemprop="url">
		Decorate</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8D%95%E4%B8%80%E6%8C%87%E8%B4%A3%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单一指责模式</h4>
<ul>
<li>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任</li>
<li>典型模式</li>
<li>decorator</li>
<li>bridge</li>
</ul>
<h4><a id="%E5%8A%A8%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动机</h4>
<ul>
<li>在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引人的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀</li>
<li>如何使“对象功能的扩展“能够根据需要来动态地实现？同时避免“扩展功能的増多”带来的子类膨胀问题？从而使得任何“功能扩展变化“所导致的影响将为最低？</li>
</ul>
<h4><a id="demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>demo</h4>
<ul>
<li><img src="media/15727410293846/15727411990518.jpg" alt="" style="width:535px;" /></li>
<li><img src="media/15727410293846/15727415664698.jpg" alt="" style="width:1092px;" /></li>
<li><img src="media/15727410293846/15727417495967.jpg" alt="" style="width:674px;" /></li>
<li><img src="media/15727410293846/15727424291605.jpg" alt="" style="width:626px;" /></li>
</ul>
<h4><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h4>
<p><img src="media/15727410293846/15805306433109.jpg" alt="" style="width:886px;" /></p>
<h4><a id="slide" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>slide</h4>
<ul>
<li>编译时共用</li>
<li>运行时多态</li>
<li>运行时装配</li>
<li><img src="media/15727410293846/15727426290997.jpg" alt="" style="width:666px;" /></li>
</ul>
<h5><a id="%E9%87%8D%E6%9E%84%E4%B9%8B%E5%90%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重构之后</h5>
<p><img src="media/15727410293846/15727429404116.jpg" alt="" style="width:1015px;" /></p>
<h4><a id="%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>要点总结</h4>
<ul>
<li>
<p>通过采用组合而非继承的手法，Decorator 模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</p>
</li>
<li>
<p>Decorator 类在接口上表现为 is- a Componenti 的继承关系，即 Decorator 类继承了 Component 类所具有的接口。但在实现上又表现为 has- a Component 的组合关系，即 Decorator 类又使用了另外个 Component 类。</p>
</li>
<li>
<p>Decorator/模式的目的并非解决“多子类衍生的多继承”问题，Decorator 模式应用的要点在于解决“主体类在多个方向上的扩展功能”一是为“装饰”的含义</p>
</li>
</ul>
<h4><a id="%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%A0%87%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>装饰器的标示</h4>
<ul>
<li><img src="media/15727410293846/15727461029717.jpg" alt="" style="width:586px;" /></li>
<li>同时继承和组合</li>
</ul>
<h4><a id="golang-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang-demo</h4>
<pre><code class="language-go">package decorator

type Component interface {
	Calc() int
}

type ConcreteComponent struct{}

func (*ConcreteComponent) Calc() int {
	return 0
}

type MulDecorator struct {
	Component
	num int
}

func WarpMulDecorator(c Component, num int) Component {
	return &amp;MulDecorator{
		Component: c,
		num:       num,
	}
}

func (d *MulDecorator) Calc() int {
	return d.Component.Calc() * d.num
}

type AddDecorator struct {
	Component
	num int
}

func WarpAddDecorator(c Component, num int) Component {
	return &amp;AddDecorator{
		Component: c,
		num:       num,
	}
}

func (d *AddDecorator) Calc() int {
	return d.Component.Calc() + d.num
}

package decorator

import &quot;fmt&quot;

func ExampleDecorator() {
	var c Component = &amp;ConcreteComponent{}
	c = WarpAddDecorator(c, 10)
	c = WarpMulDecorator(c, 8)
	res := c.Calc()

	fmt.Printf(&quot;res %d\n&quot;, res)
	// Output:
	// res 80
}
</code></pre>
<h4><a id="golang-demo2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang_demo2</h4>
<pre><code class="language-go">type IMachine interface {
	show()
}

type Machine struct {
	name string
}

func (m *Machine) show() {
}

type AirCondition struct {
	*Machine
}

func (a *AirCondition) show() {
	println(&quot;machine name is &quot; + a.name)
}

func NewAirCondition(name string) *AirCondition {
	return &amp;AirCondition{
		Machine: &amp;Machine{
			name: name,
		},
	}
}

type Television struct {
	*Machine
}

func (t *Television) show() {
	println(&quot;machine name is &quot; + t.name)
}

func NewTelevision(name string) *Television {
	return &amp;Television{
		Machine: &amp;Machine{
			name: name,
		},
	}
}

type Decorator struct {
	IMachine
}

func (d *Decorator) show() {
	println(reflect.TypeOf(d.IMachine).String() + &quot; show&quot;)
}

func NewDecorator(m IMachine) *Decorator {
	return &amp;Decorator{
		IMachine: m,
	}
}

type AirDecorator struct {
	*Decorator
}

func (a *AirDecorator) show() {
	a.external()
	a.IMachine.show()
}

func (a *AirDecorator) external() {
	println(&quot;AirDecorator external function&quot;)
}

func NewAirDecorator(m IMachine) *AirDecorator {
	return &amp;AirDecorator{
		Decorator: NewDecorator(m),
	}
}


type TeleDecorator struct {
	*Decorator
}

func (a *TeleDecorator) show() {
	a.external()
	a.IMachine.show()
}

func (a *TeleDecorator) external() {
	println(&quot;TeleDecorator external function&quot;)
}

func NewTeleDecorator(m IMachine) *TeleDecorator {
	return &amp;TeleDecorator{
		Decorator: NewDecorator(m),
	}
}

func TestMachineDecorator(t *testing.T) {
	air := NewAirCondition(&quot;air&quot;)
	dec1 := NewAirDecorator(air)
	dec1.show()

	tele := NewTelevision(&quot;tele&quot;)
	dec2 := NewTeleDecorator(tele)
	dec2.show()
}
</code></pre>
<h4><a id="cpp-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cpp_demo</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;

class Machine
{
 public:
  std::string _name;
 public:
  Machine(std::string tmp) :_name(tmp){}
  Machine(){}
  virtual void show() = 0;
};

class AirCondition:public Machine
{
 public:
  AirCondition(std::string name):Machine(name){}
  AirCondition(){}
  virtual void show()
  {
    std::cout&lt;&lt;&quot;machine name is &quot; &lt;&lt; _name &lt;&lt; std::endl;
  }
};

class Television:public Machine
{
 public:
  Television(std::string name):Machine(name){}
  Television(){}
  virtual void show()
  {
    std::cout&lt;&lt;&quot;machine name is &quot; &lt;&lt; _name &lt;&lt; std::endl;
  }
};
class Decorator:public Machine
{
 protected:
  Machine* _person;   //要进行装饰的类
 public:
  Decorator(Machine* tmp)
  {
    _person = tmp;
  }

  virtual void show()
  {
    _person-&gt;show();
  }
};

class AirDecorator :public Decorator
{
 public:
  AirDecorator(Machine *tmp):Decorator(tmp){}
  virtual void show()
  {
    this-&gt;ExternalFunction();
    Decorator::show();
  }

  void ExternalFunction() //额外功能
  {
    std::cout &lt;&lt; &quot;AirDecorator ExternalFunction &quot; &lt;&lt; std::endl;
  }
};
class TeleDecorator :public Decorator
{
 public:
  TeleDecorator(Machine *tmp):Decorator(tmp){}
  virtual void show()
  {
    this-&gt;ExternalFunction();
    Decorator::show();
  }

  void ExternalFunction() //额外功能
  {
    std::cout &lt;&lt; &quot;TeleDecorator ExternalFunction &quot; &lt;&lt; std::endl;
  }
};

int main()
{
  Machine *air = new AirCondition(&quot;air&quot;);
  Decorator * dec1 = new AirDecorator(air);

  dec1-&gt;show();

  Machine *tele = new Television(&quot;tele&quot;);
  Decorator * dec2 = new TeleDecorator(tele);

  dec2-&gt;show();
}
</code></pre>
<h4><a id="python-code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>python_code</h4>
<pre><code class="language-python">from abc import ABCMeta, abstractmethod

class Machine(metaclass=ABCMeta):

    @abstractmethod
    def show(self):
        pass

    def __init__(self, name):
        self.name = name

class AirCondition(Machine):

    def __init__(self, name):
        super().__init__(name)

    def show(self):
        print(&quot;machine name is {}&quot;.format(self.name))


class Television(Machine):

    def __init__(self, name):
        super().__init__(name)

    def show(self):
        print('machine name is {}'.format(self.name))

class Decorator(Machine):

    def __init__(self, machine):
        self.machine = machine

    def show(self):
        self.machine.show()

class AirDecorator(Decorator):

    def __init__(self, machine):
        super().__init__(machine)

    def show(self):
        self.external_function()
        super().show()

    def external_function(self):
        print('air decorator external function')

class TeleDecorator(Decorator):

    def __init__(self, machine):
        super().__init__(machine)

    def show(self):
        self.external_function()
        super().show()

    def external_function(self):
        print('tele decorator external function')

if __name__ == '__main__':
    air = AirCondition('air')
    dec1 = AirDecorator(air)
    dec1.show()

    tele = Television('tele')
    dec2 = TeleDecorator(tele)
    dec2.show()
</code></pre>
<h4><a id="golang-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang_demo</h4>
<pre><code class="language-go">package desian_pattern_practise

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type IPerson interface {
	Wear()
}

type Person struct {
	name string
}

func (p *Person) Wear() {
}

type Engineer struct {
	*Person
	skill string
}

func (e *Engineer) Wear() {
	fmt.Println(reflect.TypeOf(e).String(), &quot;I'm&quot;, e.name, &quot;skill&quot;, e.skill)
}

func NewEngineer(name, skill string) *Engineer {
	return &amp;Engineer{
		Person: &amp;Person{
			name: name,
		},
		skill: skill,
	}
}

type Teacher struct {
	*Person
	title string
}

func (e *Teacher) Wear() {
	fmt.Println(reflect.TypeOf(e).String(),&quot;I'm&quot;, e.name, &quot;title&quot;, e.title)
}

func (e *Teacher) NewTeacher(name, title string) *Teacher {
	return &amp;Teacher{
		Person: &amp;Person{
			name: name,
		},
		title: title,
	}
}

type Decorator struct {
	IPerson
}

func (d *Decorator) Wear() {
	println(reflect.TypeOf(d.IPerson).String() + &quot; Wear&quot;)
	d.IPerson.Wear()
}

type CasualPan struct {
	*Decorator
}

func (c *CasualPan) Wear() {
	c.Decorator.Wear()
	c.Decorate()
}

func (c *CasualPan) Decorate() {
	println(&quot;CasualPan&quot;)
}

func NewCasualPan(person IPerson) *CasualPan {
	return &amp;CasualPan{
		Decorator: &amp;Decorator{
			IPerson: person,
		},
	}
}

type Belt struct {
	*Decorator
}

func (c *Belt) Wear() {
	c.Decorator.Wear()
	c.Decorate()
}

func (c *Belt) Decorate() {
	println(&quot;Belt&quot;)
}

func NewBelt(person IPerson) *Belt {
	return &amp;Belt{
		Decorator: &amp;Decorator{
			IPerson: person,
		},
	}
}


type LeatherShoes struct {
	*Decorator
}

func (c *LeatherShoes) Wear() {
	c.Decorator.Wear()
	c.Decorate()
}

func (c *LeatherShoes) Decorate() {
	println(&quot;LeatherShoes&quot;)
}

func NewLeatherShoes(person IPerson) *LeatherShoes {
	return &amp;LeatherShoes{
		Decorator: &amp;Decorator{
			IPerson: person,
		},
	}
}

package desian_pattern_practise

import &quot;testing&quot;

func TestDecorator_Wear(t *testing.T) {
	engineer := NewEngineer(&quot;ming&quot;, &quot;Golang&quot;)
	pant := NewCasualPan(engineer)
	belt := NewBelt(pant)
	shoes := NewLeatherShoes(belt)
	shoes.Wear()
}
</code></pre>
<h3><a id="cpp-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cpp_demo</h3>
<pre><code class="language-C++">//
// Created by eredinliu on 2020-02-01.
//

#include &lt;iostream&gt;

using namespace std;

class Person {
public:
    virtual void Wear() { cout &lt;&lt; &quot;person wear&quot; &lt;&lt; endl; }

    Person(const string&amp; name) : name_(name) {}

    Person() {}

protected:
    string name_;
};

class Engineer : public Person {

public:
    Engineer(const string&amp; name, const string&amp; skill) : Person(name),
    skill_(skill) {}

    string&amp; GetSkill() {return this-&gt;skill_;}

    void Wear() {
        cout &lt;&lt; &quot;I'm &quot; &lt;&lt; name_ &lt;&lt; &quot; engineer &quot; &lt;&lt; name_ &lt;&lt; endl;
        Person::Wear();
    }
private:
    string skill_;
};

class Decorator : public  Person {
public:
    Decorator(Person* person) : decorated_(person) {}

    void Wear() {
        this-&gt;decorated_-&gt;Wear();
        this-&gt;Decorate();
    }

    virtual void Decorate() = 0;

protected:
    Person* decorated_;
};

class CasualPant : public Decorator {
public:
    CasualPant(Person* person) : Decorator(person) {}

    void Decorate() {
        cout &lt;&lt; &quot;CasualPant&quot; &lt;&lt; endl;
    }
};

class Belt : public Decorator {
public:
    Belt(Person* person) : Decorator(person) {}

    void Decorate() {
        cout &lt;&lt; &quot;Belt&quot; &lt;&lt; endl;
    }
};

class LeatherShoes : public Decorator {
public:
    LeatherShoes(Person* person) : Decorator(person) {}

    void Decorate() {
        cout &lt;&lt; &quot;LeatherShoes&quot; &lt;&lt; endl;
    }
};

int main() {
    Person* tony = new Engineer(&quot;engineer&quot;, &quot;Go&quot;);
    Person* pant = new CasualPant(tony);
    Person* belt = new Belt(pant);
    Person* shoes = new LeatherShoes(belt);
    shoes-&gt;Wear();
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-11-11T07:20:26+08:00" itemprop="datePublished">2019/11/11 07:20 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15734280261866.html" itemprop="url">
		Singleton</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>案例</h4>
<pre><code class="language-C++">std::mutex m;
 static MyCAS* GetInstance() {
    //不代表一定没被new过，只有第一次多线程初始化的时候需要加锁，后面都不需要加锁
    if (m_instance == nullptr) {
      //初始化的时候才加锁
      std::unque_lock(std::mutex) lock(m);
      if (m_instance == nullptr) {
        m_instance = new MyCAS();
        static GC c1;
      }
      return m_instance;
    }
  }

</code></pre>
<ul>
<li>存在内存reorder, 加volatitle没有</li>
</ul>
<h4><a id="golang-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang_demo</h4>
<pre><code class="language-go">//Singleton 是单例模式类
type Singleton struct{}

var singleton *Singleton
var once sync.Once

//GetInstance 用于获取单例模式对象
func GetInstance() *Singleton {
        once.Do(func() {
                singleton = &amp;Singleton{}
        })

        return singleton
}

func GetInstance() *Singleton {
        once.Do(func() {
                singleton = &amp;Singletion()
        })
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-06T07:50:09+08:00" itemprop="datePublished">2019/12/06 07:50 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15755898090270.html" itemprop="url">
		Composite</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="composite" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Composite</h4>
<ul>
<li>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</li>
</ul>
<h4><a id="%E5%8A%A8%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动机</h4>
<ul>
<li>在软件在某些情況下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</li>
<li>如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象样来处理复杂的对象容器？</li>
</ul>
<h4><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h4>
<ul>
<li><img src="media/15755898090270/15807244643257.jpg" alt="" style="width:828px;" /></li>
</ul>
<h4><a id="%E8%A6%81%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>要点</h4>
<ul>
<li>Composite 模式采用树形结构来实现普遍存在的对象容器从 i 致地く意用）处運对案和对象容器无需笑心处的是单个的对象，还的对象容器。</li>
<li>将“客户代码与复杂的对象容器结构“解耦是 Composite 的核心，解耦之后，客户代码将与纯粹的抽象接口-而非对象容器的内部实现机构-产生依赖，从而更能应对变化</li>
<li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li>
</ul>
<h4><a id="cpp-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cpp_demo</h4>
<pre><code class="language-C++">//
// Created by 刘超 on 2019-12-06.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;

using namespace std;

class Component {
public:
    virtual ~Component(){};
    virtual void Operation() = 0;
};

class Composite : public Component {
public:
    Composite(const string&amp; _name) : name(_name) {}
    ~Composite() {}

    void Operation() {
        for (auto&amp; iter : comList) {
            std::cout &lt;&lt; &quot;Composite Operation&quot; &lt;&lt; std::endl;
            iter-&gt;Operation();
        }
    }
    void Add(Component* com) {
        comList.push_back(com);
    }
    void Remove(Component* com) {
        comList.remove(com);
    }

private:
    list&lt;Component*&gt; comList;
    string name;
};

class Leaf : public Component {
public:
    Leaf(const string&amp; name) : _name(name) {}
    ~Leaf() {
        cout &lt;&lt; &quot;Leaf::~leaf()&quot; &lt;&lt; endl;
    }
    void Operation() {
        std::cout &lt;&lt; name &lt;&lt; &quot; Operation&quot; &lt;&lt; std::endl;
    }

private:
    string _name;
};

int main() {
    Composite* root = new Composite(&quot;root&quot;);
    Composite* node1 = new Composite(&quot;node1&quot;);
    Composite* node2 = new Composite(&quot;node2&quot;);
    Composite* node3 = new Composite(&quot;node3&quot;);
    Composite* node4 = new Composite(&quot;node4&quot;);
    Leaf* lf1 = new Leaf(&quot;lf1&quot;);
    Leaf* lf2 = new Leaf(&quot;lf2&quot;);

    root-&gt;Add(node1);
    node1-&gt;Add(node2);
    node2-&gt;Add(lf1);

    root-&gt;Add(node3);
    node3-&gt;Add(node4);
    node4-&gt;Add(lf2);
    root-&gt;Operation();
}
</code></pre>
<h4><a id="golang-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang_demo</h4>
<pre><code class="language-go">package design_pattern

import (
	&quot;fmt&quot;
)

type IComponent interface {
	Display(dep int)
}

func (l *Leaf) Display(dep int) {
	fmt.Println(RetString(dep) + l.name)
}

type Leaf struct {
	name string
}

func RetString(depth int) string {
	var ret []byte
	for i := 0; i &lt; depth; i++ {
		ret = append(ret, '-')
	}

	return string(ret)
}

func NewLeaf(name string) *Leaf {
	return &amp;Leaf{name: name}
}

type Composite struct {
	name string
	comList map[IComponent]bool
}

func NewComposite(name string) *Composite {
	return  &amp;Composite{
		comList: make(map[IComponent]bool),
		name: name,
	}
}

func (c *Composite) Add(i IComponent) {
	c.comList[i] = true
}

func (c *Composite) Remove(i IComponent) {
	delete(c.comList, i)
}

func (c *Composite) Display(dep int) {

	fmt.Println(RetString(dep) + c.name)
	for k, _ := range c.comList {
		k.Display(dep + 1)
	}
}
</code></pre>
<h4><a id="python-code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>python_code</h4>
<pre><code class="language-python">from abc import ABCMeta, abstractmethod

class Component(metaclass=ABCMeta):

    @abstractmethod
    def display(self):
        pass

class Composite(Component):

    def __init__(self, name):
        self.com_list = []
        self.__name = name

    def add(self, com):
        self.com_list.append(com)

    def remove(self, com):
        self.com_list.remove(com)

    def display(self):
        print('{} display'.format(self.__name))
        for com in self.com_list:
            com.display()

class Leaf(Component):

    def __init__(self, name):
        self.__name = name

    def display(self):
        print('{} display'.format(self.__name))

if __name__ == '__main__':
    root = Composite(&quot;root&quot;)

    node1 = Composite(&quot;node1&quot;)
    node2 = Composite(&quot;node2&quot;)
    node3 = Composite(&quot;node3&quot;)
    node4 = Composite(&quot;node4&quot;)

    lf1 = Leaf(&quot;lf1&quot;)
    lf2 = Leaf(&quot;lf2&quot;)
    lf3 = Leaf(&quot;lf3&quot;)

    root.add(node1)
    node1.add(node2)
    node2.add(lf1)

    root.add(node3)
    node3.add(node4)
    node4.add(lf2)

    root.add(node4)

    root.display()

    print(&quot;=============================&quot;)
    root.remove(node1)
    root.display()
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-11-04T06:27:18+08:00" itemprop="datePublished">2019/11/04 06:27 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15728200383131.html" itemprop="url">
		桥模式</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单一职责模式</h4>
<ul>
<li>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时侯的关键是划清责任</li>
</ul>
<h4><a id="%E5%8A%A8%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动机</h4>
<ul>
<li>只override了一部分</li>
<li>抽象部分（业务功能）与实现部分（平台实现）分离，使它们可以独立地变化。</li>
<li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度乃至多个纬度的变化</li>
<li>如何应对这种“多维度的变化“？如何利用面向对象技术来使得类型</li>
<li>可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</li>
</ul>
<h4><a id="%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结构</h4>
<ul>
<li><img src="media/15728200383131/15728212883849.jpg" alt="" style="width:788px;" /></li>
</ul>
<h4><a id="%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>要点总结</h4>
<ul>
<li>Bridge 模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化“它们。</li>
<li>Bridge 模式有时候类似于多继承方案，但是多继承方案往往违背单职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge 模式是比多继承方案更好的解决方法</li>
<li>Bridge 模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用 Bridge 的扩展模式。</li>
</ul>
<h4><a id="cpp-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cpp_demo</h4>
<pre><code class="language-c++">class ISwitch
{
 public:
  ISwitch(IElectricalEquipment *ee) { m_pEe = ee; }
  virtual ~ISwitch() {}

  virtual void On() = 0;

  virtual void Off() = 0;

 protected:
  IElectricalEquipment *m_pEe;
};

class IElectricalEquipment
{
 public:
  virtual ~IElectricalEquipment() {}

  virtual void PowerOn() = 0;

  virtual void PowerOff() = 0;
};
class Light : public IElectricalEquipment
{
 public:
  // 开灯
  virtual void PowerOn() override {
    std::cout &lt;&lt; &quot;Light is on.&quot; &lt;&lt; std::endl;
  }

  // 关灯
  virtual void PowerOff() override {
    std::cout &lt;&lt; &quot;Light is off.&quot; &lt;&lt; std::endl;
  }
};

// 风扇
class Fan : public IElectricalEquipment
{
 public:
  // 打开风扇
  virtual void PowerOn() override {
    std::cout &lt;&lt; &quot;Fan is on.&quot; &lt;&lt; std::endl;
  }

  // 关闭风扇
  virtual void PowerOff() override {
    std::cout &lt;&lt; &quot;Fan is off.&quot; &lt;&lt; std::endl;
  }
};
// 拉链式开关
class PullChainSwitch : public ISwitch
{
public:
    PullChainSwitch(IElectricalEquipment *ee) : ISwitch(ee) {}

    // 用拉链式开关打开电器
    virtual void On() override {
        std::cout &lt;&lt; &quot;Switch on the equipment with a pull chain switch.&quot; &lt;&lt; std::endl;
        m_pEe-&gt;PowerOn();
    }

    // 用拉链式开关关闭电器
    virtual void Off() override {
        std::cout &lt;&lt; &quot;Switch off the equipment with a pull chain switch.&quot; &lt;&lt; std::endl;
        m_pEe-&gt;PowerOff();
    }
};
// 两位开关
class TwoPositionSwitch : public ISwitch
{
 public:
  TwoPositionSwitch(IElectricalEquipment *ee) : ISwitch(ee) {}

  // 用两位开关打开电器
  virtual void On() override {
    std::cout &lt;&lt; &quot;Switch on the equipment with a two-position switch.&quot; &lt;&lt; std::endl;
    m_pEe-&gt;PowerOn();
  }

  // 用两位开关关闭电器
  virtual void Off() override {
    std::cout &lt;&lt; &quot;Switch off the equipment with a two-position switch.&quot; &lt;&lt; std::endl;
    m_pEe-&gt;PowerOff();
  }
};
int main()
{
    // 创建电器 - 电灯、风扇
    IElectricalEquipment *light = new Light();
    IElectricalEquipment *fan = new Fan();

    /**
    * 创建开关 - 拉链式开关、两位开关
    * 将拉链式开关和电灯关联起来，将两位开关和风扇关联起来
    **/
    ISwitch *pullChain = new PullChainSwitch(light);
    ISwitch *twoPosition = new TwoPositionSwitch(fan);

    // 开灯、关灯
    pullChain-&gt;On();
    pullChain-&gt;Off();

    // 打开风扇、关闭风扇
    twoPosition-&gt;On();
    twoPosition-&gt;Off();
}
</code></pre>
<h4><a id="golang-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>golang_demo</h4>
<pre><code class="language-go">package design_pattern

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
)

type ISwitch interface {
	On()
	Off()
}

type IEquip interface {
	PowerOn()
	PowerOff()
}

type Light struct {}

func (l *Light) PowerOn() {
	fmt.Println(reflect.TypeOf(l).String() + &quot; PowerOn&quot;)
}

func (l *Light) PowerOff() {
	fmt.Println(reflect.TypeOf(l).String() + &quot; PowerOff&quot;)
}

type Fen struct {}

func (l *Fen) PowerOn() {
	fmt.Println(reflect.TypeOf(l).String() + &quot; PowerOn&quot;)
}

func (l *Fen) PowerOff() {
	fmt.Println(reflect.TypeOf(l).String() + &quot; PowerOff&quot;)
}

type PullSwitch struct {
	IEquip
}

func NewPullSwitch(i IEquip) ISwitch {
	return &amp;PullSwitch{
		IEquip: i,
	}
}

func (p *PullSwitch) On() {
	p.IEquip.PowerOn()
}

func (p *PullSwitch) Off() {
	p.IEquip.PowerOff()
}

type TwoBiteSwitch struct {
	IEquip
}

func NewTwoBiteSwitch(i IEquip) ISwitch {
	return &amp;TwoBiteSwitch{
		IEquip: i,
	}
}

func (p *TwoBiteSwitch) On() {
	p.IEquip.PowerOn()
}

func (p *TwoBiteSwitch) Off() {
	p.IEquip.PowerOff()
}

type Message interface {
	SendMsg()
}

type AsyncMsg struct {
	ConcreteMsg
}

func NewAsyncMsg(c ConcreteMsg) *AsyncMsg {
	return &amp;AsyncMsg{
		ConcreteMsg: c,
	}
}

func (a *AsyncMsg) SendMsg() {
	a.ConcreteMsg.Send()
}

type SyncMsg struct {
	ConcreteMsg
}

func NewSyncMsg(c ConcreteMsg) *SyncMsg {
	return &amp;SyncMsg{
		ConcreteMsg: c,
	}
}

func (a *SyncMsg) SendMsg() {
	a.ConcreteMsg.Send()
}

type ConcreteMsg interface {
	Send()
}

type Email struct {
}

func (e *Email) Send() {
	fmt.Println(reflect.TypeOf(e).String() + &quot; Send&quot;)
}

type WeChat struct {
}

func (w *WeChat) Send() {
	fmt.Println(reflect.TypeOf(w).String() + &quot; Send&quot;)
}

func TestBridge(t *testing.T) {
	ab := NewAbstraction()

	imA := NewConcreteImA()
	ab.SetImplement(imA)
	ab.Operation()

	imB := NewConcreteImB()
	ab.SetImplement(imB)
	ab.Operation()
}

func TestPullSwitch_On(t *testing.T) {
	light := &amp;Light{}
	fen := &amp;Fen{}

	pull:= NewPullSwitch(light)
	pull.On()
	pull.Off()

	two := NewTwoBiteSwitch(fen)
	two.On()
	two.Off()
}

func TestMsg(t *testing.T) {
	email := &amp;Email{}
	weChat := &amp;WeChat{}

	async := NewAsyncMsg(email)
	async.SendMsg()

	sync := NewSyncMsg(weChat)
	sync.SendMsg()
}
</code></pre>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="设计模式_1.html">Prev</a>  
	 <a class="next" href="设计模式_3.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>