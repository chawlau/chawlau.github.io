<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  eredin-blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="eredin-blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; eredin-blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Prometheus.html">Prometheus</a></li>
        
            <li><a href="RocketMQ.html">RocketMQ</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html">网络协议</a></li>
        
            <li><a href="Golang.html">Golang</a></li>
        
            <li><a href="Django.html">Django</a></li>
        
            <li><a href="C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98.html">C++设计模式实战</a></li>
        
            <li><a href="%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes.html">深入剖析Kubernetes</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html">数据结构和算法</a></li>
        
            <li><a href="%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务</a></li>
        
            <li><a href="%E6%9E%B6%E6%9E%84.html">架构</a></li>
        
            <li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">操作系统原理</a></li>
        
            <li><a href="Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Mysql优化实战</a></li>
        
            <li><a href="Kafka.html">Kafka</a></li>
        
            <li><a href="linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html">linux服务器研发</a></li>
        
            <li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html">计算机组成原理</a></li>
        
            <li><a href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html">程序员的自我修养</a></li>
        
            <li><a href="C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6.html">C语言进阶</a></li>
        
            <li><a href="http_study.html">http_study</a></li>
        
            <li><a href="%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html">玩转算法</a></li>
        
            <li><a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html">C++对象模型</a></li>
        
            <li><a href="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html">SQL必知必会</a></li>
        
            <li><a href="Zookeeper.html">Zookeeper</a></li>
        
            <li><a href="Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html">Redis从入门到精通</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6.html">数据结构和算法进阶</a></li>
        
            <li><a href="Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">Mysql性能管理和架构设计</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html">网络编程实战</a></li>
        
            <li><a href="Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html">Redis高并发缓存</a></li>
        
            <li><a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html">C++基础与提高</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html">设计模式之美</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
        
            <li><a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Linux性能优化实战</a></li>
        
            <li><a href="%E5%80%99%E6%8D%B7STL.html">候捷STL</a></li>
        
            <li><a href="%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE.html">性能工程高手课</a></li>
        
            <li><a href="%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html">性能测试</a></li>
        
            <li><a href="ElasticSearch.html">ElasticSearch</a></li>
        
            <li><a href="RabbitMQ.html">RabbitMQ</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15651683152204.html">
                
                  <h1>对象</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>类对象空间</h4>

<ul>
<li>类的成员函数不占用类的空间，成员</li>
</ul>

<h4>对象结构的发展和演化</h4>

<ul>
<li>非静态的成员变量跟着类对象走，类对象都有自己的成员变量</li>
<li>静态成员变量不保存在类中</li>
<li>虚函数会让类多8个字节，类会产生指向虚函数的指针，有两个虚函数，类会产生两个指向虚函数的指针</li>
<li>类本身指向虚函数的指针vptr，要有地方存放，存放在一个表格，虚函数表</li>
<li>vptr由系统在适当的时机增加额外的代码来赋值</li>
<li>虚函数表是基于类的，跟对象没有关系</li>
<li>如果有多个数据成员，内存对齐</li>
</ul>

<h4>对象模型</h4>

<ul>
<li><img src="media/15651683152204/15651729969739.jpg" alt="" style="width:752px;"/></li>
</ul>

<h4>this指针</h4>

<ul>
<li>派生类对象，它是包含基类子对象、</li>
<li>派生类同时继承多个基类，第一个基类的地址和派生类地址相同</li>
</ul>

<h4>构造函数语义</h4>

<ul>
<li>含成的默认构造函数，只有在必要的时候，编译器オ会为我们合成出来，而不是必然或者必须为我们合成出来</li>
<li>生成预处理文件g++ -E obj3.cpp -o obj3.i</li>
</ul>

<h4>编译器何时会把默认的构造函数构造出来</h4>

<ul>
<li>任何构造国数，但包合含一个对象类型的成员而该对象所属于的类MATX 有ー个缺省的构造函数。编译器会为MBTX合成一个默认的构造函数，并且安插代码，调用MATX的缺省构造函数</li>
<li>父类带缺省的构造函数，子类没有任何构造函数，为了调用父类的构造函数</li>
<li>一个类含有虚函数，都是没有构造函数 编译器会给我们生成一全基于该类的虚函数表 vtable，把类的虚函数表地址赋值给类对象的虚函数指针</li>
<li>一个类带有虚基类</li>
<li><img src="media/15651683152204/15652598709736.jpg" alt="" style="width:452px;"/></li>
<li>虚基类结构，编译器为子类和父类都产生了默认构造函数</li>
</ul>

<pre class="line-numbers"><code class="language-text"> objdump  -j .text._ZN4MBTXC2Ev -x -C obj3.o 查看构造函数
 objdump -t -C obj3.o 查看函数符号表
 objdump  -x -C obj3.o 
</code></pre>

<h4>拷贝构造函数</h4>

<ul>
<li>合成的拷贝构造函数也是在必要的时候才会被合成出来</li>
<li>成员变量初始化手法，int简单类型直接按值拷贝过去，不需要拷贝构造</li>
</ul>

<h4>编译器合成的拷贝构造函数</h4>

<ul>
<li>如果一个类没有拷贝构造函数，但是含有一个类类型CTB的成员变量，该类型CTB含有拷贝构造函数，当代码中有涉及到类A的拷贝构造函数，编译器会合成构造函数</li>
<li>如果一个类没有拷贝构造函数，但是有一个父类有拷贝构造函数，当代码中有涉及到拷贝构造时，编译器会合成拷贝构造函数</li>
<li>如果类没有拷贝构造函数，但是该类声明或者继承了虚函数，编译器会自动为其构建拷贝构造函数，为了设定类对象虚函数表指针</li>
<li>如果一个类中有虚基类时，涉及到该类的拷贝构造函数，编译器会为其生成拷贝构造</li>
<li>其他编译器合成拷贝构造函数的情况</li>
</ul>

<h4>程序转化语义</h4>

<ul>
<li>编译器对代码进行拆分，拆分成编译器更容易理解和转化的语言</li>
<li>X x100,从编译器视角来看，并没有调用构造函数</li>
<li>x100.X::X(x0)</li>
</ul>

<h5>返回值初始化</h5>

<ul>
<li>linux针对返回临时对象的优化NRV和NRVO的优化</li>
<li>关闭优化g++ -o test  -fno-elide-constructors obj10.cpp</li>
<li>优化可能犯错误</li>
</ul>

<h4>拷贝构造函数是否必须</h4>

<ul>
<li>如果只有一些简单的成员变量类型int,double,根本不需要拷贝构造函数，编译器本身就支持bitewise copy</li>
<li>复杂类型的成员变量需要拷贝构造函数</li>
<li>如果增加了自己的拷贝构造函数，导致编译器本身的bitewise的拷贝构造失败，需要自己在拷贝构造函数进行成员变量初始化</li>
</ul>

<h4>成员列表</h4>

<h5>必须使用成员列表</h5>

<ul>
<li>成员是个引用</li>
<li>成员是个const</li>
<li>类继承基类，基类中有构造函数，基类构造函数有参数</li>
<li>成员变量是类类型，构造函数也是带参数的</li>
</ul>

<h5>使用初始化列表的优势</h5>

<ul>
<li>提高程序运行效率</li>
<li>初始化列表的代码还是会到函数体中执行，初始化的列表代码会被编译器移动进函数体</li>
<li>对于类类型的成员变量的初始化放到列表效率有明显的提升</li>
<li>简单类型放在初始化列表中</li>
<li>构造函数的代码是在构造函数代码之前执行</li>
<li>列表中的初始化顺序是类中定义的顺序，编译器按定义的值来赋值</li>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/07 16:58 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15650870393858.html">
                
                  <h1>C++对象模型入门</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>内容</h4>

<ul>
<li>C++对象内部工作原理</li>
<li>底层的具体实现机制</li>
<li>提高C++开发修养</li>
<li>练习C++编程内功</li>
</ul>

<h4>效果</h4>

<ul>
<li>拓展眼界和思路</li>
<li>层次和能力，自信心</li>
<li>应付面试</li>
<li>空类sizeof</li>
<li>虚函数表</li>
</ul>

<h4>研究内容</h4>

<ul>
<li>研究系统内部底层的各种各样的实现是如何做的</li>
<li>继承性</li>
<li>多态性</li>
</ul>

<h4>讲解参照</h4>

<ul>
<li>深度探索C++对象模型</li>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/06 18:23 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15650804838191.html">
                
                  <h1>C++基础</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>枚举类型</h4>

<ul>
<li>直接赋值整数不行</li>
</ul>

<h4>bool类型</h4>

<ul>
<li>枚举类型
<code>
typedef enum {<br/>
false, true<br/>
}bool
</code></li>
</ul>

<h4>重载</h4>

<ul>
<li>返回值类型不同不可以构成重载</li>
<li>参数顺序不同可以重载</li>
<li>隐式转换尽量注意</li>
<li>底层实现 name mangling 函数签名</li>
<li>.h里面mangling,但是库没有改变，extern c保证头文件不被mangling</li>
</ul>

<h4>操作符重载</h4>

<ul>
<li>+号的全局重载函数</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/06 16:34 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15649975500687.html">
                
                  <h1>Zookeeper</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>概念</h4>

<ul>
<li>ZooKeeper是一个分布式的，开放源码的分布式集群应用程序协调服务，是Hadoop和Hbase的重要组件。在Zookeeper中，znode是一个跟Unix文件系统路径相似的节点，可以往这个节点存储或获取数据</li>
</ul>

<h4>节点类型</h4>

<ul>
<li>持久节点</li>
<li>持久顺序节点</li>
<li>临时节点</li>
<li>临时顺序节点</li>
</ul>

<h4>zookeeper</h4>

<ul>
<li>配置集中管理</li>
<li>服务注册和发现</li>
<li>可靠性架构设计</li>
<li>分布式锁 排他性 重入性 共享性 创建临时节点的原子性</li>
<li>分布式队列 </li>
</ul>

<h4>一致性方案</h4>

<ul>
<li>ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交（已经被处理的消息不能丢，ZXID不同），</li>
<li>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务（丢弃的消息不能再次出现，ZXID相同，myid最大的做leader</li>
</ul>

<h4>zookeeper缺陷</h4>

<ul>
<li>服务发现应该是AP，不是CP</li>
</ul>

<h4>eureka</h4>

<ul>
<li>最终一致性</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/05 17:32 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html'>linux服务器研发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15649927761897.html">
                
                  <h1>Nginx模块开发</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>动静分离</h4>

<ul>
<li>静态数据放CDN</li>
<li>动态数据 业务接口和实现</li>
</ul>

<h4>模块开发</h4>

<ul>
<li>Handle模块</li>
<li>Filter模块</li>
<li>Upstream模块</li>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/05 16:12 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html'>linux服务器研发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15649684154486.html">
                
                  <h1>动态规划</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>流程</h4>

<ul>
<li>整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点</li>
<li>每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/05 09:26 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html'>数据结构和算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15649289939803.html">
                
                  <h1>高水位和Leader epoch</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>高水位作用</h4>

<ul>
<li>定义消息可见性，即用来标识分区下的哪些消息是可以被消费者消费的。</li>
<li>帮助 Kafka 完成副本同步</li>
<li><img src="media/15649289939803/c2243d5887f0ca7a20a524914b85a8dd.png" alt="c2243d5887f0ca7a20a524914b85a8dd"/></li>
<li>高水位和 LEO 是副本对象的两个重要属性。Kafka 所有副本都有对应的高水位和 LEO 值，而不仅仅是 Leader 副本</li>
</ul>

<h4>高水位更新机制</h4>

<ul>
<li>leader的broker保存远程副本，帮助leader副本 确定高水位</li>
<li>leader的LEO通过生产者消息写入磁盘更新</li>
<li>folloer副本通过拉取消息，更新磁盘</li>
<li>follower副本高水位取LEO和leader发来的高水位最小值确定高水位</li>
<li>leader副本高水位取leader副本和所有同步的leo的最小值</li>
<li>leader远程副本leo通过follower拉取消息上报的位移算</li>
</ul>

<h4>副本同步判断</h4>

<ul>
<li>该远程 Follower 副本在 ISR 中。</li>
<li>该远程 Follower 副本 LEO 值落后于 Leader 副本 LEO 值的时间，不超过 Broker 端参数 replica.lag.time.max.ms 的值</li>
<li>先更新leo，然后更新高水位</li>
</ul>

<h4>Leader Epoch</h4>

<ul>
<li>Epoch。一个单调增加的版本号。每当副本领导权发生变更时，都会增加该版本号。小版本号的 Leader 被认为是过期 Leader，不能再行使 Leader 权力。</li>
<li>起始位移（Start Offset）。Leader 副本在该 Epoch 值上写入的首条消息的位移。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/04 22:29 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Kafka.html'>Kafka</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15649279845988.html">
                
                  <h1>Kafka控制器</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>watch</h4>

<ul>
<li>所谓的 Watch 通知功能。一旦 znode 节点被创建、删除，子节点数量发生变化，抑或是 znode 所存的数据本身变更，ZooKeeper 会通过节点变更监听器 (ChangeHandler) 的方式显式通知客户端</li>
</ul>

<h4>控制器数据</h4>

<p><img src="media/15649279845988/38ff78fdeb2a86943ae60f15c3ad28c8.jpg" alt="38ff78fdeb2a86943ae60f15c3ad28"/></p>

<h4>控制器组件</h4>

<ul>
<li>控制器组件（Controller），是 Apache Kafka 的核心组件。它的主要作用是在 Apache ZooKeeper 的帮助下管理和协调整个 Kafka 集群</li>
<li>主题管理</li>
<li>分区重分配</li>
<li>领导者选举</li>
<li>集群成员管理 存活机制 每个 Broker 启动后，会在 /brokers/ids 下创建一个临时 znode。当 Broker 宕机或主动关闭后，该 Broker 与 ZooKeeper 的会话结束，这个 znode 会被自动删除。通过watch机制观察</li>
<li>数据服务 </li>
</ul>

<h4>内部设计原理</h4>

<ul>
<li>统一处理各种控制</li>
<li><img src="media/15649279845988/b14c6f2d246cbf637f2fda5dae1688e5.png" alt="b14c6f2d246cbf637f2fda5dae1688e5"/>
器事件，然后控制器将原来执行的操作全部建模成一个个独立的事件，发送到专属的事件队列中，供此线程消费</li>
<li>之前同步操作 ZooKeeper 全部改为异步操作</li>
</ul>

<h4>快速删除主题</h4>

<ul>
<li>ZooKeeper 中手动删除 /controller 节点</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/04 22:13 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Kafka.html'>Kafka</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15649249729413.html">
                
                  <h1>消费者组重平衡</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>重平衡通知</h4>

<ul>
<li>靠消费者的心跳线程</li>
<li>协调者将REBALANCE_IN_PROGRESS封装进心跳请求响应中发送给消费者</li>
</ul>

<h4>消费者组状态机</h4>

<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">消费者五种状态</th>
<th style="text-align: center"></th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">状态</td>
<td style="text-align: center">含义</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Empty</td>
<td style="text-align: center">组内没有任何成员，但消费者组可能存在已提交的位移数据，而且这些位移尚未过期</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Dead</td>
<td style="text-align: center">同样是组内没有任何成员，但组的元数据信息已经在协调者端被移除。协调者组件保存着当前向它注册过的所有组信息，所谓的元数据信息就类似于这个注册信息</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">PreparingRebalance</td>
<td style="text-align: center">消费者组准备开启重平衡，此时所有成员都要重新请求加入消费者组</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">CompletingRebalance</td>
<td style="text-align: center">消费者组下所有成员已经加入，各个成员正在等待分配方案。该状态在老一点的版本中被称为 Awaitingsync，它和 Completing Rebalancek 是等价的</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Stable</td>
<td style="text-align: center">消费者组的稳定状态。该状态表明重平衡已经完成，组内各成员能够正常消费数据了</td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>

<ul>
<li><img src="media/15649249729413/f16fbcb798a53c21c3bf1bcd5b72b006.png" alt="f16fbcb798a53c21c3bf1bcd5b72b006"/></li>
</ul>

<h4>重平衡流程</h4>

<ul>
<li>JoinGroup JoinGroup 请求的主要作用是将组成员订阅信息发送给领导者消费者，待领导者制定好分配方案后，重平衡流程进入到 SyncGroup 请求阶段</li>
<li>SyncGroup 就是让协调者把领导者制定的分配方案下发给各个组内成员。当所有成员都成功接收到分配方案后，消费者组进入到 Stable 状态，即开始正常的消费工作</li>
</ul>

<h4>重平衡场景</h4>

<ul>
<li>新成员入组</li>
<li>组成员离开组</li>
<li>组成员崩溃离组 session.timeout.ms</li>
<li>重平衡时协调者对组内成员提交位移的处理</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/04 21:22 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Kafka.html'>Kafka</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15647133717861.html">
                
                  <h1>查找表</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>两类</h4>

<ul>
<li>查找有无</li>
<li>查找对应关系</li>
<li>有序和查找是关联</li>
<li>如果数组有序</li>
<li>leet_349</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given two arrays, write a function to compute their intersection.
class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        set&lt;int&gt; s(nums1.begin(), nums1.end()), res;
        for (auto a : nums2) {
            if (s.count(a)) res.insert(a);
        }
        return vector&lt;int&gt;(res.begin(), res.end());
    }
};
</code></pre>

<ul>
<li>leet_350</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given two arrays, write a function to compute their intersection.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        unordered_map&lt;int, int&gt; m;
        vector&lt;int&gt; res;
        for (auto a : nums1) ++m[a];
        for (auto a : nums2) {
            if (m[a]-- &gt; 0) res.push_back(a);
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_242</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">For example,
s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.
s = &quot;rat&quot;, t = &quot;car&quot;, return false.

class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size()) return false;
        int m[26] = {0};
        for (int i = 0; i &lt; s.size(); ++i) ++m[s[i] - &#39;a&#39;];
        for (int i = 0; i &lt; t.size(); ++i) {
            if (--m[t[i] - &#39;a&#39;] &lt; 0) return false;
        }
        return true;
    }
};
</code></pre>

<ul>
<li>leet_202</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Write an algorithm to determine if a number is &quot;happy&quot;.

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example: 

Input: 19
Output: true
Explanation: 
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
class Solution {
public:
    bool isHappy(int n) {
        while (n != 1 &amp;&amp; n != 4) {
            int sum = 0;
            while (n) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            n = sum;
        }
        return n == 1;
    }
};
</code></pre>

<ul>
<li>leet_290</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a pattern and a string str, find if str follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

Example 1:

Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;
Output: true
Example 2:

Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;
Output: false
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        unordered_map&lt;char, int&gt; m1;
        unordered_map&lt;string, int&gt; m2;
        istringstream in(str);
        int i = 0, n = pattern.size();
        for (string word; in &gt;&gt; word; ++i) {
            if (i == n || m1[pattern[i]] != m2[word]) return false;
            m1[pattern[i]] = m2[word] = i + 1;
        }
        return i == n;
    }
};
</code></pre>

<ul>
<li>leet_205</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given two strings  s  and  t , determine if they are isomorphic.

Two strings are isomorphic if the characters in  s  can be replaced to get  t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

Example 1:

Input: _s_ = &quot;egg&quot;, _t =_&quot;add&quot;
Output: true
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int m1[256] = {0}, m2[256] = {0}, n = s.size();
        for (int i = 0; i &lt; n; ++i) {
            if (m1[s[i]] != m2[t[i]]) return false;
            m1[s[i]] = i + 1;
            m2[t[i]] = i + 1;
        }
        return true;
    }
};
</code></pre>

<ul>
<li>leet_451</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Input:
&quot;tree&quot;

Output:
&quot;eert&quot;

Explanation:
&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.
So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.
class Solution {
public:
    string frequencySort(string s) {
        string res;
        vector&lt;string&gt; v(s.size() + 1);
        unordered_map&lt;char, int&gt; m;
        for (char c : s) ++m[c];
        for (auto &amp;a : m) {
            v[a.second].append(a.second, a.first);
        }
        for (int i = s.size(); i &gt; 0; --i) {
            if (!v[i].empty()) res.append(v[i]);
        }
        return res;
    }
};
</code></pre>

<h4>两数求和</h4>

<ul>
<li>leet_1 排序后,双索引对撞</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.count(target - nums[i])) {
                return {i, m[target - nums[i]]};
            }
            m[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>

<ul>
<li>leet_15</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array  S  of  n  integers, are there elements  a ,  b ,  c  in  S  such that  a  +  b  +  c  = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

Elements in a triplet ( a , b , c ) must be in non-descending order. (ie,  a  ≤  b  ≤  c )
The solution set must not contain duplicate triplets.
 

    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; res;
        sort(nums.begin(), nums.end());
        if (nums.empty() || nums.back() &lt; 0 || nums.front() &gt; 0) return {};
        for (int k = 0; k &lt; (int)nums.size() - 2; ++k) {
            if (nums[k] &gt; 0) break;
            if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue;
            int target = 0 - nums[k], i = k + 1, j = (int)nums.size() - 1;
            while (i &lt; j) {
                if (nums[i] + nums[j] == target) {
                    res.push_back({nums[k], nums[i], nums[j]});
                    while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) ++i;
                    while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j;
                    ++i; --j;
                } else if (nums[i] + nums[j] &lt; target) ++i;
                else --j;
            }
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_18</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array S of n integers, are there elements a , b , c , and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

Elements in a quadruplet ( a , b , c , d ) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d )

The solution set must not contain duplicate quadruplets.

For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt; &amp;nums, int target) {
        vector&lt;vector&lt;int&gt;&gt; res;
        int n = nums.size();
        sort(nums.begin(), nums.end());
        for (int i = 0; i &lt; n - 3; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j &lt; n - 2; ++j) {
                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;
                int left = j + 1, right = n - 1;
                while (left &lt; right) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        vector&lt;int&gt; out{nums[i], nums[j], nums[left], nums[right]};
                        res.push_back(out);
                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left;
                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right;
                        ++left; --right;
                    } else if (sum &lt; target) ++left;
                    else --right;
                }
            }
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_16</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given array nums = [-1, 2, 1, -4], and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        int closest = nums[0] + nums[1] + nums[2];
        int diff = abs(closest - target);
        sort(nums.begin(), nums.end());
        for (int i = 0; i &lt; nums.size() - 2; ++i) {
            int left = i + 1, right = nums.size() - 1;
            while (left &lt; right) {
                int sum = nums[i] + nums[left] + nums[right];
                int newDiff = abs(sum - target);
                if (diff &gt; newDiff) {
                    diff = newDiff;
                    closest = sum;
                }
                if (sum &lt; target) ++left;
                else --right;
            }
        }
        return closest;
    }
};
</code></pre>

<h4>动态规划</h4>

<ul>
<li>leet120 Triangle</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {
        vector&lt;int&gt; dp(triangle.back());
        for (int i = (int)triangle.size() - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt;= i; ++j) {
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j];
            }
        }
        return dp[0];
    }
};
</code></pre>

<ul>
<li>leet64 minium path sum</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) {
        int m = grid.size(), n = grid[0].size();
        int dp[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 1; i &lt; m; ++i) dp[i][0] = grid[i][0] + dp[i - 1][0];
        for (int i = 1; i &lt; n; ++i) dp[0][i] = grid[0][i] + dp[0][i - 1];
        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m - 1][n - 1];
    }
};
</code></pre>

<ul>
<li>leet343 integer break</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a positive integer  n , break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

Example 1:

Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
class Solution {
public:
    int integerBreak(int n) {
        vector&lt;int&gt; dp(n + 1, 1);
        for (int i = 3; i &lt;= n; ++i) {
            for (int j = 1; j &lt; i; ++j) {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
</code></pre>

<ul>
<li>leet279 perfect squares</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a positive integer  n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to  n.

Example 1:

Input: _n_ = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: _n_ = 13
Output: 2
Explanation: 13 = 4 + 9.
class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i &lt;= n; ++i) {
            for (int j = 1; i + j * j &lt;= n; ++j) {
                dp[i + j * j] = min(dp[i + j * j], dp[i] + 1);
            }
        }
        return dp.back();
    }
};
</code></pre>

<ul>
<li>leet91 decode ways</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">A message containing letters from A-Z is being encoded to numbers using the following mapping:

&#39;A&#39; -&gt; 1
&#39;B&#39; -&gt; 2
...
&#39;Z&#39; -&gt; 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: &quot;12&quot;
Output: 2
Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).
，在遍历的过程中，对每个数字首先判断其是否为0，若是则将 dp[i] 赋为0，若不是，赋上 dp[i-1] 的值，然后看数组前一位是否存在，如果存在且满足前一位是1，或者和当前位一起组成的两位数不大于 26，则当前 dp[i] 值加上 dp[i - 2]。最终返回 dp 数组的最后一个值即可
dp[i] = dp[i-1] + dp[i-2]
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s[0] == &#39;0&#39;) return 0;
        vector&lt;int&gt; dp(s.size() + 1, 0);
        dp[0] = 1;
        for (int i = 1; i &lt; dp.size(); ++i) {
            if (s[i - 1] != &#39;0&#39;) dp[i] += dp[i - 1];
            if (i &gt;= 2 &amp;&amp; s.substr(i - 2, 2) &lt;= &quot;26&quot; &amp;&amp; s.substr(i - 2, 2) &gt;= &quot;10&quot;) {
                dp[i] += dp[i - 2];
            }
        }
        return dp.back();
    }
};
</code></pre>

<ul>
<li>leet62 unique path</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">A robot is located at the top-left corner of a  m  x  n  grid (marked &#39;Start&#39; in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).

How many possible unique paths are there?
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; dp(n, 1);
        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[j] += dp[j - 1]; 
            }
        }
        return dp[n - 1];
    }
};
````
* leet63 unique path

```C++
这里还需要初始化 dp 数组的某个值，使得其能正常累加。当起点不是障碍物时，其 dp 值应该为1，即dp[1][1] = 1，由于其是由 dp[0][1] + dp[1][0] 更新而来，所以二者中任意一个初始化为1即可。由于之后 LeetCode 更新了这道题的 test case，使得使用 int 型的 dp 数组会有溢出的错误，所以改为使用 long 型的数组来避免 overflow，代码如下
class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector&lt;vector&lt;long&gt;&gt; dp(m + 1, vector&lt;long&gt;(n + 1, 0));
        dp[0][1] = 1;
        for (int i = 1; i &lt;= m; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                if (obstacleGrid[i - 1][j - 1] != 0) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
};
class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector&lt;long&gt; dp(n, 0);
        dp[0] = 1;
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (obstacleGrid[i][j] == 1) dp[j] = 0;
                else if (j &gt; 0) dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
</code></pre>

<ul>
<li>leet673</li>
</ul>

<h4>查找</h4>

<ul>
<li>leet_350</li>
<li>leet_49</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array of strings, group anagrams together.

Example:

Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
Output:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        vector&lt;vector&lt;string&gt;&gt; res;
        unordered_map&lt;string, vector&lt;string&gt;&gt; m;
        for (string str : strs) {
            vector&lt;int&gt; cnt(26, 0);
            string t = &quot;&quot;;
            for (char c : str) ++cnt[c - &#39;a&#39;];
            for (int d : cnt) t += to_string(d) + &quot;/&quot;;
            m[t].push_back(str);
        }
        for (auto a : m) {
            res.push_back(a.second);
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_447 </li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given n points in the plane that are all pairwise distinct, a &quot;boomerang&quot; is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k ( the order of the tuple matters ).

Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).

Example:

**Input:**
[[0,0],[1,0],[2,0]]

**Output:**
2

**Explanation:**
The two boomerangs are **[[1,0],[0,0],[2,0]]** and **[[1,0],[2,0],[0,0]]**
class Solution {
public:
    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {
        int res = 0;
        for (int i = 0; i &lt; points.size(); ++i) {
            unordered_map&lt;int, int&gt; m;
            for (int j = 0; j &lt; points.size(); ++j) {
                int a = points[i].first - points[j].first;
                int b = points[i].second - points[j].second;
                ++m[a * a + b * b];
            }
            for (auto it = m.begin(); it != m.end(); ++it) {
                res += it-&gt;second * (it-&gt;second - 1);
            }
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_149 点坐标的表示 整数 浮点数 </li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given  n  points on a 2D plane, find the maximum number of points that lie on the same straight line.

Example 1:

Input: [[1,1],[2,2],[3,3]]
Output: 3
Explanation:
^
|
|        o
|     o
|  o  
+-------------&gt;
0  1  2  3  4
class Solution {
public:
    int maxPoints(vector&lt;Point&gt;&amp; points) {
        int res = 0;
        for (int i = 0; i &lt; points.size(); ++i) {
            map&lt;pair&lt;int, int&gt;, int&gt; m;
            int duplicate = 1;
            for (int j = i + 1; j &lt; points.size(); ++j) {
                if (points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y) {
                    ++duplicate; continue;
                } 
                int dx = points[j].x - points[i].x;
                int dy = points[j].y - points[i].y;
                int d = gcd(dx, dy);
                ++m[{dx / d, dy / d}];
            }
            res = max(res, duplicate);
            for (auto it = m.begin(); it != m.end(); ++it) {
                res = max(res, it-&gt;second + duplicate);
            }
        }
        return res;
    }
    int gcd(int a, int b) {
        return (b == 0) ? a : gcd(b, a % b);
    }
};
</code></pre>

<h4>滑动窗口和查找</h4>

<ul>
<li>leet_217</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.find(nums[i]) != m.end()) return true;
            ++m[nums[i]];
        }
        return false;
    }
};
</code></pre>

<ul>
<li>leet_219</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array of integers and an integer k, return true if and only if there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. (Old Version)

Given an array of integers and an integer k , find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. (New Version)
class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.find(nums[i]) != m.end() &amp;&amp; i - m[nums[i]] &lt;= k) return true;
            else m[nums[i]] = i;
        }
        return false;
    }
};
</code></pre>

<ul>
<li>leet_220</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) {
      map&lt;long long, int&gt; m;
      int j = 0;
      for (int i = 0; i &lt; nums.size(); i++) {
        if (i - j &gt; k) m.erase(nums[j++]);
        auto a = m.lower_bound((long long)nums[i] - t);
        if (a != m.end() &amp;&amp; abs(a-&gt;first - nums[i]) &lt;= t) return true;
        m[nums[i]] = i;
      }
      return false;
    }
};
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/02 10:36 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_29.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_31.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>eredin-blog</h1>
                <div class="site-des">生命的意义是成为你自己！</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Prometheus.html"><strong>Prometheus</strong></a>
        
            <a href="RocketMQ.html"><strong>RocketMQ</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html"><strong>网络协议</strong></a>
        
            <a href="Golang.html"><strong>Golang</strong></a>
        
            <a href="Django.html"><strong>Django</strong></a>
        
            <a href="C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98.html"><strong>C++设计模式实战</strong></a>
        
            <a href="%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes.html"><strong>深入剖析Kubernetes</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html"><strong>数据结构和算法</strong></a>
        
            <a href="%E5%BE%AE%E6%9C%8D%E5%8A%A1.html"><strong>微服务</strong></a>
        
            <a href="%E6%9E%B6%E6%9E%84.html"><strong>架构</strong></a>
        
            <a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html"><strong>操作系统原理</strong></a>
        
            <a href="Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Mysql优化实战</strong></a>
        
            <a href="Kafka.html"><strong>Kafka</strong></a>
        
            <a href="linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html"><strong>linux服务器研发</strong></a>
        
            <a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html"><strong>计算机组成原理</strong></a>
        
            <a href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html"><strong>程序员的自我修养</strong></a>
        
            <a href="C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6.html"><strong>C语言进阶</strong></a>
        
            <a href="http_study.html"><strong>http_study</strong></a>
        
            <a href="%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html"><strong>玩转算法</strong></a>
        
            <a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html"><strong>C++对象模型</strong></a>
        
            <a href="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html"><strong>SQL必知必会</strong></a>
        
            <a href="Zookeeper.html"><strong>Zookeeper</strong></a>
        
            <a href="Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html"><strong>Redis从入门到精通</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6.html"><strong>数据结构和算法进阶</strong></a>
        
            <a href="Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html"><strong>Mysql性能管理和架构设计</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html"><strong>网络编程实战</strong></a>
        
            <a href="Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html"><strong>Redis高并发缓存</strong></a>
        
            <a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html"><strong>C++基础与提高</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html"><strong>设计模式之美</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
        
            <a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Linux性能优化实战</strong></a>
        
            <a href="%E5%80%99%E6%8D%B7STL.html"><strong>候捷STL</strong></a>
        
            <a href="%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE.html"><strong>性能工程高手课</strong></a>
        
            <a href="%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html"><strong>性能测试</strong></a>
        
            <a href="ElasticSearch.html"><strong>ElasticSearch</strong></a>
        
            <a href="RabbitMQ.html"><strong>RabbitMQ</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15817610843879.html">编译期</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814649492497.html">Simple Factory</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814189410719.html">代码的可测试性</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814188057978.html">重构</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813811739408.html">tuple 使用</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
