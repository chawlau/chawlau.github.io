<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  eredin-blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="eredin-blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; eredin-blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html">C++基础与提高</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Golang.html">Golang</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html">设计模式之美</a></li>
        
            <li><a href="%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE.html">性能工程高手课</a></li>
        
            <li><a href="%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html">性能测试</a></li>
        
            <li><a href="Prometheus.html">Prometheus</a></li>
        
            <li><a href="RocketMQ.html">RocketMQ</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html">网络协议</a></li>
        
            <li><a href="Django.html">Django</a></li>
        
            <li><a href="%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes.html">深入剖析Kubernetes</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html">数据结构和算法</a></li>
        
            <li><a href="%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务</a></li>
        
            <li><a href="%E6%9E%B6%E6%9E%84.html">架构</a></li>
        
            <li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">操作系统原理</a></li>
        
            <li><a href="Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Mysql优化实战</a></li>
        
            <li><a href="Kafka.html">Kafka</a></li>
        
            <li><a href="linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html">linux服务器研发</a></li>
        
            <li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html">计算机组成原理</a></li>
        
            <li><a href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html">程序员的自我修养</a></li>
        
            <li><a href="C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6.html">C语言进阶</a></li>
        
            <li><a href="http_study.html">http_study</a></li>
        
            <li><a href="%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html">玩转算法</a></li>
        
            <li><a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html">C++对象模型</a></li>
        
            <li><a href="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html">SQL必知必会</a></li>
        
            <li><a href="Zookeeper.html">Zookeeper</a></li>
        
            <li><a href="Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html">Redis从入门到精通</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6.html">数据结构和算法进阶</a></li>
        
            <li><a href="Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">Mysql性能管理和架构设计</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html">网络编程实战</a></li>
        
            <li><a href="Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html">Redis高并发缓存</a></li>
        
            <li><a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Linux性能优化实战</a></li>
        
            <li><a href="%E5%80%99%E6%8D%B7STL.html">候捷STL</a></li>
        
            <li><a href="ElasticSearch.html">ElasticSearch</a></li>
        
            <li><a href="RabbitMQ.html">RabbitMQ</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15680680837389.html">
                
                  <h1>Redis集群深入</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>伸缩原理</h4>

<ul>
<li><img src="media/15680680837389/15680681507398.jpg" alt="" style="width:940px;"/></li>
<li>槽和数据在节点之间移动</li>
</ul>

<h4>集群扩容</h4>

<ul>
<li>准备新节点</li>
<li>加入集群</li>
<li>迁移槽和数据</li>
</ul>

<h4>加入集群</h4>

<ul>
<li>为它迁移槽和数据实现扩容</li>
<li>作为从节点负责故障转移</li>
</ul>

<h4>迁移槽数据</h4>

<ul>
<li>槽迁移计算</li>
<li>迁移数据</li>
<li>添加从节点</li>
<li><img src="media/15680680837389/15680687611415.jpg" alt="" style="width:876px;"/></li>
</ul>

<h4>数据迁移</h4>

<ul>
<li>对目标节点发送：cluster setslot{ slot) importing{ source Nodeld}命令，让目标节点准备导入槽的数据。</li>
<li>对源节点发送：cluster setslot{slot} migrating{ target Nodelc아命令，让源节点准备迁出槽的数据。</li>
<li>源节点循环执行 cluster getkeysinslot{slot{ count}命令，每次获取 count 个属于槽的健</li>
<li>在源节点上执行 migrate  (ftargetlp)  (targetport) key0{ timeout 命令把指定 key 迁移重复执行步骤 3~4 直到槽下所有的键数据迁移到目标节点。</li>
<li>向集群内所有主节点发送 cluster setslot{ slot) node ftargetnodeld}命令，通知槽分配给目标节点。</li>
<li><img src="media/15680680837389/15680691770164.jpg" alt="" style="width:596px;"/></li>
<li>pipeline migrate</li>
<li><img src="media/15680680837389/15680692695123.jpg" alt="" style="width:833px;"/></li>
</ul>

<h4>集群收缩</h4>

<ul>
<li><img src="media/15680680837389/15680704949393.jpg" alt="" style="width:711px;"/></li>
<li>cluster forget</li>
<li>redis-trib reshard --from nodeid --to nodeid --slots nums ip port</li>
<li>redis-trib del-node ip:port nodeid</li>
<li>先主后从</li>
</ul>

<h4>客户端</h4>

<ul>
<li><img src="media/15680680837389/15680710106807.jpg" alt="" style="width:264px;"/></li>
</ul>

<h4>重定向</h4>

<ul>
<li>move重定向</li>
<li><img src="media/15680680837389/15680711361230.jpg" alt="" style="width:822px;"/></li>
<li>ask重定向</li>
<li><img src="media/15680680837389/15680721661878.jpg" alt="" style="width:424px;"/></li>
<li><img src="media/15680680837389/15680722142345.jpg" alt="" style="width:874px;"/></li>
<li>对比</li>
<li><img src="media/15680680837389/15680722554912.jpg" alt="" style="width:450px;"/></li>
<li>随机访问和性能</li>
</ul>

<h4>smart客户端</h4>

<ul>
<li><img src="media/15680680837389/15680724129947.jpg" alt="" style="width:785px;"/></li>
<li><img src="media/15680680837389/15680724793536.jpg" alt="" style="width:857px;"/></li>
</ul>

<h4>批量操作</h4>

<ul>
<li>mget mset必须在同一个槽</li>
<li>串行mget</li>
<li>串行IO</li>
<li><img src="media/15680680837389/15680733968971.jpg" alt="" style="width:1458px;"/></li>
<li>并行IO</li>
<li><img src="media/15680680837389/15680734290342.jpg" alt="" style="width:1469px;"/></li>
<li>hash_tag</li>
<li><img src="media/15680680837389/15680734688574.jpg" alt="" style="width:1360px;"/></li>
<li><img src="media/15680680837389/15680734909089.jpg" alt="" style="width:1457px;"/></li>
<li>hash_tag Redis中引入了HashTag的概念，可以让算法只对key的某一部分进行计算，让key落到相同数据分片。</li>
</ul>

<h4>故障转移</h4>

<ul>
<li>故障发现</li>
<li>ping/pong消息实现故障发现</li>
<li>主观下线</li>
<li><img src="media/15680680837389/15680737537823.jpg" alt="" style="width:1091px;"/></li>
<li>客观下线</li>
<li><img src="media/15680680837389/15680739618953.jpg" alt="" style="width:1212px;"/></li>
<li><img src="media/15680680837389/15680740159698.jpg" alt="" style="width:1344px;"/></li>
</ul>

<h4>故障恢复</h4>

<ul>
<li>资格检查</li>
<li><img src="media/15680680837389/15680741572842.jpg" alt="" style="width:1308px;"/></li>
<li>准备选举时间</li>
<li><img src="media/15680680837389/15680741882554.jpg" alt="" style="width:966px;"/></li>
<li>选举投票</li>
<li><img src="media/15680680837389/15680742011334.jpg" alt="" style="width:786px;"/></li>
<li>替换主节点</li>
<li><img src="media/15680680837389/15680742546123.jpg" alt="" style="width:1164px;"/></li>
</ul>

<h4>集群完整性</h4>

<ul>
<li>Cluster-require- full-coverages 默认为 yes</li>
<li>集群中 16384 个槽全部可用：保证集群完整性 17680648932 正在看</li>
<li>节点故障或者正在故障转移 (error) CLUSTERDOWN The cluster is down</li>
<li>大多数业务无法容忍，cluster-require- full-coverages 建议设置为 no</li>
</ul>

<h4>带宽消耗</h4>

<ul>
<li><img src="media/15680680837389/15681614212661.jpg" alt="" style="width:1370px;"/></li>
<li>消息发送频率：节点发现与其它节点最后通信时间超过 cluster node- timeout,/2时会直接发送ping消息 0463941</li>
<li>消息数据量：slots槽数组(2KB空间)和整个集群1/10的状态数据（10 个节点状态数据约 1 KB)</li>
<li>节点部署的机器规模：集群分布的机器越多且每台机器划分的节点数越均匀，则集群内整体的可用带宽越高。</li>
</ul>

<h5>优化</h5>

<ul>
<li>避免多业务使用一个集群，大业务可以多集群</li>
<li>cluster-node-timeout 带宽和故障转移速度的均衡。尽量均匀分配到多机器上</li>
<li>保证高可用和带宽</li>
</ul>

<h4>Pub/Sub 广播</h4>

<ul>
<li><img src="media/15680680837389/15681616136157.jpg" alt="" style="width:925px;"/></li>
<li>问题：publish 在集群每个节点广播：加重带宽</li>
<li>解决：单独“走”一套 Redis Sentinel</li>
</ul>

<h4>数据倾斜</h4>

<h5>内存不均</h5>

<ul>
<li>节点和槽分配不均</li>
<li>redis-cli info ip:port</li>
<li>redis-cli reshard ip:port</li>
</ul>

<h5>不同槽对应键值数量差异较大</h5>

<ul>
<li>CRC16 正常情况下比较均匀</li>
<li>可能存在 hash_tag</li>
<li>cluster countkeysinslot{slt}获取槽对应键值个数</li>
</ul>

<h5>包含bigkey</h5>

<ul>
<li>Bigley：例如大字符串、几百万的元素的 hash、set 等从节点：</li>
<li>redis-cli- bigkeys</li>
<li>优化：优化数据结构。</li>
</ul>

<h5>内存相关配置不一致</h5>

<ul>
<li>Hash-max-ziplist-value, set-max-intset-entriess </li>
<li>优化：定期“检查”配置一致性</li>
</ul>

<h5>请求倾斜</h5>

<ul>
<li>热点 key：重要的 key 或者 bigley </li>
<li>优化避免 bigley 热键</li>
<li>不要用 hash_tag</li>
<li>当一致性不高时，可以用本地缓存+MQ</li>
</ul>

<h4>集群读写分离</h4>

<h5>只读连接：集群模式的从节点不接受任何读写请求</h5>

<ul>
<li>重定向到负责槽的主节点</li>
<li>readonly 命令可以读：连接级别命令</li>
</ul>

<h5>读写分离：更加复杂</h5>

<ul>
<li>同样的问题：复制延退、读取过期数据、从节点故障</li>
<li>修改客户端：cluster slaves{ nodeld}</li>
</ul>

<h4>数据迁移</h4>

<h5>redis-trib.rb import</h5>

<ul>
<li>只能从单机迁移到集群不支持在线迁移：</li>
<li>source 需要停写</li>
<li>不支持断点续传</li>
<li>单线程迁移：影响速度</li>
</ul>

<h5>在线迁移</h5>

<ul>
<li>唯品会 redis- migrate-tool </li>
<li>豌豆英：redis-port</li>
</ul>

<h4>集群限制</h4>

<ul>
<li>Key 批量操作支持有限：例如 mget、mset 必须在一个 slot </li>
<li>Key 事务和 Lua 支持有限：操作的 key 必须在一个节点 </li>
<li>Key 是数据分区的最小粒度：不支持 bigkey 分区</li>
<li>不支持多个数据库：集群模式下只有一个 db0</li>
<li>复制只支持一层。不支持树形复制</li>
</ul>

<h4>分布式Redis</h4>

<ul>
<li>Redis Cluster：满足容量和性能的扩展性，很多业务”不需要”</li>
<li>大多数时客户端性能会”降低”。</li>
<li>命令无法跨节点使用：mget、keys、scan、flush、sintera 等。Lua 和事务无法跨节点使用。</li>
<li>客户端维护更复杂：SDK 和应用本身消耗（例如更多的连接池）。</li>
<li>很多场景 Redis Sentinel 已经足够好。</li>
</ul>

<h4>集群总结</h4>

<ul>
<li>使用 smart 客户端操作集群达到通信效率最大化，客户端内部负责计算维护键-》槽-》节点的映射，用于快速定位到目标节点。</li>
<li>集群自动故障转移过程分为故障发现和节点恢复。节点下线分为主观下线和客观下线，当超过半数主节点认为故障节点为主观下线时标记它为客观下线状态。从节点负责对客观下线的主节点触发故障恢复流程，保证集群的可用性。</li>
<li>开发运维常见问题包括: 超大规模集群带宽消耗,pub/sub 广播问题，集</li>
<li>群倾斜问题，单机和集群对比等</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/09/10 06:28 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html'>Redis从入门到精通</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15701380646450.html">
                
                  <h1>Redis持久化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/04 05:27 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html'>Redis高并发缓存</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15700073181059.html">
                
                  <h1>function&& bind</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>可调用对象</h4>

<ul>
<li>函数</li>
<li>重载()对象</li>
</ul>

<h4>可被转换的函数指针的类对象</h4>

<pre class="line-numbers"><code class="language-cpp">class CT {
 public:
  using tfptr = void(*)(int);

  static void st_func(int t) {
    cout &lt;&lt; &quot;static function &quot; &lt;&lt; t &lt;&lt; endl;
  }

  operator tfptr() {return st_func;}
};
int main() {
  using ptr = void(*)(int);
  CT ct;
  ct(5);
}
</code></pre>

<h4>function</h4>

<ul>
<li><p>能够通过给它指定模版参数，能够以统一的方式来处理函数</p>
<pre class="line-numbers"><code class="language-cpp">function&lt;void(int)&gt; ptr = func;
ptr(3);<br/>
function&lt;void(int)&gt; ptr2 = TC::st_func;<br/>
ptr2(12);<br/>
TC tc;<br/>
function&lt;void(int)&gt; ptr3 = tc;<br/>
ptr3(12);
</code></pre></li>
</ul>

<h4>bind</h4>

<ul>
<li>可调用对象和参数绑定到一起， 构成防函数</li>
<li>如果是多个参数，可以部分绑定</li>
<li>bind对预先绑定的参数是通过值传递的</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">void func(int t) {
  cout &lt;&lt; &quot; t &quot; &lt;&lt; t &lt;&lt; endl;
}

class CT {
 public:
  using tfptr = void(*)(int);

  static void st_func(int t) {
    cout &lt;&lt; &quot;static function &quot; &lt;&lt; t &lt;&lt; endl;

  }

  operator tfptr() {return st_func;}

  void func(int x, int y) {
    m_a++;
    cout &lt;&lt; &quot;x &quot; &lt;&lt; x &lt;&lt; &quot; y &quot; &lt;&lt; y &lt;&lt; &quot; m_a &quot;&lt;&lt; m_a &lt;&lt; endl;
  }

  ~CT() { std::cout &lt;&lt; &quot; destory &quot; &lt;&lt; endl;}
  CT() { std::cout &lt;&lt; &quot; construct &quot; &lt;&lt; endl;}
  int m_a;
};

void bfunc(int x, int y, int z) {
  cout &lt;&lt; &quot;x &quot; &lt;&lt; x &lt;&lt; &quot; y &quot; &lt;&lt; y &lt;&lt; &quot; z &quot; &lt;&lt; z &lt;&lt; endl;
}
void bfunc2(int&amp; x, int&amp; y) {
  x++;
  y++;
}

int main() {
  //绑定函数bfunc的参数30，placeholders::_1表示需要f1来参数
  auto f1 = bind(bfunc, placeholders::_1, placeholders::_1, 30);
  bind(bfunc, placeholders::_1, placeholders::_2, 30)(5, 15);
  f1(1);

  auto f3 = bind(bfunc, placeholders::_2, placeholders::_1, 30);
  f3(5,15);


  int a = 2, b = 3;
  //bind对预先绑定的参数是通过值传递的,所以a值是值传递的, 没有事先绑定的是引用传
  //递
  auto f4 = bind(bfunc2, a, placeholders::_1);
  f4(b);
  cout &lt;&lt; &quot;a &quot; &lt;&lt; a &lt;&lt; &quot; b &quot; &lt;&lt; b &lt;&lt; endl;

  CT ct;
  ct.m_a = 1;
  //生成了防函数的临时对象，后续的func修改的是临时对象的m_a;
  //如果传的是对象引用，则不生成临时对象
  auto f5 = bind(&amp;CT::func, ct, placeholders::_1, placeholders::_2);
  f5(10, 20);
  cout &lt;&lt; &quot;ct m_a = &quot; &lt;&lt; ct.m_a &lt;&lt; endl;

  function&lt;void(int,int)&gt; f6 = bind(&amp;CT::func, ct, placeholders::_1, placeholders::_2);
  f6(10, 223);

  cout &lt;&lt; &quot;=================&quot; &lt;&lt; endl;
  CT ct1;
  //第一次拷贝系统需要ct1产生临时对象，第二次是bind本身要返回临时对象，但是bind
  //执行完毕后，临时对象会被释放
  function&lt;int &amp;()&gt; f7 = bind(&amp;CT::m_a, &amp;ct1);
  f7() = 60;
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/02 17:08 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15700959965580.html">
                
                  <h1>应对DDos攻击和TFO</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>DDos参数配置</h4>

<ul>
<li>/proc/sys/net/ipv4/tcp_syncookies</li>
<li>/proc/sys/net/ipv4/tcp_max_syn_backlog</li>
<li>/proc/sys/net/ipv4/tcp_synack_retries</li>
<li>当 SYN 队列满后，新的 SYN 不进入队列，计算出 cookie 再以 SYN+ACK 中的序列号返回客户端，正常客户端发报文时，服务器根据报文中携带的 cookie 重新恢复连接</li>
<li>当 SYN 队列满后，新的 SYN 不进入队列，计算出 cookie 再以 SYN+ACK 中的序列号返回客户端，正常客户端发报文时，服务器根据报文中携带的 cookie 重新恢复连接</li>
<li>由于cookies 占用序列号空间，导致此时所有 TCP 可选功能失效，例如扩充窗口、时间戳等</li>
<li>tcp_syncookies只有在队列满了之后才使用，防止ddos攻击</li>
<li>SYN-Cookie避免了内存空间被爆掉，但是却引来了CPU时间被爆掉的机会，这又是一种时间-空间之间的权衡！如果攻击者发送大量的ACK包过来，那么被攻击机器将会花费大量的CPU时间在计算Cookie上，造成正常的逻辑无法被执行，同时即便是大量的SYN包也可以将CPU爆满</li>
</ul>

<h4>Tcp Fast Open</h4>

<h5>开启</h5>

<pre class="line-numbers"><code class="language-text">服务器配置 echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen系统开启TFO功能
</code></pre>

<ul>
<li>0: 关闭</li>
<li>1: 作为客户端时可以使用 TFO</li>
<li>2: 作为服务器时可以使用 TFO</li>
<li>3: 无论作为客户端还是服务器，都可以使用 TFO</li>
<li>ip tcp_metrics show | grep &quot;fo_cookie&quot; 查看cookie</li>
</ul>

<h5>截图</h5>

<ul>
<li><img src="media/15601259183343/15642728044011.jpg" alt="" style="width:1617px;"/></li>
<li>为防止带数据的 SYN 攻击，限制最大长度，指定 TFO 连接队列的最大长度</li>
<li>减少Cpu消耗</li>
<li>客户端的TFOcookie多长时间后删除，谁来维护和删除？</li>
<li>nginx的TFO队列具体是什么意思？队列满了会怎样？数值设定多少合适？ </li>
</ul>

<h5>TFO原理</h5>

<ul>
<li>客户端发送SYN包，包尾加一个FOC请求，只有4个字节。</li>
<li>服务端受到FOC请求，验证后根据来源ip地址声称cookie(8个字节)，将这个COOKIE加载SYN+ACK包的末尾发送回去。</li>
<li>客户端缓存住获取到的Cookie 可以给下一次使用。</li>
<li>下一次请求开始，客户端发送SYN包，这时候后面带上缓存的COOKIE，然后就是正式发送的数据。</li>
<li>服务器端验证COOKIE正确，将数据交给上层应用处理得到相应结果，然后在发送SYN+ACK时，不再等待客户端的ACK确认，即开始发送相应数据。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/03 17:46 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Linux性能优化实战</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15700925706491.html">
                
                  <h1>Redis 性能调优</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>问题描述</h4>

<ul>
<li>Can&#39;t save in background: fork: Cannot allocate memory</li>
<li>maxmemory10 G-，这个选项非常重要，它用来指定 Redis 可使用的最大内存，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。</li>
</ul>

<h4>/proc/sys/vm/overcommit_memory</h4>

<ul>
<li>0, 默认值，表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</li>
<li>1, 表示内核允许分配所有的物理内存，而不管当前的内存状态如何</li>
<li>2, 表示内核允许分配超过所有物理内存和交换空间总和的内存。</li>
</ul>

<h4>问题解决</h4>

<ul>
<li>我们操作系统物理内存是 16 G, redis 主进程占用了最大 10 G 内存，而 fork 子进程也需要 10 G 的内存，这样，redis 总共就需要 20 GB 内存了，而操作系统只有 16 GB 物理内存，肯定会报内存无法分配。</li>
<li>修改maxmemory为小于物理内存的一半</li>
<li>增加服务器物理内存</li>
</ul>

<h4>redis</h4>

<ul>
<li>config get auto-aof-rewrite-min-size </li>
<li>config get auto-aof-rewrite-percentage</li>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/03 16:49 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Linux性能优化实战</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15700893160219.html">
                
                  <h1>网卡中断过高优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>软硬中断区别</h4>

<ul>
<li>(1) 硬中断是有外设硬件发出的，需要有中断控制器参与，而软中断则通常是由硬中断处理程序或者进程调度程序等软件程序发出的中断信号，无需中断控制器参与。</li>
<li>(2) 硬中断直接以硬件的方式引发，处理速度快。软中断以软件指令之方式适合于对响应速度要求不是特别严格的场景。</li>
<li>(3) 硬中断通过设置 CPU 的屏蔽位可进行屏蔽，软中断则由于是指令之方式给出, 不能屏蔽。</li>
<li>(4)硬中断和软中断均会引起上下文切换(进程/线程之切换），进程切换的过程是差不多的</li>
</ul>

<h4>诊断中断</h4>

<ul>
<li>top</li>
<li>cat /proc/interrupts | grep ens33 获取中断号</li>
<li>IRQ 号決定了需要被 CPU 处理的优先级，IRQ 号越小意味着被优先执行的级别越高</li>
<li>mpstat -P ALL 2 //查看所有cpu核的状态信息</li>
<li>cat /proc/irq/19/smp_affinity</li>
<li>cat /proc/irq/19/smp_affinity_list 查看网卡中断集中在哪个cpu上</li>
<li>echo 1 &gt; /proc/irq/19/smp_affinity_list 设置网卡中断亲和</li>
</ul>

<h4>配置 RPS 绑定网卡队列到 CPU</h4>

<ul>
<li>echo 0,1 &gt; /proc/irq/19/smp_affinity_list 仍然会导致网卡中断集中在一个cpu上</li>
</ul>

<pre class="line-numbers"><code class="language-text">echo f &gt; /sys/class/net/ens33/queues/rx-0/rps_cpus
sysctl net.core.rps_sock_flow_entries=32768
echo 32678 &gt; /sys/class/net/ens33/queues/rx-0/rps_flow_cnt
</code></pre>

<ul>
<li>软件层面模拟实现硬件的多队列网卡功能。</li>
</ul>

<h4>使用IRQBalance服务</h4>

<h4>RSS</h4>

<ul>
<li>RSS (Receive Side Scaling）是网卡的硬件特性，实现了多队列。通过多队列网卡驱动加载，就可以获取网卡型号，得到网卡的硬件队列数量，并结合 CPU 核的数量，最终得出所要激活的网卡队列的数量。</li>
<li>ethtool -l eth0</li>
<li>ethtool -L eth0 combined num//最多支持的队列数目</li>
<li>手动绑定,获取网卡的中断号</li>
<li>cat /proc/interrupts | awk &#39;{print \(1, \)NF}&#39; | grep eth0-TxRx</li>
<li>echo 中断号 &gt; /proc/irq/19/smp_affinity_list</li>
</ul>

<h4>如果队列数目小于cpu数目</h4>

<ul>
<li>如果手动绑定 CPU 与中断号ーー对应，就会出现软中断负载跑在 0-7 核上，8-1 5 核不处理软中断的情况，这样一来，CPU 的 0-7 核负载依然会很高。</li>
<li>RFS (Receive Flow Steering）是 RPS 的扩展，由于 RPS 只是单纯的把数据包均衡到不同的 CPU 上，此时如果应用程序所在 CPU 和中断处理的 CPU 不在同个核，将会对 CPU Cache 影响很大，RFS 的作用就是将应用程序和软中断处理分配到同一个 CPU 上</li>
<li>在多队列情况下，rps_flow_cntl 的值建议设为 rps_sock_flow_entries 除以 N，其中 N 是设备中接收队列的数量。例如，如果 rps flow_entries 设为 32768, 并且有 8 个配置接收队列，那么 rps_flow_cnt 就应设为 4096</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/03 15:55 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Linux性能优化实战</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15671314584110.html">
                
                  <h1>递归和回溯</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>树形问题</h4>

<ul>
<li>leet_17  O(2<sup>n)</sup></li>
</ul>

<pre class="line-numbers"><code class="language-text">Input: &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
class Solution {
public:
    vector&lt;string&gt; letterCombinations(string digits) {
        if (digits.empty()) return {};
        vector&lt;string&gt; res;
        vector&lt;string&gt; dict{&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
        letterCombinationsDFS(digits, dict, 0, &quot;&quot;, res);
        return res;
    }
    void letterCombinationsDFS(string&amp; digits, vector&lt;string&gt;&amp; dict, int level, string out, vector&lt;string&gt;&amp; res) {
        if (level == digits.size()) {res.push_back(out); return;}
        string str = dict[digits[level] - &#39;0&#39;];
        for (int i = 0; i &lt; str.size(); ++i) {
            letterCombinationsDFS(digits, dict, level + 1, out + str[i], res);
        }
    }
}; 
</code></pre>

<ul>
<li>字符串合法性 空字符串 多个解的顺序</li>
<li>s(d[0..n-1]) = letter(d[0]) + s(d[1...n-1])</li>
<li>leet_93</li>
</ul>

<pre class="line-numbers"><code class="language-text">Input: &quot;25525511135&quot;
Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]
class Solution {
public:
    vector&lt;string&gt; restoreIpAddresses(string s) {
        vector&lt;string&gt; res;
        restore(s, 4, &quot;&quot;, res);
        return res;
    }
    void restore(string s, int k, string out, vector&lt;string&gt; &amp;res) {
        if (k == 0) {
            if (s.empty()) res.push_back(out);
        }
        else {
            for (int i = 1; i &lt;= 3; ++i) {
                if (s.size() &gt;= i &amp;&amp; isValid(s.substr(0, i))) {
                    if (k == 1) restore(s.substr(i), k - 1, out + s.substr(0, i), res);
                    else restore(s.substr(i), k - 1, out + s.substr(0, i) + &quot;.&quot;, res);
                }
            }
        }
    }
    bool isValid(string s) {
        if (s.empty() || s.size() &gt; 3 || (s.size() &gt; 1 &amp;&amp; s[0] == &#39;0&#39;)) return false;
        int res = atoi(s.c_str());
        return res &lt;= 255 &amp;&amp; res &gt;= 0;
    }
};
</code></pre>

<ul>
<li>leet_131</li>
</ul>

<pre class="line-numbers"><code class="language-text">Input: &quot;aab&quot;
Output:
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]

class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        vector&lt;vector&lt;string&gt;&gt; res;
        vector&lt;string&gt; out;
        helper(s, 0, out, res);
        return res;
    }
    void helper(string s, int start, vector&lt;string&gt;&amp; out, vector&lt;vector&lt;string&gt;&gt;&amp; res) {
        if (start == s.size()) { res.push_back(out); return; }
        for (int i = start; i &lt; s.size(); ++i) {
            if (!isPalindrome(s, start, i)) continue;
            out.push_back(s.substr(start, i - start + 1));
            helper(s, i + 1, out, res);
            out.pop_back();
        }
    }
    bool isPalindrome(string s, int start, int end) {
        while (start &lt; end) {
            if (s[start] != s[end]) return false;
            ++start; --end;
        }
        return true;
    }
};
</code></pre>

<h4>回溯算法</h4>

<ul>
<li>排列leet_46 perm(0...n-1) = num +perm(0...n-1 - 这个数字)</li>
</ul>

<pre class="line-numbers"><code class="language-text">Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
class Solution {
public:
  vector&lt;vector&lt;int&gt;&gt; res;
  vector&lt;bool&gt; used = {false};

  void generatPermutation(const vector&lt;int&gt;&amp; nums, int index, vector&lt;int&gt;&amp; p) {
    if (index == nums.size()) {
      res.push_back(p);
      return;
    }

    for (int i = 0; i &lt; nums.size(); i++) {
      if (!used[i]) {
        p.push_back(nums[i]);
        used[i] = true;
        generatPermutation(nums, index + 1, p);
        p.pop_back();
        used[i] = false;
      }
    }
    return;
  }

  vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0)
      return res;

    used = vector&lt;bool&gt;(nums.size(), false);
    vector&lt;int&gt; p;
    generatPermutation(nums, 0, p);
    return res;
  } 
};
</code></pre>

<ul>
<li>leet_47 </li>
</ul>

<pre class="line-numbers"><code class="language-text">Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
class Solution {
public:
  
  vector&lt;vector&lt;int&gt;&gt; res;
  vector&lt;bool&gt; used;
  void generatPermutation(const vector&lt;int&gt;&amp; nums, int index, vector&lt;int&gt;&amp; p) {
    if (index == nums.size()) {
      res.push_back(p);
      return;
    }

    for (int i = 0; i &lt; nums.size(); i++) {
      if(i &gt; 0 &amp;&amp; nums[i-1] == nums[i] &amp;&amp; !used[i-1])
        continue;

      if (!used[i]) {
        p.push_back(nums[i]);
        used[i] = true;
        generatPermutation(nums, index + 1, p);
        p.pop_back();
        used[i] = false;
      }
    }
    return;
  }

  vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0)
      return res;

    used = vector&lt;bool&gt;(nums.size(), false);
    vector&lt;int&gt; p;
    sort(nums.begin(), nums.end());
    generatPermutation(nums, 0, p);
    return res;
  }
};
</code></pre>

<h4>组合</h4>

<ul>
<li>leet_77</li>
</ul>

<pre class="line-numbers"><code class="language-text">For example,
If  n  = 4 and  k  = 2, a solution is:

[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; out;
        helper(n, k, 1, out, res);
        return res;
    }
    void helper(int n, int k, int level, vector&lt;int&gt;&amp; out, vector&lt;vector&lt;int&gt;&gt;&amp; res) {
        if (out.size() == k) {res.push_back(out); return;}
        for (int i = level; i &lt;= n; ++i) {
            out.push_back(i);
            helper(n, k, i + 1, out, res);
            out.pop_back();
        }
    }
};
</code></pre>

<ul>
<li>leet_39</li>
</ul>

<pre class="line-numbers"><code class="language-text">Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
//重复元素i层级不加1
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; out;
        combinationSumDFS(candidates, target, 0, out, res);
        return res;
    }
    void combinationSumDFS(vector&lt;int&gt;&amp; candidates, int target, int start, vector&lt;int&gt;&amp; out, vector&lt;vector&lt;int&gt;&gt;&amp; res) {
        if (target &lt; 0) return;
        if (target == 0) {res.push_back(out); return;}
        for (int i = start; i &lt; candidates.size(); ++i) {
            out.push_back(candidates[i]);
            combinationSumDFS(candidates, target - candidates[i], i, out, res);
            //重复元素i层级不加1
            out.pop_back();
        }
    }
};
</code></pre>

<ul>
<li>leet_40</li>
</ul>

<pre class="line-numbers"><code class="language-text">For example, given candidate set 10,1,2,7,6,1,5 and target 8, 
A solution set is: 
[1, 7] 
[1, 2, 5] 
[2, 6] 
[1, 1, 6] 

class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) {
        vector&lt;vector&lt;int&gt; &gt; res;
        vector&lt;int&gt; out;
        sort(num.begin(), num.end());
        combinationSum2DFS(num, target, 0, out, res);
        return res;
    }
    void combinationSum2DFS(vector&lt;int&gt; &amp;num, int target, int start, vector&lt;int&gt; &amp;out, vector&lt;vector&lt;int&gt; &gt; &amp;res) {
        if (target &lt; 0) return;
        else if (target == 0) res.push_back(out);
        else {
            for (int i = start; i &lt; num.size(); ++i) {
                //可以去除组合中的重复元素
                if (i &gt; start &amp;&amp; num[i] == num[i - 1]) continue;
                out.push_back(num[i]);
                combinationSum2DFS(num, target - num[i], i + 1, out, res);
                //不重复使用元素，所以层级+1
                out.pop_back();
            }
        }
    }
};
</code></pre>

<ul>
<li>leet_216</li>
</ul>

<pre class="line-numbers"><code class="language-text">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; combinationSum3(int k, int n) {
        vector&lt;vector&lt;int&gt; &gt; res;
        vector&lt;int&gt; out;
        combinationSum3DFS(k, n, 1, out, res);
        return res;
    }
    void combinationSum3DFS(int k, int n, int level, vector&lt;int&gt; &amp;out, vector&lt;vector&lt;int&gt; &gt; &amp;res) {
        if (n &lt; 0) return;
        if (n == 0 &amp;&amp; out.size() == k) res.push_back(out);
        for (int i = level; i &lt;= 9; ++i) {
            out.push_back(i);
            combinationSum3DFS(k, n - i, i + 1, out, res);
            out.pop_back();
        }
    }
};
</code></pre>

<ul>
<li>leet_78</li>
</ul>

<pre class="line-numbers"><code class="language-text">If  S  = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) {
        vector&lt;vector&lt;int&gt; &gt; res;
        vector&lt;int&gt; out;
        sort(S.begin(), S.end());
        getSubsets(S, 0, out, res);
        return res;
    }
    void getSubsets(vector&lt;int&gt; &amp;S, int pos, vector&lt;int&gt; &amp;out, vector&lt;vector&lt;int&gt; &gt; &amp;res) {
       //没有条件和外加边界限制
        res.push_back(out);
        for (int i = pos; i &lt; S.size(); ++i) {
            out.push_back(S[i]);
            getSubsets(S, i + 1, out, res);
            out.pop_back();
        }
    }
};

</code></pre>

<ul>
<li>leet_90</li>
</ul>

<pre class="line-numbers"><code class="language-text">For example,
If  S  = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt; &amp;S) {
        if (S.empty()) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; out;
        sort(S.begin(), S.end());
        getSubsets(S, 0, out, res);
        return res;
    }
    void getSubsets(vector&lt;int&gt; &amp;S, int pos, vector&lt;int&gt; &amp;out, vector&lt;vector&lt;int&gt;&gt; &amp;res) {
        res.push_back(out);
        for (int i = pos; i &lt; S.size(); ++i) {
            if (i &gt; pos &amp;&amp; S[i] == S[i-1]) continue;
            out.push_back(S[i]);
            getSubsets(S, i + 1, out, res);
            out.pop_back();
        }
    }
};
</code></pre>

<ul>
<li>leet_401</li>
</ul>

<pre class="line-numbers"><code class="language-text">Input: n = 1
Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]

class Solution {
  public:
  vector&lt;string&gt; res;

  void helper(vector&lt;int&gt;&amp; chart,int&amp;num,int curr,int idx,int hour,int min){
    if(hour&gt;11||min&gt;59) return;
    if(curr==num){
      string tmp=to_string(hour)+&quot;:&quot;+((min&lt;10)?&quot;0&quot;:&quot;&quot;)+to_string(min);
      res.push_back(tmp);
      return;
    }
    for(int i=idx;i&lt;chart.size();i++){
      if(i&lt;4)
        helper(chart,num,curr+1,i+1,hour+chart[i],min);
      else
        helper(chart,num,curr+1,i+1,hour,min+chart[i]);
    }
  }

  vector&lt;string&gt; readBinaryWatch(int num) {
    vector&lt;int&gt; chart({1,2,4,8,1,2,4,8,16,32});
    helper(chart,num,0,0,0,0);
    return res;
  }

};
</code></pre>

<h4>二维平面</h4>

<ul>
<li>leet_79 </li>
</ul>

<pre class="line-numbers"><code class="language-text">or example,
Given board =
[
  [&quot;ABCE&quot;],
  [&quot;SFCS&quot;],
  [&quot;ADEE&quot;]
]
word = &quot;ABCCED&quot;, -&gt; returns true,
word = &quot;SEE&quot;, -&gt; returns true,
word = &quot;ABCB&quot;, -&gt; returns false.
class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        if (board.empty() || board[0].empty()) return false;
        int m = board.size(), n = board[0].size();
        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n));
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (search(board, word, 0, i, j, visited)) return true;
            }
        }
        return false;
    }
    bool search(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int idx, int i, int j, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) {
        if (idx == word.size()) return true;
        int m = board.size(), n = board[0].size();
        if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n || visited[i][j] || board[i][j] != word[idx]) return false;
        visited[i][j] = true;
        bool res = search(board, word, idx + 1, i - 1, j, visited) 
                 || search(board, word, idx + 1, i + 1, j, visited)
                 || search(board, word, idx + 1, i, j - 1, visited)
                 || search(board, word, idx + 1, i, j + 1, visited);
        visited[i][j] = false;
        return res;
    }
};
</code></pre>

<ul>
<li>leet_200</li>
</ul>

<pre class="line-numbers"><code class="language-text">class Solution {
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        if (grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size(), res = 0;
        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n));
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == &#39;1&#39; &amp;&amp; !visited[i][j]) 
                helper(grid, visited, i, j);
                ++res;
            }
        }
        return res;
    }
    void helper(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) {
        if (x &lt; 0 || x &gt;= grid.size() || y &lt; 0 || y &gt;= grid[0].size() || grid[x][y] == &#39;0&#39; || visited[x][y]) return;
        visited[x][y] = true;
        helper(grid, visited, x - 1, y);
        helper(grid, visited, x + 1, y);
        helper(grid, visited, x, y - 1);
        helper(grid, visited, x, y + 1);
    }
};
</code></pre>

<ul>
<li>leet_130</li>
</ul>

<pre class="line-numbers"><code class="language-text">Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X

class Solution {
public:
    void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) {
        for (int i = 0; i &lt; board.size(); ++i) {
            for (int j = 0; j &lt; board[i].size(); ++j) {
                if ((i == 0 || i == board.size() - 1 || j == 0 || j == board[i].size() - 1) &amp;&amp; board[i][j] == &#39;O&#39;)
                    solveDFS(board, i, j);
            }
        }
        for (int i = 0; i &lt; board.size(); ++i) {
            for (int j = 0; j &lt; board[i].size(); ++j) {
                if (board[i][j] == &#39;O&#39;) board[i][j] = &#39;X&#39;;
                if (board[i][j] == &#39;$&#39;) board[i][j] = &#39;O&#39;;
            }
        }
    }
    void solveDFS(vector&lt;vector&lt;char&gt; &gt; &amp;board, int i, int j) {
        if (board[i][j] == &#39;O&#39;) {
            board[i][j] = &#39;$&#39;;
            if (i &gt; 0 &amp;&amp; board[i - 1][j] == &#39;O&#39;) 
                solveDFS(board, i - 1, j);
            if (j &lt; board[i].size() - 1 &amp;&amp; board[i][j + 1] == &#39;O&#39;) 
                solveDFS(board, i, j + 1);
            if (i &lt; board.size() - 1 &amp;&amp; board[i + 1][j] == &#39;O&#39;) 
                solveDFS(board, i + 1, j);
            if (j &gt; 0 &amp;&amp; board[i][j - 1] == &#39;O&#39;) 
                solveDFS(board, i, j - 1);
        }
    }
};
</code></pre>

<ul>
<li>leet_417</li>
</ul>

<pre class="line-numbers"><code class="language-text">Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic
class Solution {
public:
    vector&lt;pair&lt;int, int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        if (matrix.empty() || matrix[0].empty()) return {};
        vector&lt;pair&lt;int, int&gt;&gt; res;
        int m = matrix.size(), n = matrix[0].size();
        vector&lt;vector&lt;bool&gt;&gt; pacific(m, vector&lt;bool&gt;(n, false));
        vector&lt;vector&lt;bool&gt;&gt; atlantic(m, vector&lt;bool&gt;(n, false));
        for (int i = 0; i &lt; m; ++i) {
            dfs(matrix, pacific, INT_MIN, i, 0);
            dfs(matrix, atlantic, INT_MIN, i, n - 1);
        }
        for (int i = 0; i &lt; n; ++i) {
            dfs(matrix, pacific, INT_MIN, 0, i);
            dfs(matrix, atlantic, INT_MIN, m - 1, i);
        }
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (pacific[i][j] &amp;&amp; atlantic[i][j]) {
                    res.push_back({i, j});
                }
            }
        }
        return res;
    }
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int pre, int i, int j) {
        int m = matrix.size(), n = matrix[0].size();
        if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || visited[i][j] || matrix[i][j] &lt; pre) return;
        visited[i][j] = true;
        dfs(matrix, visited, matrix[i][j], i + 1, j);
        dfs(matrix, visited, matrix[i][j], i - 1, j);
        dfs(matrix, visited, matrix[i][j], i, j + 1);
        dfs(matrix, visited, matrix[i][j], i, j - 1);
    }
};
</code></pre>

<h4>回溯</h4>

<ul>
<li>是人工智能的基础</li>
<li>leet_51
<img src="media/15671314584110/15700743532592.jpg" alt="" style="width:1021px;"/>
<img src="media/15671314584110/15700743705081.jpg" alt="" style="width:1115px;"/></li>
</ul>

<pre class="line-numbers"><code class="language-text">class Solution {
  public:
  vector&lt;vector&lt;string&gt;&gt; res;
  vector&lt;bool&gt; col, dia1, dia2;

  vector&lt;string&gt; generateBoard(int n, vector&lt;int&gt;&amp; row) {
    assert(row.size() == n);
    vector&lt;string&gt; board(n, string(n, &#39;.&#39;));
    for (int i = 0; i &lt; n; i++)
      board[i][row[i]] = &#39;Q&#39;;
    return board;
  }
  
  void putQueen(int n, int index, vector&lt;int&gt;&amp; row) {

    if (index == n) {
      res.push_back(generateBoard(n, row));
      return;
    }

    for (int i = 0; i &lt; n; i++)
      if (!col[i] &amp;&amp; !dia1[index+i] &amp;&amp; !dia2[index-i+n-1]) {
        row.push_back(i);
        col[i] = dia1[index+i] = dia2[index-i+n-1] = true;
        putQueen(n, index + 1, row);
        col[i] = dia1[index+i] = dia2[index-i+n-1] = false;
        row.pop_back();
      }
  }

  vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
    res.clear();

    col = vector&lt;bool&gt;(n, false);
    dia1 = vector&lt;bool&gt;(2 * n - 1, false);
    dia2 = vector&lt;bool&gt;(2 * n - 1, false);
    vector&lt;int&gt; row;
    putQueen(n, 0, row);
    return res;
  }
};
</code></pre>

<ul>
<li>leet_52</li>
</ul>

<pre class="line-numbers"><code class="language-text">class Solution {
  public:
  vector&lt;bool&gt; col, dia1, dia2;
  
  int count = 0;
  //n皇后摆放在index行的皇后位置
  void putQueen(int n, int index, vector&lt;int&gt;&amp; row) {

    if (index == n) {
      count ++;
      return;
    }

    for (int i = 0; i &lt; n; i++)
      if (!col[i] &amp;&amp; !dia1[index+i] &amp;&amp; !dia2[index-i+n-1]) {
        row.push_back(i);
        col[i] = dia1[index+i] = dia2[index-i+n-1] = true;
        putQueen(n, index + 1, row);
        col[i] = dia1[index+i] = dia2[index-i+n-1] = false;
        row.pop_back();
      }
  }

  int totalNQueens(int n) {
    col = vector&lt;bool&gt;(n, false);
    dia1 = vector&lt;bool&gt;(2 * n - 1, false);
    dia2 = vector&lt;bool&gt;(2 * n - 1, false);
    vector&lt;int&gt; row;
    putQueen(n, 0, row);
    return count;
  }
};
</code></pre>

<ul>
<li>leet_37</li>
</ul>

<pre class="line-numbers"><code class="language-text">class Solution {
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        helper(board, 0, 0);
    }
    bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j) {
        if (i == 9) return true;
        if (j &gt;= 9) return helper(board, i + 1, 0);
        if (board[i][j] != &#39;.&#39;) return helper(board, i, j + 1);
        for (char c = &#39;1&#39;; c &lt;= &#39;9&#39;; ++c) {
            if (!isValid(board, i , j, c)) continue;
            board[i][j] = c;
            if (helper(board, i, j + 1)) return true;
            board[i][j] = &#39;.&#39;;
        }
        return false;
    }
    bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, char val) {
        for (int x = 0; x &lt; 9; ++x) {
            if (board[x][j] == val) return false;
        }
        for (int y = 0; y &lt; 9; ++y) {
            if (board[i][y] == val) return false;
        }
        int row = i - i % 3, col = j - j % 3;
        for (int x = 0; x &lt; 3; ++x) {
            for (int y = 0; y &lt; 3; ++y) {
                if (board[x + row][y + col] == val) return false;
            }
        }
        return true;
    }
};
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/30 10:17 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15700585529718.html">
                
                  <h1>Redis 集群</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>一致性保证</h4>

<ul>
<li>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作 完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权 衡。 注意:Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况 是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</li>
</ul>

<h4>分片重哈希</h4>

<ul>
<li>添加一个新的主节点</li>
</ul>

<pre class="line-numbers"><code class="language-text">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000
</code></pre>

<ul>
<li>添加一个新的从节点</li>
</ul>

<pre class="line-numbers"><code class="language-text">./redis-trib.rb add-node --slave 127.0.0.1:7006 127.0.0.1:7000
</code></pre>

<ul>
<li>移除一个节点</li>
</ul>

<pre class="line-numbers"><code class="language-text">./redis-trib.rb del-node 127.0.0.1:7000 &lt;node-id&gt; 
</code></pre>

<p>第一个参数是任意一个节点的地址,第二个节点是你想要移 除的节点地址。</p>

<h4>集群问题</h4>

<p><img src="media/15700585529718/15700600532398.jpg" alt="" style="width:1192px;"/></p>

<h4>分片问题</h4>

<ul>
<li>水平切分于垂直切分相比，相对来说稍微复杂一些。因为要将同一个表中的不同数据拆分到不同的数据 库中。 分片是一种基于数据库分成若干片段的传统概念扩容技术，它将数据库分割成多个碎片并将这 些碎片放置在不同的服务器上。</li>
<li>垂直切分的最大特点就是规则简单，实施也更为方便，尤其适合各业务之间的耦合度非常低，相互影响很小，业务逻辑非常清晰的系统。按照业务维度将不同数据放入不同的表</li>
</ul>

<h4>一致性hash算法</h4>

<p><img src="media/15700585529718/15700606333480.jpg" alt="" style="width:1150px;"/></p>

<ul>
<li>hash环上顺时针从整数0开始，一直到最大正整数，我们根据四个ip计算的hash值肯定会落到这个hash 环上的某一个点，至此我们把服务器的四个ip映射到了一致性hash环</li>
<li> 当用户在客户端进行请求时候，首先根据hash(用户id)计算路由规则(hash值)，然后看hash值落到了 hash环的那个地方，根据hash值在hash环上的位置顺时针找距离最近的ip作为路由ip</li>
</ul>

<h4>一致性HASH算法虚拟节点</h4>

<ul>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/03 07:22 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html'>Redis高并发缓存</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15599783184679.html">
                
                  <h1>基准测试和性能测试</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>基准测试的目的</h4>

<ul>
<li>建立mysql服务器的性能基准线</li>
<li>模拟比当前系统更高的负载，找出系统的扩展瓶劲</li>
<li>测试不同硬件，软件和操作系统</li>
<li>证明新的硬件设备是否配置正确</li>
</ul>

<h4>基准测试常见指标</h4>

<ul>
<li>TPS</li>
<li>QPS</li>
<li>响应时间
<ul>
<li>平均响应时间，最小响应时间，最大响应时间，各时间响应百分比</li>
</ul></li>
<li>并发量</li>
<li>正在工作中的并发的操作数或同事工作的数量</li>
</ul>

<h4>计划和设计基准测试</h4>

<ul>
<li>整个系统还是单一组件</li>
<li>使用什么样的数据</li>
</ul>

<h4>基准测试的步骤</h4>

<ul>
<li>准备基准测试数据和收集脚本</li>
<li>运行基准测试</li>
<li>保存以及分析基准测试结果</li>
</ul>

<h4>基准测试的问题</h4>

<ul>
<li>使用生产环境数据，只使用了部分数据</li>
<li>多用户场景，只做单用户测试</li>
<li>单服务器上测试分布式应用</li>
<li>反复执行同一个查询，容易命中缓存，无法反应真实的查询性能</li>
</ul>

<h4>mysqlslap</h4>

<ul>
<li>可以模拟服务器负载，并输出相关统计信息可以指定也可以自动生成查询语句</li>
<li>常用参数说明</li>
</ul>

<pre class="line-numbers"><code class="language-mysql">--auto-generate-sql由系统自动生成SQL脚本进行测试
--auto-generate-sql-add-autoincrement在牛成的表中增加自增ID
--auto-generate sql-load-type指定测试中使用的询类型
--auto-generate sql-write number指定初始化数据时生成的数据量
--concurrency指定并发线程的数量
--engine 指定要测试表的存储引擎，可以用逗号分割多个存储引擎
--no-drop 指定不清理测试数据
--iterations 指定测试运行的次数
--number-of-queries 指定每一个线程执行的查询数量
--debug-info 指定输出额外的内存和CPU统计信息
--number-int-cols 指定测试表中包含INT类型列的数量
--number-char-cols 指定测试表中包含的varchar 类型的数量
--create-schema 指定了用于执行测试的数据库的名字
--query 用于指定自定义 SQL 的脚本
--only-print 并不运行测试脚本，而是把生成的脚本打
</code></pre>

<h4>测试案例</h4>

<pre class="line-numbers"><code class="language-text">mysqlslap --concurrency=1,50,100,200 --iterations=3 --number-int-cols=5 --number-char-cols=5 --auto-generate-sql --auto-generate-sql-add-autoincrement --engine=myisam,innodb --number-of-queries=10 --create-schema=sbtest -uroot -pL19880901c-
</code></pre>

<h4>sysbench</h4>

<h5>常用参数</h5>

<ul>
<li>test 用于指定所要执行的测试类型，支持以下参数 Fileid 文件系统 O 性能測试 cpu cpu&#39;性能试 memory 内存性能观试 oltp 测试要指定具体的 lua 脚本</li>
</ul>

<pre class="line-numbers"><code class="language-sql">mysqa-db 用于指定执行基准测试的数据库名
mysql-table-engine 用于指定所使用的存储引擎
oltp-tables-count 执行测试的表的数量
oltp-table-size 指定每个表中的数据行数
num-threads 指定测试的并发线程数量
max-time 指定最大的测试时间
report- -interval指定间隔多长时间输出一次统计信息
mysq-user 指定执行测试的 MYSQL 用户
-mysqlpassword 指定执行测试的 MYSQL 用户的密码
prepare 用于准备测试数据
run 用于实际进行测试
cleanup 用于清理测试数据
</code></pre>

<h4>测试案例</h4>

<pre class="line-numbers"><code class="language-text">sysbench --test=cpu --cpu-max-prime=10000 run
sysbench --test-fileio --num-thread=8 --init-rng=on --file-total-size=5G \
--file-test-mode=rndrw --report-interval=1s
</code></pre>

<h5>mysql性能测试</h5>

<pre class="line-numbers"><code class="language-text">sysbench ./oltp.lua --mysql-host=192.168.31.186 --mysql-port=3306 --mysql-user=root --mysql-password=&quot;L19880901c-&quot; --mysq1-table-engine=innodb --oltp-tables-count=10 --oltp-table-size=100000 --threads=10 --time=120 --report-interval=10 prepare
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/06/08 15:18 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15677236146527.html">
                
                  <h1>Sentinel</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>主从复制高可用</h4>

<ul>
<li>手动故障转移</li>
<li>写能力和存储能力受限制</li>
</ul>

<h4>主要任务</h4>

<ul>
<li>监控(Monitoring): Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。<br/></li>
<li>提醒(Notification): 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或 者其他应用程序发送通知。</li>
<li>自动故障迁移(Automatic failover): 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故 障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其 他从服务器改为复制新的主服务器; 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新 主服务器的地址， 使得集群可以使用新主服务器代替失效服务器</li>
</ul>

<h4>基本架构</h4>

<ul>
<li><img src="media/15677236146527/15677238406646.jpg" alt="" style="width:1048px;"/></li>
<li><img src="media/15677236146527/15677240210056.jpg" alt="" style="width:1267px;"/></li>
</ul>

<h4>sentinel配置</h4>

<ul>
<li><img src="media/15677236146527/15677245915239.jpg" alt="" style="width:1044px;"/></li>
<li>sentinel monitor mymaster 127.0.0.1 6379 1 名称为mymaster的主节点名，1表示将这个主服务器判断 为失效至少需要 1个 Sentinel 同意 (只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行)</li>
<li>down-after-milliseconds 选项指定了 Sentinel 认为服务器已经断线所需的毫秒数</li>
<li>failover过期时间，当failover开始后，在此时间内仍然没有触发任何failover操作，当前sentinel 将会认 为此次failoer失败</li>
<li>parallel-syncs 选项指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同 步， 这个数字越小， 完成故障转移所需的时间就越长。 如果从服务器被设置为允许使用过期数据集， 那么你可能不希望所有从服务器都在同一时间向新的主 服务器发送同步请求， 因为尽管复制过程的绝大部分步骤都不会阻塞从服务器， 但从服务器在载入主 服务器发来的 RDB 文件时， 仍然会造成从服务器在一段时间内不能处理命令请求: 如果全部从服务 器一起对新的主服务器进行同步， 那么就可能会造成所有从服务器在短时间内全部不可用的情况出 现。</li>
</ul>

<h4>客户端</h4>

<ul>
<li>连接sentinel</li>
<li><img src="media/15677236146527/15677260391092.jpg" alt="" style="width:911px;"/></li>
<li><img src="media/15677236146527/15677260637461.jpg" alt="" style="width:844px;"/></li>
</ul>

<h4>三个定时任务</h4>

<ul>
<li>每10秒每个sentinel对master和slave指向info</li>
<li>发现slave节点</li>
<li>确定主从关系</li>
<li><img src="media/15677236146527/15678968542743.jpg" alt="" style="width:733px;"/></li>
<li>每2秒每个sentinel通过master的channel频道交互信息(pub/sub)</li>
<li><strong>sentinel</strong>:hello</li>
<li>交互对节点的看法和自身信息</li>
<li><img src="media/15677236146527/15678970065504.jpg" alt="" style="width:683px;"/></li>
<li>每1s每个sentinel对其他sentinel进行ping访问</li>
<li>心跳检测，失败判定依据</li>
<li><img src="media/15677236146527/15678973156445.jpg" alt="" style="width:613px;"/></li>
</ul>

<h4>主观下线和客观下线</h4>

<ul>
<li>sentinel monitor mymaster 192.168.31.191 6379 2主观下限法定人数</li>
<li>sentinel down-after-milliseconds mymaster 30000 主观超时下线判断</li>
<li>主观下线：每个 sentinel 节点对 Redis 节点失败的“偏见</li>
<li>客观下线：所有 sentinel 节点对 Redis 节点失败“达成共识“（超过 quorum 个统一）</li>
<li>sentinel is-master-down-by-addr</li>
</ul>

<h4>领导者选举</h4>

<ul>
<li>原因：只有一个 sentinel 节点完成故障转移</li>
<li>选举：通过 sentinel is- master-down-by-addr 命令都希望成为领导者</li>
<li>每个做主观下线的 Sentinel 节点向其他 Sentinel 节点发送命令，要求将它设置为领导者收到命令的 Sentinel 节点如果没有同意通过其他 Sentinel 节点发送的命令，那么将同意该请求，否则拒绝</li>
<li>如果该 Sentinel 节点发现自己的票数已经超过 Sentinel 集合半数且超过 quorum，那么它将成为领导者</li>
<li>如果此过程有多个 Sentinel 节点成为了领导者，那么将等待一段时间重新进行选举。</li>
<li><img src="media/15677236146527/15678976923488.jpg" alt="" style="width:539px;"/></li>
</ul>

<h4>故障转移</h4>

<ul>
<li>从 slave 节点中选出一个“合适的”节点作为新的 master 节点 </li>
<li>对上面的 slave 节点执行 slaveof no oner 命令让其成为 master 节点。</li>
<li>向剩余的 Slave 节点发送命令，让它们成为新 master 节点的 slave 节点，复制规则和 parallel- syncs 参数有关。</li>
<li>更新对原来 master-节点配置为 slave，并保持着对其“关注“，当其恢复后命令它去复制新的 master 节点</li>
</ul>

<h4>选择合适的slave节点</h4>

<ul>
<li>选择 slave- priority (slave 节点优先级）最高的』ave 节点，如果存在则返回，不存在则继续。</li>
<li>选择复制偏移量最大的 slave 节点（复制的最完整），如果存在则返回，不存在则继续</li>
<li>选择 runed 最小的 slave 节点。</li>
</ul>

<h4>节点运维</h4>

<ul>
<li>主节点 </li>
<li>从节点</li>
<li>sentinel节点</li>
</ul>

<h4>手动故障转移</h4>

<ul>
<li><img src="media/15677236146527/15678979994184.jpg" alt="" style="width:1165px;"/></li>
</ul>

<h4>节点上线</h4>

<ul>
<li>主节点：sentinel failover 进行替换。</li>
<li>从节点：slaveofe 即可，sentinel 节点可以感知。</li>
<li>sentinel 节点：参考其他 sentinel 节点启动即可。</li>
</ul>

<h4>从节点的作用</h4>

<ul>
<li>副本 高可用的基础</li>
<li>扩展 读能力</li>
</ul>

<h4>三个消息</h4>

<ul>
<li>+ switch- master：切换主节点（从节点晋升主节点</li>
<li>+ convert-to- slave：切换从节点（原主节点降为从节点）</li>
<li>+ sdown：主观下线。</li>
</ul>

<h4>高可用读写分离</h4>

<ul>
<li><img src="media/15677236146527/15678982480394.jpg" alt="" style="width:951px;"/></li>
</ul>

<h4>总结</h4>

<ul>
<li>故障发现、故障自动转移、配置中心、客户端通知。</li>
<li>Redis Sentinel 中的 Sentinel=节点个数应该为大于等于 3 且最好为奇数。</li>
<li>Redis Sentinel 中的数据节点与普通数据节点没有区别</li>
<li>客户端初始化时连接的是 Sentinel 节点集合，不再是具体的 Redis 节点，但 Sentinel 只是配置中心不是代理</li>
<li>Redis Sentinel 通过三个定时任务实现了 Sentinel 节点对于主节点、从节点其余 Sentinel 节点的监控。</li>
<li>Redis Sentinel 在对节点做失败判定时分为主观下线和客观下线。</li>
<li>看懂 Redis Sentine 故障转移日志对于 Redis Sentinel 以及问题排查非常有帮助</li>
<li>Redis Sentinels 实现读写分离高可用可以依赖 Sentinel 节点的消息通知，获取 Redis 数据节点的状态变化</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/09/06 06:46 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html'>Redis从入门到精通</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_19.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_21.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>eredin-blog</h1>
                <div class="site-des">生命的意义是成为你自己！</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html"><strong>C++基础与提高</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Golang.html"><strong>Golang</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html"><strong>设计模式之美</strong></a>
        
            <a href="%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE.html"><strong>性能工程高手课</strong></a>
        
            <a href="%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html"><strong>性能测试</strong></a>
        
            <a href="Prometheus.html"><strong>Prometheus</strong></a>
        
            <a href="RocketMQ.html"><strong>RocketMQ</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html"><strong>网络协议</strong></a>
        
            <a href="Django.html"><strong>Django</strong></a>
        
            <a href="%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes.html"><strong>深入剖析Kubernetes</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html"><strong>数据结构和算法</strong></a>
        
            <a href="%E5%BE%AE%E6%9C%8D%E5%8A%A1.html"><strong>微服务</strong></a>
        
            <a href="%E6%9E%B6%E6%9E%84.html"><strong>架构</strong></a>
        
            <a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html"><strong>操作系统原理</strong></a>
        
            <a href="Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Mysql优化实战</strong></a>
        
            <a href="Kafka.html"><strong>Kafka</strong></a>
        
            <a href="linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html"><strong>linux服务器研发</strong></a>
        
            <a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html"><strong>计算机组成原理</strong></a>
        
            <a href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html"><strong>程序员的自我修养</strong></a>
        
            <a href="C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6.html"><strong>C语言进阶</strong></a>
        
            <a href="http_study.html"><strong>http_study</strong></a>
        
            <a href="%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html"><strong>玩转算法</strong></a>
        
            <a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html"><strong>C++对象模型</strong></a>
        
            <a href="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html"><strong>SQL必知必会</strong></a>
        
            <a href="Zookeeper.html"><strong>Zookeeper</strong></a>
        
            <a href="Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html"><strong>Redis从入门到精通</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6.html"><strong>数据结构和算法进阶</strong></a>
        
            <a href="Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html"><strong>Mysql性能管理和架构设计</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html"><strong>网络编程实战</strong></a>
        
            <a href="Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html"><strong>Redis高并发缓存</strong></a>
        
            <a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Linux性能优化实战</strong></a>
        
            <a href="%E5%80%99%E6%8D%B7STL.html"><strong>候捷STL</strong></a>
        
            <a href="ElasticSearch.html"><strong>ElasticSearch</strong></a>
        
            <a href="RabbitMQ.html"><strong>RabbitMQ</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15818128782116.html">Singleton</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15748977610569.html">State</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15817697569868.html">字符串分割</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15817610843879.html">编译期</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813101435484.html">列表&字典&集合进阶用法</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
