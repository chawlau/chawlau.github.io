<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	       凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2020-12-25T09:02:47+08:00" itemprop="datePublished">2020/12/25 09:02 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16088581674368.html" itemprop="url">
		哨兵集群</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E9%9B%86%E7%BE%A4%E7%BB%84%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>集群组成</h4>
<ul>
<li>pub/sub 机制</li>
<li>主库上有一个名为“<strong>sentinel</strong>:hello”的频道，不同哨兵就是通过它来相互发现，实现互相通信的</li>
</ul>
<h4><a id="%E5%8F%91%E7%8E%B0%E4%BB%8E%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发现从库</h4>
<ul>
<li>INFO命令获取从库</li>
<li>info replication</li>
</ul>
<h4><a id="%E8%AE%A2%E9%98%85%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>订阅事件</h4>
<pre><code class="language-plain_text">SUBSCRIBE +odown  所有实例进入客观下线状态的事件
</code></pre>
<p><img src="media/16088581674368/16088593535242.jpg" alt="" /></p>
<ul>
<li>客户端订阅事件，通过pubsub得知主从切换</li>
</ul>
<h4><a id="%E5%81%87%E8%AE%BE%E6%9C%89%E4%B8%80%E4%B8%AAredis%E9%9B%86%E7%BE%A4%EF%BC%8C%E6%98%AF%E2%80%9C%E4%B8%80%E4%B8%BB%E5%9B%9B%E4%BB%8E%E2%80%9D%EF%BC%8C%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AE%E4%BA%86%E5%8C%85%E5%90%AB-5%E4%B8%AA%E5%93%A8%E5%85%B5%E5%AE%9E%E4%BE%8B%E7%9A%84%E9%9B%86%E7%BE%A4%EF%BC%8C-quorum%E5%80%BC%E8%AE%BE%E4%B8%BA-2%E3%80%82%E5%9C%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89-3%E4%B8%AA%E5%93%A8%E5%85%B5%E5%AE%9E%E4%BE%8B%E9%83%BD%E5%8F%91%E7%94%9F%E6%95%85%E9%9A%9C%E4%BA%86%EF%BC%8C%E6%AD%A4%E6%97%B6%EF%BC%8C-redis%E4%B8%BB%E5%BA%93%E5%A6%82%E6%9E%9C%E6%9C%89%E6%95%85%E9%9A%9C%EF%BC%8C%E8%BF%98%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%9C%B0%E5%88%A4%E6%96%AD%E4%B8%BB%E5%BA%93%E2%80%9C%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF%E2%80%9D%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%BF%98%E8%83%BD%E8%BF%9B%E8%A1%8C%E4%B8%BB%E4%BB%8E%E5%BA%93%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E5%90%97%EF%BC%9F%E6%AD%A4%E5%A4%96%EF%BC%8C%E5%93%A8%E5%85%B5%E5%AE%9E%E4%BE%8B%E6%98%AF%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E5%91%A2%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B6%E8%B0%83%E5%A4%A7-down-after-milliseconds%E5%80%BC%EF%BC%8C%E5%AF%B9%E5%87%8F%E5%B0%91%E8%AF%AF%E5%88%A4%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B9%9F%E6%9C%89%E5%A5%BD%E5%A4%84%E5%91%A2%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>假设有一个 Redis 集群，是“一主四从”，同时配置了包含 5 个哨兵实例的集群，quorum 值设为 2。在运行过程中，如果有 3 个哨兵实例都发生故障了，此时，Redis 主库如果有故障，还能正确地判断主库“客观下线”吗？如果可以的话，还能进行主从库自动切换吗？此外，哨兵实例是不是越多越好呢，如果同时调大 down-after-milliseconds 值，对减少误判是不是也有好处呢？</h4>
<ul>
<li>quorum=2可以判断客观下线</li>
<li>不能选出leader，所以不能进行主从切换</li>
<li>交换信息，哨兵实例越多，通信的次数也就越多，而且部署多个哨兵时，会分布在不同机器上，节点越多带来的机器故障风险也会越大，这些问题都会影响到哨兵的通信和选举，出问题时也就意味着选举时间会变长，切换主从的时间变久</li>
<li>是有好处的，适当调大down-after-milliseconds值，当哨兵与主库之间网络存在短时波动时，可以降低误判的概率。</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2020-12-31T09:01:45+08:00" itemprop="datePublished">2020/12/31 09:01 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16093765058382.html" itemprop="url">
		切片多了</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h5><a id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%AE%BF%E9%97%AE%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E6%97%B6%EF%BC%8C%E9%83%BD%E8%83%BD%E8%8E%B7%E5%BE%97%E6%89%80%E6%9C%89%E7%9A%84%E5%93%88%E5%B8%8C%E6%A7%BD%E4%BF%A1%E6%81%AF%E5%91%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢</h5>
<ul>
<li>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了</li>
</ul>
<h4><a id="ask%E5%92%8Cmoved" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ASK和MOVED</h4>
<ul>
<li>ASK 命令表示两层含义：第一，表明 Slot 数据还在迁移中；第二，ASK 命令把客户端所请求数据的最新实例地址返回给客户端，此时，客户端需要给实例 3 发送 ASKING 命令，然后再发送操作命令</li>
<li>MOVED 会更改本地缓存，让后续所有命令都发往新实例</li>
<li>ASK 命令并不会更新客户端缓存的哈希槽分配信息</li>
</ul>
<h4><a id="%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题</h4>
<p>Redis Cluster 方案通过哈希槽的方式把键值对分配到不同的实例上，这个过程需要对键值对的 key 做 CRC 计算，然后再和哈希槽做映射，这样做有什么好处吗？<br />
1.让key在多个实例上分布更均匀<br />
2.需要rehash的时候，还要去修改这个对应关系表，代价有点大<br />
3.存在表里，key的数量太大，表的维护是个问题</p>
<h4><a id="replication-buffer%E5%92%8C-repl-backlog-buffer%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>replication buffer 和 repl_backlog_buffer 的区别</h4>
<ul>
<li>replication buffer 是主从库在进行全量复制时，主库上用于和从库连接的客户端的 buffer，而 repl_backlog_buffer 是为了支持从库增量复制，主库上用于持续保存写操作的一块专用 buffer</li>
<li>从库slave_repl_offset 主库master_repl_offset</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2021-01-03T10:35:56+08:00" itemprop="datePublished">2021/01/03 10:35 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16096413568310.html" itemprop="url">
		string</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="redis-object" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Redis Object</h4>
<ul>
<li><img src="media/16096413568310/16096416111832.jpg" alt="" /></li>
</ul>
<h5><a id="string%E7%9A%84redis-object" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>string的redis object</h5>
<ul>
<li>一方面，当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了</li>
<li>另一方面，当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 embstr 编码方式</li>
<li>当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构</li>
</ul>
<h4><a id="%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全局哈希表</h4>
<ul>
<li>Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对。dictEntry 结构中有三个 8 字节的指针，分别指向 key、value 以及下一个 dictEntry</li>
</ul>
<h4><a id="%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>压缩列表</h4>
<ul>
<li>表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 zlend，表示列表结束</li>
<li>entry 由pre_len,len,data</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-07-23T10:45:42+08:00" itemprop="datePublished">2019/07/23 10:45 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15638499426579.html" itemprop="url">
		数组问题</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li>排序: 选择排序 插入排序 归并排序 快速排序</li>
</ul>
<h4><a id="%E9%A2%98%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>题目</h4>
<ul>
<li>leetcode 283</li>
</ul>
<pre><code class="language-C++">Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].

Note:

You must do this in-place without making a copy of the array.
Minimize the total number of operations.
class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        for (int i = 0, j = 0; i &lt; nums.size(); ++i) {
            if (nums[i]) {
                swap(nums[i], nums[j++]);
            }
        }
    }
};
</code></pre>
<ul>
<li>k [0,k) 保存所有遍历过的非0元素</li>
</ul>
<h4><a id="code" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>code</h4>
<ul>
<li>给定一个数组nums和一个数组val，将数组中所有等于val的元素删除，返回剩余的元素个数</li>
<li>leetcode26</li>
</ul>
<pre><code class="language-C++">Given a sorted array  nums , remove the duplicates in-place such that each element appear only  once  and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given _nums_ = [1,1,2],

Your function should return length = 2, with the first two elements of _nums_ being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int j = 0, n = nums.size();
        for (int i = 0; i &lt; n; ++i) {
            if (nums[i] != nums[j]) nums[++j] = nums[i];
        }
        return nums.empty() ? 0 : (j + 1);
    }
};
</code></pre>
<ul>
<li>leetcode27</li>
</ul>
<pre><code class="language-C++">Given an array  nums  and a value  val , remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example 1:

Given _nums_ = [3,2,2,3], _val_ = 3,

Your function should return length = 2, with the first two elements of _nums_ being 2.

It doesn't matter what you leave beyond the returned length.
class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int res = 0;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (nums[i] != val) nums[res++] = nums[i];
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leetcode80</li>
</ul>
<pre><code class="language-C++">Given a sorted array  nums , remove the duplicates in-place such that duplicates appeared at most  twice  and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given _nums_ = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of _nums_ being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.
class Solution {
public:
   int removeDuplicates(vector&lt;int&gt;&amp; nums) {
    int slow = 0, fast = 1, count = 0;

    for (; fast &lt; nums.size(); fast++) {
        if (nums[fast] == nums[slow]) count++;
        else count = 0;

        if (count &lt; 2) {
            nums[++slow] = nums[fast];
        }
    }
    return slow + 1;
 }
};
class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int i = 0;
        for (int num : nums) {
            if (i &lt; 2 || num &gt; nums[i - 2]) {
                nums[i++] = num;
            }
        }
        return i;
    }
};
</code></pre>
<h4><a id="sort-colors" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sort Colors</h4>
<ul>
<li>leet_code75</li>
</ul>
<pre><code class="language-C++">Given an array with  n  objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note: You are not suppose to use the library's sort function for this problem.

Example:

Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        int red = 0, blue = (int)nums.size() - 1;
        for (int i = 0; i &lt;= blue; ++i) {
            if (nums[i] == 0) {
                swap(nums[i], nums[red++]);
            } else if (nums[i] == 2) {
                swap(nums[i--], nums[blue--]);
            } 
        }
    }
};
</code></pre>
<ul>
<li>leet_code88</li>
</ul>
<pre><code class="language-C++">Given two sorted integer arrays  nums1  and  nums2 , merge  nums2  into  nums1  as one sorted array.

Note:

The number of elements initialized in  nums1 and  nums2  are  m  and  n  respectively.
You may assume that  nums1  has enough space (size that is greater or equal to  m  +  n ) to hold additional elements from  nums2.
Example:

Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
            if (nums1[i] &gt; nums2[j]) nums1[k--] = nums1[i--];
            else nums1[k--] = nums2[j--];
        }
        while (j &gt;= 0) nums1[k--] = nums2[j--];
    }
};
</code></pre>
<ul>
<li>leet_code215</li>
</ul>
<pre><code class="language-C++">Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:

Input: [3,2,1,5,6,4] and k = 2
Output: 5
class Solution {
public:
  int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
    int left = 0, right = nums.size() - 1;
    k = nums.size() - k;
    while (left &lt;= right) {
      int pos = partition(nums, left, right);
      if (pos == k) return nums[pos];
      else if (pos &gt; k) right = pos - 1;
      else left = pos + 1;
    }
    return -1;
  }

  int partition(vector&lt;int&gt;&amp; nums, int left, int right) {
    int val = nums[left], j = left;
    for (int i = left + 1; i &lt;= right; i++) {
      if (nums[i] &lt; val)  swap(nums[++j], nums[i]);
    }
    swap(nums[j], nums[left]);
    return j;
  }
};
</code></pre>
<h4><a id="two-sum" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>two_sum</h4>
<ul>
<li>leet_125</li>
</ul>
<pre><code class="language-C++">Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,
&quot;A man, a plan, a canal: Panama&quot; is a palindrome.
&quot;race a car&quot; is not a palindrome
//判断大小写等价if ((s[left] + 32 - 'a') %32 != (s[right] + 32 - 'a') % 32)
class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0, right = s.size() - 1 ;
        while (left &lt; right) {
            if (!isAlphaNum(s[left])) ++left;
            else if (!isAlphaNum(s[right])) --right;
            else if ((s[left] + 32 - 'a') %32 != (s[right] + 32 - 'a') % 32) return false; 
            else {
                ++left; --right;
            }
        }
        return true;
    }
    bool isAlphaNum(char &amp;ch) {
        if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') return true;
        if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') return true;
        if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') return true;
        return false;
    }
};
</code></pre>
<ul>
<li>leet_344</li>
</ul>
<pre><code class="language-C++">字符串反转
class Solution {
public:
    void reverseString(vector&lt;char&gt;&amp; s) {
      int left = 0, right = s.size() - 1;
      while (left &lt; right) {
        swap(s[left++], s[right--]);
      }
    }
};
</code></pre>
<ul>
<li>leet_345</li>
</ul>
<pre><code class="language-C++">Write a function that takes a string as input and reverse only the vowels of a string.

Example 1:
Given s = &quot;hello&quot;, return &quot;holle&quot;.

Example 2:
Given s = &quot;leetcode&quot;, return &quot;leotcede&quot;.
class Solution {
public:
    string reverseVowels(string s) {
        int left = 0, right= s.size() - 1;
        while (left &lt; right) {
            if (isVowel(s[left]) &amp;&amp; isVowel(s[right])) {
                swap(s[left++], s[right--]);
            } else if (isVowel(s[left])) {
                --right;
            } else {
                ++left;
            }
        }
        return s;
    }
    bool isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
    }
};
</code></pre>
<ul>
<li>leet_11</li>
</ul>
<pre><code class="language-C++">Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
      int i = 0, j = height.size() - 1;
      int res = 0;
      while (i &lt; j) {
        res = max(res, min(height[i], height[j]) * (j - i));
        height[i] &lt; height[j] ? i++ : j--;
      }
      return res;
    }
};
</code></pre>
<h4><a id="%E5%8F%8C%E7%B4%A2%E5%BC%95%E6%8A%80%E6%9C%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双索引技术</h4>
<ul>
<li>滑动窗口</li>
<li>leet_209 暴力解法优化到O(n2) //TODO</li>
</ul>
<pre><code class="language-C++">Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.

Example: 

Input: s = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: the subarray [4,3] has the minimal length under the problem constraint.
class Solution {
  public:
  int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {
    int l = 0, r = -1, sum = 0;

    int  res = nums.size() + 1; //有可能是整个数组之和等于s

    while (l &lt; nums.size()) {
      if (r + 1 &lt; nums.size() &amp;&amp; sum &lt; s)
        sum += nums[++r];
      else
        sum -= nums[l++];

      if (sum &gt;= s)
        res = min(res, r -l +1);
    }

    if (res == nums.size() + 1)
      return 0;

    return res;
  }
};
</code></pre>
<ul>
<li>leet_3 字符集？ 只有字母?  字母 + 数字 ? ASCII 大小写是否敏感</li>
</ul>
<pre><code class="language-C++">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
输入: s = &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。

class Solution {
public:
    int lengthOfLongestSubstring(string s) 
    {
        int l = 0;
        int r = 0;
        int maxLength = 0;
        int usedChar[256] = { 0 };
        while (l &lt; s.size())
        {
            if (r &lt; s.size() &amp;&amp; usedChar[s[r]] == 0)
            {
                usedChar[s[r++]] += 1;
            }
            else
            {
                usedChar[s[l++]] -= 1;
            }
            maxLength = max(maxLength, r - l);
        }
        return maxLength;
    }
};
int main()
{
    string s = &quot;abcabcbb&quot;;
    cout &lt;&lt; Solution().lengthOfLongestSubstring(s) &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>leet_438 字符集范围 英文小写字母 返回的解的顺序</li>
</ul>
<pre><code class="language-C++">Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.

class Solution 
{
public:
    vector&lt;int&gt; findAnagrams(string s, string p) 
    {
        int count = p.size();
        int pChar[256] = { 0 };
        vector&lt;int&gt; result;
        for (auto&amp; i : p)
        {
            ++pChar[i];
        }
        for (int i = 0; i &lt; s.size(); ++i)
        {
            if (pChar[s[i]] &gt;= 1) --count;
            --pChar[s[i]];
            if (i &gt;= p.size())
            {
                if (pChar[s[i - p.size()]] &gt;= 0) ++count;
                ++pChar[s[i - p.size()]];
            }
            if (count == 0) result.push_back(i - p.size() + 1);
        }
        return result;
    }
};
int main()
{
    string s = &quot;cbaebabacd&quot;;
    string p = &quot;abc&quot;;
    for (auto&amp; i : Solution().findAnagrams(s, p))
    {
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2020-02-08T16:34:56+08:00" itemprop="datePublished">2020/02/08 16:34 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15811508963305.html" itemprop="url">
		constexpr</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用</h4>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;array&gt;

using namespace std;
constexpr int sqr(int n) {return n * n;}

int main() {
    constexpr int n = sqr(3);
    int b[n];

    constexpr string_view sv {&quot;vi&quot;};
    constexpr pair pr{sv[0], sv[1]};
    constexpr array a{pr.first, pr.second};
    constexpr int n1 = a[0];
    constexpr int n2 = a[1];
    cout &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<ul>
<li>如果一个类的构造函数里面只包含常量表达式、满足对 constexpr 函数的限制的话（这也意味着，里面不可以有任何动态内存分配），并且类的析构函数是平凡的，那这个类就可以被称为是一个字面类型。换一个角度想，对 constexpr 函数——包括字面类型构造函数——的要求是，得让编译器能在编译期进行计算，而不会产生任何“副作用”，比如内存分配、输入、输出等等</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-12T18:09:38+08:00" itemprop="datePublished">2019/09/12 18:09 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15682829786509.html" itemprop="url">
		线程启动 join detach</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程启动</h4>
<ul>
<li>thread是标准库的类</li>
<li>join 加入汇合 阻塞主线程，让主线程等待子线程执行完毕，主线程执行完，join完毕，主线程就执行</li>
</ul>
<h5><a id="detach" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>detach()</h5>
<ul>
<li>传统多线程主线程要等待子线程执行完毕，然后自己再退出</li>
<li>主线程不和子线程会和了，主线程和子线程分道扬镳</li>
<li>detach()之后，与主线程关联的thread对象就会失去与主线程的关联</li>
<li>子线程就会驻留在后台运行，子线程就会被c++运行时库接管</li>
<li>detach会导致线程失去控制，不能再join</li>
</ul>
<h4><a id="joinable%EF%BC%88%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>joinable（）</h4>
<ul>
<li>判断是否可以成join, detach</li>
</ul>
<h4><a id="%E5%85%B6%E4%BB%96%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他可调用对象</h4>
<ul>
<li>用类对象创建的线程，一旦主线程执行结束了，这个对象是被复制进新创建的线程中</li>
<li>执行完主线程后，ta会被销毁。但是所复制的对象依旧存在</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-24T18:27:45+08:00" itemprop="datePublished">2019/09/24 18:27 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15693208659724.html" itemprop="url">
		std::atomic</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="std-atomic" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>std::atomic</h4>
<ul>
<li>一般atomic原子操作，支持++,--,-=,+=其他的不支持</li>
</ul>
<h4><a id="std-async" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>std::async</h4>
<ul>
<li>async一般叫创建异步任务</li>
<li>async有时候并不创建线程</li>
<li>deferred延迟调用，并且不创建新线程，延迟到future对象调用get或者wait的时候才执行线程函数，如果没有调用get或者wait，那么mythread不会执行</li>
</ul>
<h5><a id="std-launch-async" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>std::launch::async</h5>
<pre><code class="language-plain_text">std::future&lt;int&gt; res = std::async(std::launch::async, mythread);
</code></pre>
<ul>
<li>强制异步任务在新线程上执行</li>
</ul>
<h5><a id="std-launch-async-std-launch-deferred" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>std::launch::async|std::launch::deferred</h5>
<pre><code class="language-plain_text">std::future&lt;int&gt; res = std::async(std::launch::async | std::launch::deferred, mythread);
</code></pre>
<ul>
<li>可能是创建新线程立即执行</li>
<li>也可能是没有创建新线程，并且延迟到res.get()才开始执行任务入口函数</li>
</ul>
<h5><a id="%E4%B8%8D%E5%B8%A6%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0%EF%BC%8C%E5%8F%AA%E7%BB%99async%E5%87%BD%E6%95%B0%E4%B8%80%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不带额外参数，只给async函数一入口函数名</h5>
<pre><code class="language-plain_text">std::future&lt;int&gt; res = std::async(std::launch::async | std::launch::deferred, mythread);
</code></pre>
<ul>
<li>默认值是std::launch::async|std::launch::deferred</li>
</ul>
<h5><a id="%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%87%AA%E8%A1%8C%E5%86%B3%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>系统如何自行决定</h5>
<ul>
<li>std::async和std::thread</li>
<li>std::thread创建线程，如果系统资源紧张，创建线程异常，整个程序就会报异常错误</li>
<li>std::async创建异步任务，可能创建，也可能不创建，容易拿到入口函数的返回值</li>
<li>async创建失败不会引起系统崩溃，可能执行在主线程上，不创建新的线程</li>
<li>如果一定要创建std::launched::async, 可能是程序崩溃</li>
<li>默认写法判定系统是否创建线程需要wait_for</li>
</ul>
<pre><code class="language-plain_text">std::future_status status = result.wait_for(std::chrono::seconds(0));
if (status == std::future_status::deferred) {
  //delay exec 
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-24T18:11:34+08:00" itemprop="datePublished">2019/08/24 18:11 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15666414947293.html" itemprop="url">
		临时对象深入探讨，解析，提高性能手段</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>临时对象的概念</h4>
<ul>
<li>右值引用范围内，临时对象不会被释放</li>
<li>代码书写问题产生的，统一称为临时变量</li>
</ul>
<h4><a id="%E4%BA%A7%E7%94%9F%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%83%85%E5%86%B5%E5%92%8C%E8%A7%A3%E5%86%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>产生临时对象的情况和解决</h4>
<ul>
<li>以传值的方式给函数传递参数</li>
<li>类型转换生成的临时对象，隐式临时对象，保证函数调用成功</li>
<li>函数返回对象的时候</li>
<li>C++只会为const引用(const string&amp; str)产生临时变量，</li>
<li>CTmp tm3 = Double(sum1);tm3直接接管了临时对象</li>
<li>CTmp&amp;&amp; tm3 = Double(sum1); 右值引用成功接管了临时对象</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-27T18:05:38+08:00" itemprop="datePublished">2019/08/27 18:05 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15669003383519.html" itemprop="url">
		类型转换构造函数，运算符，类成员指针</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E8%BF%90%E7%AE%97%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类型转换构造运算符</h4>
<ul>
<li>operator type() const</li>
<li>type 表示要转换的类型</li>
<li>类型转换运算符，没有形参</li>
<li>必须定义为类的成员函数</li>
</ul>
<h4><a id="%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义函数指针</h4>
<ul>
<li>typedef void(*func)(int);</li>
<li>using func = void(*)(int)</li>
</ul>
<h4><a id="%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类成员函数指针</h4>
<ul>
<li>void (A::*ptr)(int)</li>
<li>成员函数是属于类的，和对象没有关系</li>
<li>(a.*ptr)(12);</li>
</ul>
<h4><a id="%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态成员函数</h4>
<ul>
<li>void (*s_ptr)(int) = &amp;A::s_func;</li>
<li>s_ptr(1200);</li>
</ul>
<h4><a id="%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类成员变量指针</h4>
<ul>
<li>int A::*t = &amp;A::m_i;</li>
<li>并不是真正的地址，而是该成员变量的偏移量</li>
</ul>
<h4><a id="%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态成员变量</h4>
<ul>
<li>有真正的内存地址</li>
<li></li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_11.html">Prev</a>  
	 <a class="next" href="all_13.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>