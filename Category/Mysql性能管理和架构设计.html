<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Mysql性能管理和架构设计 -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-30T06:12:02+08:00" itemprop="datePublished">2019/09/30 06:12 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15697951220815.html" itemprop="url">
		SQL查询优化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化</h4>
<ul>
<li>查询优化，库表优化，索引优化</li>
</ul>
<h4><a id="%E8%8E%B7%E5%8F%96%E6%9C%89%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E7%9A%84sql" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取有性能问题的SQL</h4>
<ul>
<li>通过用户反馈获取存在性能问题的</li>
<li>SQL通过慢查日志获取存在性问题的SQL</li>
<li>实时获取存在性能问题的SQL</li>
</ul>
<h4><a id="%E6%85%A2%E6%9F%A5%E6%97%A5%E5%BF%97%E8%8E%B7%E5%8F%96%E5%AD%98%E5%9C%A8%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84sql" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>慢查日志获取存在性问题的SQL</h4>
<ul>
<li>slow_query_log 启动停止记录慢查询日志</li>
<li>slow_query_log_file 指定慢查日志的存储路径及文件</li>
<li>long_query_time 指定记录慢查日志SQL执行时间的阀值<br />
<img src="media/15697951220815/15697956818258.jpg" alt="" style="width:680px;" /></li>
<li>1ms比较合适</li>
<li>log_ queries_ not_using_indexes 是否记录未使用索引的SQL</li>
</ul>
<h5><a id="%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用工具</h5>
<ul>
<li>mysqldumpslow<br />
<img src="media/15697951220815/15697959332594.jpg" alt="" style="width:791px;" /></li>
</ul>
<pre><code class="language-plain_text">pt-query-digest --explain -h -u slow-mysql.log
</code></pre>
<h4><a id="%E5%AE%9E%E6%97%B6%E8%8E%B7%E5%8F%96%E6%9C%89%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98sql" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实时获取有性能问题SQL</h4>
<pre><code class="language-plain_text">SELECT `id`,`user`,`host`,DB,command,`time`,state,Info
FROM information_schema.PROCESSLIST WHERE TIME&gt;=60
</code></pre>
<h4><a id="%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>执行流程</h4>
<ul>
<li>客户端发送 SQL 请求给服务器</li>
<li>服务器检查是否可以在査询绶存中命中该 SQL</li>
<li>服务器端进行 SQL 解析，预处理，再由优化器生成对应的执行计划</li>
<li>跟据执行计划，调用存储引擎 AI 来查询数据</li>
<li>将结果返回给客户端</li>
</ul>
<h5><a id="%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查询缓存</h5>
<ul>
<li>query_cache_type 设置查询绶存是否可用 OFF</li>
<li>query_ cache_size 设置査询缓存的内存大小 0</li>
<li>query_cache_ limit 设置查询缓存可用存储的最大值</li>
<li>query_cache lock invalidate 设置数据表被锁后是否返回绶存中的数据</li>
<li>query_cache_ min_res_unit 设置查询缓存分配的内存块最小单位</li>
</ul>
<h4><a id="%E8%A7%A3%E6%9E%90%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解析阶段</h4>
<ul>
<li>MYSQL依照这个执行计划和存储引擎进行交互这个阶段包括了多个子过程</li>
<li>检查查询中所涉及的表和数据列是否存在及名字或别名是否存在歧义等等</li>
<li>语法检查全都通过了，查询优化器就可以生成查询计划了</li>
</ul>
<h5><a id="%E7%94%9F%E6%88%90%E9%94%99%E8%AF%AF%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生成错误的执行计划的原因</h5>
<ul>
<li>统计信息不准确</li>
<li>执行计划中的成本估算不等同于实际的执行计划的成本</li>
<li>MYSQL优化器所认为的最优可能与你所认为的最优不一样</li>
<li>MYSQL 从不考虑其他并发的査询，这可能会影响当前查询的速度</li>
<li>MySQL 有时候也会基于一些固定的规则来生成执行计划</li>
<li>MySQL 不会考虑不受其控制的成本 自定义函数</li>
</ul>
<h5><a id="%E5%8F%AF%E4%BC%98%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可优化的类型</h5>
<ul>
<li>重新定义表的关联顺序</li>
<li>将外连接转化成内连接</li>
<li>使用等价变换规则</li>
<li>优化count()min()max()</li>
<li>select tables optimized away</li>
<li>优化器已经从执行计划中移除了该表，并以一个常数取而代之</li>
<li>将一个表达式转化为常数表达式</li>
<li>使用等价变换规则</li>
<li>子查询优化</li>
<li>提前终止查询</li>
<li>in条件优化，先排序，然后通过二分查找的方式</li>
</ul>
<h4><a id="%E7%A1%AE%E5%AE%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E6%89%80%E6%B6%88%E8%80%97%E7%9A%84%E6%97%B6%E9%97%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>确定查询处理各个阶段所消耗的时间</h4>
<ul>
<li>实用profile</li>
<li>set profiling=1;</li>
<li>show profiles;</li>
<li>show profile for query N;</li>
<li>show profile cpu for query 1;</li>
<li>performance_shema</li>
</ul>
<pre><code class="language-plain_text">UPDATE `setup_instruments` SET enabled='YES', TIMED='YES' WHERE NAME LIKE 'stage%';
UPDATE setup_consumers SET enabled='yes' WHERE NAME LIKE 'events%';


SELECT a.THREAD_ID,SQL_TEXT,c.EVENT_NAME,(c.TIMER_END-c.TIMER_START)/1000000000 AS 'DURATION (ms)' FROM events_ statements_history_long a JOIN threads b ON a.`THREAD_ID`=b.`THREAD_ID` JOIN events_stages_history_long c ON c.`THREAD_ID`=b.`THREAD_ID` AND c.`EVENT_ID` BETWEEN a.EVENT_ID AND a.END_EVENT_ID WHERE b.`PROCESSLIST_ID`=CONNECTION_ID() AND a.EVENT_NAME='statement/sql/select' ORDER BY a.THREAD_ID,c.EVENT_ID;
</code></pre>
<p><img src="media/15697951220815/15697985375993.jpg" alt="" style="width:1208px;" /></p>
<h4><a id="%E7%89%B9%E5%AE%9Amysql%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>特定mysql的查询优化</h4>
<ul>
<li>分批处理 暂停一段时间</li>
</ul>
<h5><a id="%E4%BF%AE%E6%94%B9%E5%A4%A7%E8%A1%A8%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改大表结构</h5>
<p><img src="media/15697951220815/15697987541897.jpg" alt="" style="width:809px;" /></p>
<pre><code class="language-plain_text">pt-online-schema-change --alter=&quot;modify c1 varchar(40) not null default '' &quot; --user=root --password=L19880901c- D=crn2,t=t charset=utf8 --execute;
</code></pre>
<h5><a id="%E4%BC%98%E5%8C%96not-in%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化not in &amp;&amp; &lt;&gt;查询</h5>
<p><img src="media/15697951220815/15697994236380.jpg" alt="" style="width:1085px;" /></p>
<h5><a id="%E4%BD%BF%E7%94%A8%E6%B1%87%E6%80%BB%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用汇总表查询优化</h5>
<p><img src="media/15697951220815/15697995377681.jpg" alt="" style="width:1188px;" /></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-10-01T06:16:05+08:00" itemprop="datePublished">2019/10/01 06:16 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15698817657509.html" itemprop="url">
		Mysql监控</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li>MySQL 数据库我们都要监控什么</li>
<li>怎么对这些要监控的资源进行监控</li>
</ul>
<h4><a id="%E7%9B%91%E6%8E%A7%E5%8F%AF%E7%94%A8%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>监控可用性</h4>
<ul>
<li>对数据库服务可用性进行监控</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何确认数据库是否可以通过网络连接</h5>
<pre><code class="language-plain_text">mysqladmin-umonitor_user-p h ping
telnet ip port
应用程序通过网络建立数据库连接
</code></pre>
<ul>
<li>可以连接到数据库不代表可用</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E7%A1%AE%E8%AE%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E5%8F%AF%E8%AF%BB%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何确认数据库是否可读写</h5>
<ul>
<li>检査数据库的 read_only 参数是否为 off</li>
<li>建立监控表并对表中数据进行更行执行简单的查询</li>
<li>select@@ version</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何监控数据库的连接数</h5>
<ul>
<li>时刻关注数据库连接数量的变化</li>
</ul>
<pre><code class="language-plain_text">show variables like 'max connections 
show global status like 'Threads_connected'
threads connected/max connections 0.8
</code></pre>
<h4><a id="%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对数据库性能进行监控</h4>
<ul>
<li>记录性能监控过程中所采集到的数据库的状态</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97qps%E5%92%8Ctps" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何计算QPS和TPS</h5>
<pre><code class="language-plain_text">* QPS=(Queries2-Queries1)(差值)/
(Uptime_since_flush_status2- Uptime_since_flush_status1）(时间间隔)
* TPS=((Com_insert+Com_update2+Com_delete
 (Com_insert1+Com_update1+Com_deletel))/
 (Uptimesince_flushStatus2-uptime_since_flush_statusi)
</code></pre>
<h5><a id="%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%E6%95%B0%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何监控数据库的并发请求数量</h5>
<pre><code class="language-plain_text">show global status like 'Threads_running'
</code></pre>
<ul>
<li>数据库系统的性能会随着并发处理请求数量的增加而下降</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7innodb%E9%98%BB%E5%A1%9E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何监控Innodb阻塞</h5>
<p><img src="media/15698817657509/15698831966537.jpg" alt="" style="width:1183px;" /></p>
<ul>
<li>information_schema.innodb_lock_waits</li>
<li>information_schema.innodb_trx</li>
</ul>
<pre><code class="language-plain_text">select connection_id() 查看连接ID
</code></pre>
<h4><a id="%E5%AF%B9%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对主从复制进行监控</h4>
<h5><a id="%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%9A%84%E7%9B%91%E6%8E%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主从复制链路状态的监控</h5>
<ul>
<li>Slave_IO_Running: Yes</li>
<li>Slave_SQL_Running: Yes</li>
</ul>
<h5><a id="%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F%E7%9A%84%E7%9B%91%E6%8E%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主从复制延迟的监控</h5>
<ul>
<li>show slave status</li>
<li>Seconds_Behind_Master 0</li>
<li>这个方法需要使用多线程的程序同时对于主从服务器的状态来进行检查</li>
</ul>
<h5><a id="%E5%AE%9A%E6%9C%9F%E7%9A%84%E7%A1%AE%E8%AE%A4%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定期的确认主从复制的数据是否一致</h5>
<p><img src="media/15698817657509/15698839274583.jpg" alt="" style="width:1065px;" /></p>
<h4><a id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E7%9A%84%E7%9B%91%E6%8E%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>服务器资源的监控</h4>
<ul>
<li>磁盘空间</li>
<li>CPU 的使用情况，内存的使用情况，Swap 分区的使用情况以及网络 IO 的情况等</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-06-08T15:18:38+08:00" itemprop="datePublished">2019/06/08 15:18 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15599783184679.html" itemprop="url">
		基准测试和性能测试</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E7%9A%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基准测试的目的</h4>
<ul>
<li>建立mysql服务器的性能基准线</li>
<li>模拟比当前系统更高的负载，找出系统的扩展瓶劲</li>
<li>测试不同硬件，软件和操作系统</li>
<li>证明新的硬件设备是否配置正确</li>
</ul>
<h4><a id="%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E6%8C%87%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基准测试常见指标</h4>
<ul>
<li>TPS</li>
<li>QPS</li>
<li>响应时间</li>
<li>平均响应时间，最小响应时间，最大响应时间，各时间响应百分比</li>
<li>并发量</li>
<li>正在工作中的并发的操作数或同事工作的数量</li>
</ul>
<h4><a id="%E8%AE%A1%E5%88%92%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计划和设计基准测试</h4>
<ul>
<li>整个系统还是单一组件</li>
<li>使用什么样的数据</li>
</ul>
<h4><a id="%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%9A%84%E6%AD%A5%E9%AA%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基准测试的步骤</h4>
<ul>
<li>准备基准测试数据和收集脚本</li>
<li>运行基准测试</li>
<li>保存以及分析基准测试结果</li>
</ul>
<p>####基准测试的问题</p>
<ul>
<li>使用生产环境数据，只使用了部分数据</li>
<li>多用户场景，只做单用户测试</li>
<li>单服务器上测试分布式应用</li>
<li>反复执行同一个查询，容易命中缓存，无法反应真实的查询性能</li>
</ul>
<h4><a id="mysqlslap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mysqlslap</h4>
<ul>
<li>可以模拟服务器负载，并输出相关统计信息可以指定也可以自动生成查询语句</li>
<li>常用参数说明</li>
</ul>
<pre><code class="language-mysql">--auto-generate-sql由系统自动生成SQL脚本进行测试
--auto-generate-sql-add-autoincrement在牛成的表中增加自增ID
--auto-generate sql-load-type指定测试中使用的询类型
--auto-generate sql-write number指定初始化数据时生成的数据量
--concurrency指定并发线程的数量
--engine 指定要测试表的存储引擎，可以用逗号分割多个存储引擎
--no-drop 指定不清理测试数据
--iterations 指定测试运行的次数
--number-of-queries 指定每一个线程执行的查询数量
--debug-info 指定输出额外的内存和CPU统计信息
--number-int-cols 指定测试表中包含INT类型列的数量
--number-char-cols 指定测试表中包含的varchar 类型的数量
--create-schema 指定了用于执行测试的数据库的名字
--query 用于指定自定义 SQL 的脚本
--only-print 并不运行测试脚本，而是把生成的脚本打
</code></pre>
<h4><a id="%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试案例</h4>
<pre><code class="language-plain_text">mysqlslap --concurrency=1,50,100,200 --iterations=3 --number-int-cols=5 --number-char-cols=5 --auto-generate-sql --auto-generate-sql-add-autoincrement --engine=myisam,innodb --number-of-queries=10 --create-schema=sbtest -uroot -pL19880901c-
</code></pre>
<h4><a id="sysbench" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>sysbench</h4>
<h5><a id="%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用参数</h5>
<ul>
<li>test 用于指定所要执行的测试类型，支持以下参数 Fileid 文件系统 O 性能測试 cpu cpu'性能试 memory 内存性能观试 oltp 测试要指定具体的 lua 脚本</li>
</ul>
<pre><code class="language-sql">mysqa-db 用于指定执行基准测试的数据库名
mysql-table-engine 用于指定所使用的存储引擎
oltp-tables-count 执行测试的表的数量
oltp-table-size 指定每个表中的数据行数
num-threads 指定测试的并发线程数量
max-time 指定最大的测试时间
report- -interval指定间隔多长时间输出一次统计信息
mysq-user 指定执行测试的 MYSQL 用户
-mysqlpassword 指定执行测试的 MYSQL 用户的密码
prepare 用于准备测试数据
run 用于实际进行测试
cleanup 用于清理测试数据
</code></pre>
<h4><a id="%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试案例</h4>
<pre><code class="language-plain_text">sysbench --test=cpu --cpu-max-prime=10000 run
sysbench --test-fileio --num-thread=8 --init-rng=on --file-total-size=5G \
--file-test-mode=rndrw --report-interval=1s
</code></pre>
<h5><a id="mysql%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mysql性能测试</h5>
<pre><code class="language-plain_text">sysbench ./oltp.lua --mysql-host=192.168.31.186 --mysql-port=3306 --mysql-user=root --mysql-password=&quot;L19880901c-&quot; --mysq1-table-engine=innodb --oltp-tables-count=10 --oltp-table-size=100000 --threads=10 --time=120 --report-interval=10 prepare
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-23T07:21:20+08:00" itemprop="datePublished">2019/09/23 07:21 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15691944800581.html" itemprop="url">
		mysql高可用架构设计</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%A4%8D%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复制</h4>
<ul>
<li>实现在不同服务器上的数据分布</li>
<li>实现数据读取的负载均衡</li>
<li>增强了数据安全性</li>
<li>实现数据库高可用和故障切换</li>
<li>实现数据库在线升级</li>
</ul>
<h4><a id="binlog" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>binlog</h4>
<h5><a id="statement" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>statement</h5>
<ul>
<li>基于段的格式<br />
<img src="media/15691944800581/15691948341088.jpg" alt="" style="width:1183px;" /></li>
</ul>
<h5><a id="row" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>row</h5>
<ul>
<li>基于行的格式</li>
<li>同-SQL 语句修改了 10000 条数据的情况下基于段的日志格式只会记录这个 SQL 语句</li>
<li>基于行的日志会有 10000 条记录分别记录每行的数据修改</li>
<li>使Mysql主从复制更加安全</li>
<li>对每一行数据的修改比基于段的复制高效</li>
<li>误操作可以通过反向处理</li>
<li>缺点</li>
<li>记录日志量较大binlog_row_image=full|minimal记录列|noblog</li>
<li>full：在before和after影像中，记录所有的列值；</li>
<li>minimal：在before和after影像中，仅仅记录被更改的以及能够唯一识别数据行的列值；</li>
<li>noblob：在before和after影像中，记录所有的列值，但是BLOB 与 TEXT列除外（如未更改）。</li>
</ul>
<h5><a id="mixed" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mixed</h5>
<ul>
<li>根据SQL语句由系统决定在基于段和基于行的日志格式中进行选择</li>
</ul>
<h5><a id="%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>建议</h5>
<ul>
<li>row</li>
<li>minimal</li>
</ul>
<h5><a id="%E5%A4%8D%E5%88%B6%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复制总结</h5>
<h5><a id="%E5%9F%BA%E4%BA%8Esql%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88sbr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于SQL语句的复制（SBR)</h5>
<ul>
<li>二进制日志格式使用的是 statement</li>
<li>缺点</li>
<li>对于非确定性事件，无法保证主从复制数据的一致性</li>
<li>对于存储过程，触法器，自定义函数进行的修改也可能造成数据不一致</li>
<li>相比于基于行的复制方式在从上执行时需要更多的行锁</li>
</ul>
<h5><a id="%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%9A%84%E5%A4%8D%E5%88%B6%EF%BC%88rbr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于行的复制（RBR)</h5>
<ul>
<li>二进制日志格式使用的是基于行的日志格式</li>
<li>优点</li>
<li>可以应用于任何 SQL 的复制包括非确定函数，存储过程等</li>
<li>可以减少数据库锁的使用</li>
<li>缺点</li>
<li>要求主从数据庳的表结构相同，否则可能会中断复制</li>
<li>无法在从服务器上单独执行触法器</li>
</ul>
<h4><a id="%E5%A4%8D%E5%88%B6%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复制工作方式</h4>
<ul>
<li>主将变更写入二进制日志</li>
<li>从读取主的二进制日志变更并写入到 Relay_log 中</li>
<li>在从上重放 relay_log 中的日志</li>
<li>基于 SQL 段的日志是在从库上重新执行记录的 SQL 基王行的日赤则是在从库上直接应用对数据库行的修改</li>
</ul>
<h4><a id="%E4%B8%BB%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主配置</h4>
<pre><code class="language-plain_text">bin_log=mysql-bin
server_id=100
</code></pre>
<h4><a id="%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>从服务器配置</h4>
<pre><code class="language-plain_text">bin_log=mysql-bin
server_id=100
relay_log=mysql-relay-bin
log_slave_update=on //链路配置
read_only=on //防止错误配置
</code></pre>
<h4><a id="gtid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>GTID</h4>
<ul>
<li>GTID 即全局事务 ID，其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的 ID</li>
<li>source_id:transaction_id</li>
<li>Create table. Select<br />
在事务中使用 Create temporary table 建立临时表使用关联更新事务表和非事务表都是会报错的</li>
</ul>
<h4><a id="%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>从服务器</h4>
<pre><code class="language-plain_text">Log-slave-updates = on read_only=on【建议】
master info_ repository= TABLE【建议】
relay_log_info_ repository= TABLE【建议】
gtid_mode =on
enforce-gtid-consistency
</code></pre>
<ul>
<li>查询授权</li>
</ul>
<pre><code class="language-plain_text">select user,host  from user;
show grants for shui@'192.168.31.%'
</code></pre>
<h4><a id="gtid%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>GTID复制的优缺点</h4>
<ul>
<li>优点</li>
<li>可以很方便的进行故障转移从库不会丢失主库上的任何修改</li>
<li>缺点</li>
<li>故障处理比较复杂</li>
<li>对执行的 SQL 有一定的限制</li>
</ul>
<h4><a id="%E9%80%89%E6%8B%A9%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>选择复制模式要考虑的问题</h4>
<ul>
<li>所使用的MYSQL版本</li>
<li>复制架构及主从切换的方式</li>
<li>所使用的高可用管理组件</li>
</ul>
<h4><a id="%E5%A4%8D%E5%88%B6%E6%8B%93%E6%89%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复制拓扑</h4>
<ul>
<li>MYSQL5.7 之前，一个从库只能有一个主库</li>
<li>MYSQL5.7 之后支持一从多主架构</li>
</ul>
<h4><a id="%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一主多从</h4>
<ul>
<li>为不同业务使用不同的从库</li>
<li>将一台从库放到远程 IDC，用作灾备恢复</li>
<li>分担主库的读负载，由于要复制主库的写，所以不能分担写负载</li>
</ul>
<h4><a id="%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6%E6%8B%93%E6%89%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主主复制拓扑</h4>
<h5><a id="%E4%B8%BB%E4%B8%BB%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主主模式</h5>
<ul>
<li>产生数据冲突而造成复制链路的中断</li>
<li>耗费大量的时间</li>
<li>造成数据丟失</li>
<li>注意事项</li>
<li>两个主中所操作的表最好能够分开使用下面两个参数控制自增 ID 的生成</li>
<li>auto increment increment= 2</li>
<li>auto_increment_offset=12</li>
</ul>
<h4><a id="%E4%B8%BB%E5%A4%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主备</h4>
<ul>
<li>只有一台主服务器对外提供服务</li>
<li>一台服务器处于只读状态并且只作为热备使用在对外提供服务的主库出现故障或是计划性的维护时才会进行切换</li>
<li>使原来的备库成为主库，而原来的主库会成为新的备库并处理只读或是下线状态，待维护完成后重新上线</li>
<li>注意事项</li>
<li>确保两台服务器上的初始数据相同</li>
<li>确保两台服务器上已经启动 biolog 并且有不同的 server id</li>
<li>在两台服务器上启用 log_ slave_ updates 参数在初始的备库上启用 read_only</li>
</ul>
<h4><a id="%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拓扑结构</h4>
<p><img src="media/15691944800581/15692711891670.jpg" alt="" style="width:1026px;" /></p>
<ul>
<li>级联复制<br />
<img src="media/15691944800581/15692712403802.jpg" alt="" style="width:1034px;" /></li>
</ul>
<h4><a id="%E5%A4%8D%E5%88%B6%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复制优化</h4>
<ul>
<li>控制主库的事务大小分割大事务,大表修改无法分割</li>
<li>二进制日志传输时间 mixed，row-&gt;set binlog_row_image=minimal;</li>
<li>默认情况下从只有一个 SQ인L 线程，主上并发的修改在从上变成了串行</li>
<li>在 MYSQL5.7 中可以按照逻辑时钟的方式来分配 SQL 线程</li>
</ul>
<pre><code class="language-plain_text">stop slave;
set global slave_parallel_type='logical_clock';
set global slave_parallel_workers=4; 
start slave;
</code></pre>
<h4><a id="%E5%A4%8D%E5%88%B6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复制常见问题</h4>
<ul>
<li>主库或从库意外宕机引起的错误</li>
<li>使用跳过二进制日志事件</li>
<li>注入空事务的方式先恢复中断的复制链路</li>
<li>再使用其它方法来对比主从服务器上的数据</li>
<li>主库的二进制日志损坏</li>
<li>备库的中继日志</li>
<li>在从库上进行数据修改造成的主从复制错误</li>
<li>不唯一的 server id 或 server_uuid</li>
<li>max_allow_packeti 设置引起的主从复制错</li>
</ul>
<h4><a id="%E5%A4%8D%E5%88%B6%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复制解决不了的问题</h4>
<ul>
<li>分担主数据库的写负载</li>
<li>自动进行故障转移及主从切换</li>
<li>提供读写分离功能</li>
</ul>
<h4><a id="%E9%AB%98%E5%8F%AF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高可用</h4>
<p><img src="media/15691944800581/15692724432770.jpg" alt="" style="width:723px;" /></p>
<h5><a id="%E9%81%BF%E5%85%8D%E5%AF%BC%E8%87%B4%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E5%9B%A0%E7%B4%A0%EF%BC%8C%E5%87%8F%E5%B0%91%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>避免导致系统不可用的因素，减少系统不可用的时间</h5>
<ul>
<li>建立完善的监控及报警系统</li>
<li>对备份数据进行恢复测试</li>
<li>正确配置数据库环境</li>
<li>对不需要的数据进行归档和清理</li>
</ul>
<h5><a id="%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E5%86%97%E4%BD%99%EF%BC%8C%E4%BF%9D%E8%AF%81%E5%8F%91%E7%94%9F%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%8F%AF%E7%94%A8%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%B0%BD%E5%BF%AB%E6%81%A2%E5%A4%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>增加系统冗余，保证发生系统不可用时可以尽快恢复</h5>
<ul>
<li>避免存在单点故障</li>
<li>利用SUN共享存储或DRDB磁盘复制解决MYSQL单点故障<br />
<img src="media/15691944800581/15693677885166.jpg" alt="" style="width:637px;" /></li>
<li>利用多写集群或NDB集群来解决Mysql单点故障<br />
<img src="media/15691944800581/15693678313849.jpg" alt="" style="width:377px;" /></li>
<li>利用MySQL主从复制来解决MySQL单点故障</li>
<li>问题</li>
<li>主服务器切换后如何通知应用新的主服务器的 IP 地址</li>
<li>如何检查 MYSQL 主服务器是否可用</li>
<li>如何处理从服务器和新主服务器之间的那种复制关系</li>
<li>主从切换及故障转移</li>
</ul>
<h4><a id="mmm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MMM</h4>
<ul>
<li>监控和管理 MYSQL 的主主复制拓扑，并在当前的主服务器失效时，进行主和主备服务器之间的主从切换和故障转移等工作</li>
<li>MMM监控 MySQL 主从复制健康情况</li>
<li>在主库出现宕机时进行故障转移并自动配置其它从对新主的复制</li>
<li><img src="media/15691944800581/15693682010691.jpg" alt="" style="width:888px;" /><br />
<img src="media/15691944800581/15693681373072.jpg" alt="" style="width:670px;" /></li>
<li>提供了主，写虚拟 IP，在主从服务器出现问题时可以自动迁移虚拟 IP<br />
<img src="media/15691944800581/15693682624344.jpg" alt="" style="width:918px;" /></li>
</ul>
<h5><a id="%E9%9C%80%E8%A6%81%E8%B5%84%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需要资源</h5>
<p><img src="media/15691944800581/15693682900151.jpg" alt="" style="width:947px;" /></p>
<h5><a id="%E9%83%A8%E7%BD%B2%E6%AD%A5%E9%AA%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>部署步骤</h5>
<ul>
<li>配置主主复制及主从同步集群</li>
<li>安装主从节点所需要的支持包</li>
<li>安装及配置 MMM 工具集</li>
<li>运行 MMM 监控服务测试<br />
<img src="media/15691944800581/15693685291641.jpg" alt="" style="width:651px;" /></li>
<li><img src="media/15691944800581/15693685352329.jpg" alt="" style="width:883px;" /></li>
</ul>
<h5><a id="%E4%BC%98%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优点</h5>
<ul>
<li>使用 PerI 脚本语言开发及完全开源</li>
<li>提供了读写 VIP（虚拟 IP），使服务器角色的变更对前端应用透明</li>
<li>在从服务器出现大量的主从延迟，主从链路中断时可以把这台从服务器上的读的虚拟 IP，漂移到集群中其它正常的服务器上。</li>
<li>MMM 提供了从服务器的延迟监控</li>
<li>MMM 提供了主数据库故障转移后从服务器对新主的重新同步功能</li>
<li>很容易对发生故障的主数据库重新上线</li>
</ul>
<h5><a id="%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缺点</h5>
<ul>
<li>发布时间比较早不支持 MYSQLI 新的复制功能</li>
<li>不支持多线程复制功能</li>
<li>没有读负载均衡的功能</li>
<li>在进行主从切换时，容易造成数据丟失，重复递交事务</li>
<li>MMM 监控服务存在单点故障</li>
</ul>
<h4><a id="mha" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MHA</h4>
<ul>
<li>30秒内完成切换</li>
<li>监控主数据库服务器是否可用</li>
<li>当主 DB 不可用时，从多个从服务器中选举出新的主数据库服务器</li>
<li>提供了主从切换和故障转移功能</li>
</ul>
<h5><a id="%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主从切换流程</h5>
<ul>
<li>尝试从出现故障的主数据库保存二进制日志</li>
<li>从多个备选从服务器中选举出新的备选主服务器</li>
<li>在备选主服务器和其它从服务器之间同步差异二进制数据</li>
<li>应用从原主 DB 服器上保存的二进制日志</li>
<li>迁移集群中的其它从 DB 作为新的主 DB 的从服务器</li>
</ul>
<h5><a id="mha%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MHA架构</h5>
<p><img src="media/15691944800581/15693704382563.jpg" alt="" style="width:757px;" /></p>
<ul>
<li><img src="media/15691944800581/15693704552779.jpg" alt="" style="width:643px;" /></li>
</ul>
<h5><a id="%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置步骤</h5>
<ul>
<li>建立主从复制集群</li>
<li>配制 MHA 管理节点</li>
<li>使用 masterha_ check_ssh 和 masterha_ check_repl 对配置进行检验</li>
<li>启动并测试 MHA 服务</li>
</ul>
<h4><a id="mha%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MHA的优点和缺点</h4>
<h5><a id="%E4%BC%98%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优点</h5>
<ul>
<li>同样是由 Per 语言开发的开源工具</li>
<li>可以支持基于 GTD 的复制模式</li>
<li>MHA 在进行故障转移时更不易产生数据丟失</li>
<li>同一个监控节点可以监控多个集群</li>
</ul>
<h5><a id="%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缺点</h5>
<ul>
<li>需要编写脚本或利用第三方工具来实现 Vip 的配置</li>
<li>MHA 启动后只会对主数据库进行监控，不能排查从服务器故障</li>
<li>需要基于 SSH 兔认证配置，存在一定的安全隐患</li>
<li>没有提供从服务器的读负载均衡功能</li>
</ul>
<h4><a id="%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>负载均衡</h4>
<h4><a id="%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>读写分离</h4>
<p><img src="media/15691944800581/15696236063092.jpg" alt="" style="width:1110px;" /></p>
<h5><a id="%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>程序实现读写分离</h5>
<ul>
<li>优点</li>
<li>由开发人员控制什么样查询在从库中执行，因此比较灵活</li>
<li>由程序直接连接数据库，所以性能损耗比较少</li>
<li>缺点</li>
<li>增加了开发的工作量，使程序代码更加复杂</li>
<li>人为控制，容易出现错误</li>
</ul>
<h5><a id="%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中间件来实现读写分离</h5>
<ul>
<li>mysql-proxy</li>
<li>maxScale</li>
<li>优点</li>
<li>由中间件根据查询语法分析，自动完成读写分离</li>
<li>对程序透明，对于已有程序不用做任何调整</li>
<li>缺点</li>
<li>由于增加了中间层，所以对查询效率有损耗 消耗50%</li>
</ul>
<h5><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h5>
<ul>
<li>读写分离要解决的是如何在复制集群的不同角色上，去执行不同的 SQL 语句。</li>
<li>读的负载均衡主要解决的是具有相同角色的数据库，如何共同分担相同的负载。</li>
</ul>
<h4><a id="maxscale" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MaxScale</h4>
<ul>
<li>Authentication 认证插件</li>
<li>Protocal 协议插件</li>
<li>Router 路由插件 readconnroute readwritesplit</li>
<li>Monitor 监控插件</li>
<li>Filter&amp;Logging 日志和过滤插件</li>
</ul>
<h4><a id="%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高可用架构</h4>
<p><img src="media/15691944800581/15696250203347.jpg" alt="" style="width:1204px;" /></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-29T06:54:42+08:00" itemprop="datePublished">2019/09/29 06:54 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15697112820357.html" itemprop="url">
		索引性能优化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引类型</h4>
<h4><a id="b-tree%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>B+tree索引</h4>
<ul>
<li>B-tree 过引以 B+树的结构存储数据</li>
<li>Innodb通过主键。Myisam通过物理位置引用物理行</li>
<li>B-tree 索引能够加快数据的查询速度</li>
<li>B-tree 索引更适合进行范围查找</li>
</ul>
<h5><a id="%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>能够使用索引的场景</h5>
<ul>
<li>全值匹配的查询</li>
<li>匹配最左前缀的查询</li>
<li>匹配列前缀查询 orders_sn like '9876%'</li>
<li>匹配范围值的查询</li>
<li>精确匹配左前列并范围匹配另外一列</li>
<li>只访问索引的查询 覆盖索引</li>
</ul>
<h5><a id="%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用限制</h5>
<ul>
<li>如果不是按照索引最左列开始查找，则无法使用索引</li>
<li>使用索引时不能跳过索引中的列</li>
<li>Not in和&lt;&gt;无法使用</li>
<li>如果査询中有某个列的范围查询，则其右边所有列都无法使用索引</li>
</ul>
<h4><a id="hash%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hash索引</h4>
<ul>
<li>只能等值查询</li>
<li>Hash 索引是基于 Hash 表实现的，只有查询条件精确匹配 Hash 索引中的所有列时，才能够使用到 hash 索引。</li>
<li>对于 Hash 索引中的所有列，存储引擎都会为每一行计算一个 Hash 码，Hash 索引中存储的就是 Hash 码。</li>
<li>Hash 索引必须进行二次查找</li>
<li>Hash 索引无法用于排序</li>
<li>Hash 索引不支持部分索引查找也不支持范闺查找</li>
<li>Hash 索引中 Hash 码的计算可能存在 Hash冲突</li>
</ul>
<h4><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么使用索引</h4>
<ul>
<li>索引大大減少了存储引孳需要扫描的数据量</li>
<li>索引可以帮助我们进行排序以避免使用临时表</li>
<li>索引可以把随机I/O変为顺序I/O</li>
</ul>
<h4><a id="%E7%B4%A2%E5%BC%95%E6%98%AF%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引是不是越多越好</h4>
<ul>
<li>索引会增加写操作的成本</li>
<li>太多的索引会增加查询优化器的选择时间</li>
</ul>
<h4><a id="%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引优化策略</h4>
<h5><a id="%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%88%96%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引列上不能使用表达式或函数</h5>
<p><img src="media/15697112820357/15697127274946.jpg" alt="" style="width:1103px;" /></p>
<h5><a id="%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前缀索引和索引列的选择性</h5>
<p><img src="media/15697112820357/15697128097620.jpg" alt="" style="width:952px;" /></p>
<ul>
<li>索引的选择性是不重复的索引值和表的记录数的比值<br />
<img src="media/15697112820357/15697128954405.jpg" alt="" style="width:700px;" /></li>
</ul>
<h5><a id="%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>联合索引</h5>
<ul>
<li>经常会被使用到的列优先</li>
<li>选择高的列优先</li>
<li>宽度小的列优先</li>
</ul>
<h5><a id="%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>覆盖索引</h5>
<ul>
<li>可以优化缓存，减少磁盘IO操作</li>
<li>可以减少随机 IO，変随机 IO 操作变为 O 操作</li>
<li>可以避免对 Innodb 主键索引的二次査询</li>
<li>可以避免MYISAM 表进行系统调用</li>
<li>无法使用的情况</li>
<li>存储引擎不支持覆盖索引</li>
<li>査询中使用了太多的列</li>
<li>使用了双%号的 like 查询</li>
</ul>
<h4><a id="%E9%80%82%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9D%A5%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>适用索引来优化查询</h4>
<h5><a id="%E9%80%9A%E8%BF%87%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通过排序操作</h5>
<ul>
<li>innodb索引顺序和主键顺序是一致的</li>
<li>索引的列顺序和 Order By 子句的顺序完全一致</li>
<li>索引中所有列的方向升序降序和 Order by 子句完全致 Order by 中的字段全部在关联表中的第一张表中<br />
<img src="media/15697112820357/15697147233050.jpg" alt="" style="width:1733px;" /></li>
</ul>
<h5><a id="%E6%8C%89%E7%85%A7%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%89%AB%E6%8F%8F%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>按照索引顺序扫描数据</h5>
<h4><a id="%E6%A8%A1%E6%8B%9Fhash%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模拟hash索引</h4>
<ul>
<li>只能处理键值的全值匹配查找</li>
<li>所使用的 Hash 函数决定着索引键的大小</li>
</ul>
<h4><a id="%E7%B4%A2%E5%BC%95%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引效果</h4>
<ul>
<li>减少锁定的行数</li>
<li>加快锁的释放，增加并发</li>
</ul>
<h4><a id="%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%B4%E6%8A%A4%E5%92%8C%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引的维护和优化</h4>
<ul>
<li>删除重复和冗余的索引</li>
<li>使用工具pt-duplicat-key-checker h = 127.0.0.1</li>
<li>查找未被使用过的索引</li>
</ul>
<pre><code class="language-plain_text">select object_schema,object_name,index_name,b.`TABLE_ROWS` FROM  
performance_schema.table_io_waits_summary_by_index_usage a 
JOIN information_schema.tables b ON
a.`OBJECT_SCHEMA`=b.`TABLE_SCHEMA` AND
a.`OBJECT_NAME`=b.`TABLE_NAME`
WHERE index_name IS NOT NULL
AND count_star = 0
ORDER BY object_schema,object_name;
</code></pre>
<ul>
<li>更新索引统计信息较少索引碎片</li>
<li>analysz table table_name</li>
<li>optimize table table_name</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-06-08T15:12:18+08:00" itemprop="datePublished">2019/06/08 15:12 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15599779387841.html" itemprop="url">
		性能影响方面</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>几个方面</h4>
<ul>
<li>服务器硬件</li>
<li>服务器系统</li>
<li>数据库存储引擎的选择</li>
<li>数据库参数配置</li>
<li>数据库结构设计和SQL语句</li>
</ul>
<h4><a id="%E5%9B%BA%E6%80%81%E5%AD%98%E5%82%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>固态存储</h4>
<ul>
<li>SSD和PCI-E SSD</li>
<li>更好的随机读写性能</li>
<li>更好的支持并发</li>
<li>比机械固态磁盘更容易损坏</li>
<li>支持RAID</li>
</ul>
<h4><a id="pcie" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PCIE</h4>
<ul>
<li>Fusion-IO</li>
<li>无法使用STAT接口，需要独特的驱动和配置</li>
<li>相对SSD更贵，性能更贵</li>
<li>使用服务器的CPU和内存资源</li>
<li>不建议使用RAID</li>
<li>适用场景 大量随机I/O的场景</li>
<li>单线程负载的IO瓶颈</li>
<li>建议放在从服务器
<ul>
<li>单线程</li>
<li>损耗少</li>
</ul>
</li>
</ul>
<h4><a id="%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络性能的影响</h4>
<ul>
<li>延迟</li>
<li>吞吐量</li>
</ul>
<h4><a id="%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8san%E5%92%8Cnas" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络存储SAN和NAS</h4>
<ul>
<li>顺序IO性能不错</li>
<li>数据备份文件</li>
</ul>
<h4><a id="%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络对性能的影响</h4>
<ul>
<li>网络带宽</li>
<li>网络质量</li>
</ul>
<h4><a id="%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>建议</h4>
<ul>
<li>高性能和高带宽的网络接口设备和交换机</li>
<li>多个网卡进行绑定，增强可以性和带宽</li>
<li>尽可能进行网络隔离 内外网隔离</li>
</ul>
<h4><a id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6%E5%BD%B1%E5%93%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>服务器硬件影响</h4>
<h5><a id="cpu-64%E4%BD%8D%E7%9A%84cpu%E5%92%8C%E7%B3%BB%E7%BB%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CPU 64位的cpu和系统</h5>
<ul>
<li>并发比较高的场景CPU的数量比频率重要</li>
<li>CPU密集型场景和复杂SQL则频率越高越好</li>
</ul>
<h5><a id="%E5%86%85%E5%AD%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存</h5>
<ul>
<li>主板使用最高频率的内存</li>
<li>内存的大小</li>
</ul>
<h4><a id="io%E5%AD%90%E7%B3%BB%E7%BB%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>IO子系统</h4>
<ul>
<li>PCIE-&gt;SSD-&gt;Raid10-&gt;磁盘-&gt;SAN</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-22T07:13:26+08:00" itemprop="datePublished">2019/09/22 07:13 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15691076069994.html" itemprop="url">
		数据库结构优化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li><img src="media/15691076069994/15691098302316.jpg" alt="" style="width:689px;" /></li>
</ul>
<h4><a id="%E4%BC%98%E5%8C%96%E7%9B%AE%E7%9A%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化目的</h4>
<ul>
<li>减少数据冗余</li>
<li>尽量避免数据维护中出现更新，插入和删除异常</li>
<li>插入异常：如果表中的某个实体随着另一个实体而存在</li>
<li>更新异常：如果更改表中的某个实体的单独属性时，需要对多行进行更新</li>
<li>删除异常：如果删除表中的某一实体则会导致其他实体的消失</li>
<li>节约数据存储空间</li>
<li>提高查询效率</li>
</ul>
<h4><a id="%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设计步骤</h4>
<h5><a id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求分析</h5>
<ul>
<li>全面了解产品设计的存储需求</li>
<li>存储需求</li>
<li>数据处理需求</li>
<li>数据的安全性和完整性</li>
</ul>
<h5><a id="%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逻辑设计</h5>
<ul>
<li>设计数据的逻辑存储结构</li>
<li>数据实体之间的逻辑关系，解决数据冗余和数据维护异常</li>
</ul>
<h5><a id="%E7%89%A9%E7%90%86%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>物理设计</h5>
<ul>
<li>跟据所使用的数据库特点进行表结构设计</li>
</ul>
<h5><a id="%E7%BB%B4%E6%8A%A4%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>维护优化</h5>
<ul>
<li>跟据实际情況对索引、存储结构等进行优化</li>
</ul>
<h4><a id="%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设计范式</h4>
<h5><a id="%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一范式</h5>
<ul>
<li>数据库表中的所有字段都只具有单一属性</li>
<li>单一属性的列是由基本的数据类型所构成的</li>
<li>设计出来的表都是简单的二维表</li>
</ul>
<h5><a id="%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二范式</h5>
<ul>
<li>要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系</li>
</ul>
<h5><a id="%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第三范式</h5>
<ul>
<li>指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖</li>
</ul>
<h4><a id="%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>需求说明</h4>
<ul>
<li>设计电子商务网站<br />
<img src="media/15691076069994/15691103338784.jpg" alt="" style="width:1181px;" /><br />
<img src="media/15691076069994/15691103622147.jpg" alt="" style="width:1082px;" /></li>
<li>商品信息依赖于分类信息，所以需要拆分<br />
<img src="media/15691076069994/15691106259955.jpg" alt="" style="width:1197px;" /></li>
<li>在线销售功能<br />
<img src="media/15691076069994/15691106829695.jpg" alt="" style="width:1145px;" /><br />
<img src="media/15691076069994/15691107266966.jpg" alt="" style="width:1227px;" /></li>
</ul>
<h4><a id="%E8%8C%83%E5%BC%8F%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>范式化设计的优缺点</h4>
<h5><a id="%E4%BC%98%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优点</h5>
<ul>
<li>可以尽量的减少数据冗余</li>
<li>数据表更新快体积小</li>
<li>范式化的更新操作比反范式化更快范式化的表通常比反范式化更小</li>
</ul>
<h5><a id="%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缺点</h5>
<ul>
<li>对于查询需要对多个表进行关联</li>
<li>更难进行索引优化</li>
</ul>
<h4><a id="%E7%89%A9%E7%90%86%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>物理设计</h4>
<ul>
<li>整数类型<br />
<img src="media/15691076069994/15691076463161.jpg" alt="" style="width:1270px;" /></li>
<li>int(2)宽度没有任何意义</li>
<li>实数类型<br />
<img src="media/15691076069994/15691077678335.jpg" alt="" style="width:1107px;" /></li>
<li>DECIMAL可以保证精度</li>
</ul>
<h4><a id="varchar%E5%92%8Cchar%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>varchar和char类型</h4>
<h5><a id="%E5%AE%BD%E5%BA%A6%E6%98%AF%E4%BB%A5%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E4%B8%BA%E5%87%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>宽度是以字符长度为准</h5>
<ul>
<li>Varchar 用于存储变长字符串，只占用必要的存储空间列的最大长度小于 255 则只占用一个额外字节用于记录字符串长度</li>
<li>列的最大长度大于 255 则要占用两个额外字节用于记录字符串长度</li>
</ul>
<h5><a id="%E9%95%BF%E5%BA%A6%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>长度选择问题</h5>
<ul>
<li>使用最小的符合需求的长度，修改宽度需要锁表</li>
<li>varchar(5)和varchar(200)存储'Mysql'字符串性能不同，内存临时表是固定长度。最小可以减少内存消耗</li>
</ul>
<h5><a id="%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>适用场景</h5>
<ul>
<li>字符串列的最大长度比平均长度大很多</li>
<li>字符串列很少被更新</li>
<li>使用了多字节字符集存储字符串</li>
</ul>
<h4><a id="char%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Char类型</h4>
<ul>
<li>CHAR 类型是定长的</li>
<li>字符串存储在 CHAR 类型的列中会删除末尾的空格</li>
<li>CHAR 类型的最大宽度为255</li>
</ul>
<h5><a id="%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>适用场景</h5>
<ul>
<li>CHAR 类型适合存储所长度近似的值</li>
<li>CHAR 类型适合存储短字符串</li>
<li>CHAR 类型适合存储经常更新的字符串列</li>
</ul>
<h4><a id="%E6%97%A5%E6%9C%9F%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>日期数据</h4>
<ul>
<li>date time<br />
<img src="media/15691076069994/15691085771655.jpg" alt="" style="width:1246px;" /></li>
</ul>
<h5><a id="timestamp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TIMESTAMP</h5>
<ul>
<li>4个字节</li>
<li>时间范围 1970-01-01 到 2038-01-19</li>
<li>依赖时区</li>
<li>在行的数据修改时可以自动修改timestamp 列的值</li>
</ul>
<h4><a id="date%E7%B1%BB%E5%9E%8B%E5%92%8Ctime%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>date类型和time类型</h4>
<ul>
<li>Date 类型和 time 类型 date 类型的优点占用的字节数比使用字符串、datetime、int 存储要少，使用 date 类型只需要 3 个字节</li>
<li>使用 Date 类型还可以利用日期时间函数进行日期之间的计算</li>
</ul>
<h4><a id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意事项</h4>
<h5><a id="%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%AD%98%E5%82%A8%E6%97%A5%E6%9C%9F%E6%97%B6%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不要使用字符串类型来存储日期时数据</h5>
<ul>
<li>日期时间类型通常比字符串占用的存储空间小</li>
<li>日期时间类型在进行查找过滤时可以利用日期来进行对比</li>
<li>日期时间类型还有着丰富的处理函数，可以方便的对时期类型进行日期计算</li>
</ul>
<h5><a id="%E4%BD%BF%E7%94%A8int%E5%AD%98%E5%82%A8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E4%B8%8D%E5%A6%82%E4%BD%BF%E7%94%A8timestamp%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用Int存储日期时间不如使用Timestamp类型</h5>
<h4><a id="%E7%89%A9%E7%90%86%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>物理设计</h4>
<p><img src="media/15691076069994/15691096579196.jpg" alt="" style="width:910px;" /><br />
<img src="media/15691076069994/15691097839032.jpg" alt="" style="width:689px;" /></p>
<ul>
<li>为表中的每个列选择合适的类型</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E8%A1%A8%E7%9A%84%E4%B8%BB%E9%94%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何选择表的主键</h5>
<ul>
<li>主键应该尽可能的小</li>
<li>主键应该是顺序增长的</li>
<li>Innodb 的主键和业务主键可以不同</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-10-01T05:34:49+08:00" itemprop="datePublished">2019/10/01 05:34 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15698792898834.html" itemprop="url">
		分库分表</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E9%9B%86%E4%B8%AD%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>集中方式</h4>
<ul>
<li>把一个实例中的多个数据库拆分到不同的实例<br />
<img src="media/15698792898834/15698794876981.jpg" alt="" style="width:1093px;" /></li>
<li>把一个库中的表分离到不同的数据库中</li>
<li>根据写压力来拆分，缓解写负载<br />
<img src="media/15698792898834/15698795766519.jpg" alt="" style="width:966px;" /></li>
</ul>
<h4><a id="%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%89%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据库分片</h4>
<ul>
<li>对一个库中的相关表进行水平拆分到不同实例的数据库中</li>
</ul>
<h5><a id="%E9%80%89%E6%8B%A9%E5%88%86%E5%8C%BA%E9%94%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>选择分区键</h5>
<ul>
<li>分区键要能尽量避兔跨分片查询的发生</li>
<li>分区键要能尽量使各个分片中的数据平均</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%97%A0%E9%9C%80%E5%88%86%E7%89%87%E7%9A%84%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何存储无需分片的表</h5>
<ul>
<li>每个分片中存储一份相同的数据</li>
<li>使用额外的节点统一存储</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E5%9C%A8%E8%8A%82%E7%82%B9%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%88%86%E7%89%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何在节点上部署分片</h5>
<ul>
<li>每个分片使用单一数据库，并且数据库名也相同</li>
<li>将多个分片表存储在一个数据库中，并在表名上加入分片号后缀</li>
<li>在一个节点中部署多个数据库，每个数据库包含一个分片</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%88%86%E7%89%87%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何分配分片中的数据</h5>
<ul>
<li>按分区键的 Hash 值取模来分配分片数据</li>
<li>按分区键的范围来分配分片数据</li>
<li>利用分区键和分片的映射表来分配分片数据//表放在缓存中</li>
</ul>
<h5><a id="%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何生成全局唯一ID</h5>
<ul>
<li>使用 auto_increment_increment 和 auto_increment_offset 参数跟分片数目相同</li>
<li>使用全局节点来生成 ID</li>
<li>在Redis等绶存服务器中创建全局ID</li>
</ul>
<h4><a id="%E6%BC%94%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>演示</h4>
<ul>
<li>oneProxyp</li>
<li><img src="media/15698792898834/15698810528098.jpg" alt="" style="width:697px;" /></li>
<li><img src="media/15698792898834/15698810874116.jpg" alt="" style="width:721px;" /></li>
<li><img src="media/15698792898834/15698811118872.jpg" alt="" style="width:492px;" /></li>
<li>节点一</li>
<li><img src="media/15698792898834/15698812390408.jpg" alt="" style="width:718px;" /></li>
<li>节点二</li>
<li><img src="media/15698792898834/15698812790906.jpg" alt="" style="width:898px;" /></li>
<li><img src="media/15698792898834/15698812971307.jpg" alt="" style="width:846px;" /></li>
<li>全局ID</li>
<li><img src="media/15698792898834/15698815144180.jpg" alt="" style="width:1288px;" /></li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>