<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	C++对象模型 -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-06T18:23:59+08:00" itemprop="datePublished">2019/08/06 18:23 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15650870393858.html" itemprop="url">
		C++对象模型入门</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内容</h4>
<ul>
<li>C++对象内部工作原理</li>
<li>底层的具体实现机制</li>
<li>提高C++开发修养</li>
<li>练习C++编程内功</li>
</ul>
<h4><a id="%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>效果</h4>
<ul>
<li>拓展眼界和思路</li>
<li>层次和能力，自信心</li>
<li>应付面试</li>
<li>空类sizeof</li>
<li>虚函数表</li>
</ul>
<h4><a id="%E7%A0%94%E7%A9%B6%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>研究内容</h4>
<ul>
<li>研究系统内部底层的各种各样的实现是如何做的</li>
<li>继承性</li>
<li>多态性</li>
</ul>
<h4><a id="%E8%AE%B2%E8%A7%A3%E5%8F%82%E7%85%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>讲解参照</h4>
<ul>
<li>深度探索C++对象模型</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-07T16:58:35+08:00" itemprop="datePublished">2019/08/07 16:58 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15651683152204.html" itemprop="url">
		对象</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%A9%BA%E9%97%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类对象空间</h4>
<ul>
<li>类的成员函数不占用类的空间，成员</li>
</ul>
<h4><a id="%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%BC%94%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对象结构的发展和演化</h4>
<ul>
<li>非静态的成员变量跟着类对象走，类对象都有自己的成员变量</li>
<li>静态成员变量不保存在类中</li>
<li>虚函数会让类多8个字节，类会产生指向虚函数的指针，有两个虚函数，类会产生两个指向虚函数的指针</li>
<li>类本身指向虚函数的指针vptr，要有地方存放，存放在一个表格，虚函数表</li>
<li>vptr由系统在适当的时机增加额外的代码来赋值</li>
<li>虚函数表是基于类的，跟对象没有关系</li>
<li>如果有多个数据成员，内存对齐</li>
</ul>
<h4><a id="%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对象模型</h4>
<ul>
<li><img src="media/15651683152204/15651729969739.jpg" alt="" style="width:752px;" /></li>
</ul>
<h4><a id="this%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>this指针</h4>
<ul>
<li>派生类对象，它是包含基类子对象、</li>
<li>派生类同时继承多个基类，第一个基类的地址和派生类地址相同</li>
</ul>
<h4><a id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构造函数语义</h4>
<ul>
<li>含成的默认构造函数，只有在必要的时候，编译器オ会为我们合成出来，而不是必然或者必须为我们合成出来</li>
<li>生成预处理文件g++ -E obj3.cpp -o obj3.i</li>
</ul>
<h4><a id="%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%95%E6%97%B6%E4%BC%9A%E6%8A%8A%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%87%BA%E6%9D%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译器何时会把默认的构造函数构造出来</h4>
<ul>
<li>任何构造国数，但包合含一个对象类型的成员而该对象所属于的类MATX 有ー个缺省的构造函数。编译器会为MBTX合成一个默认的构造函数，并且安插代码，调用MATX的缺省构造函数</li>
<li>父类带缺省的构造函数，子类没有任何构造函数，为了调用父类的构造函数</li>
<li>一个类含有虚函数，都是没有构造函数 编译器会给我们生成一全基于该类的虚函数表 vtable，把类的虚函数表地址赋值给类对象的虚函数指针</li>
<li>一个类带有虚基类</li>
<li><img src="media/15651683152204/15652598709736.jpg" alt="" style="width:452px;" /></li>
<li>虚基类结构，编译器为子类和父类都产生了默认构造函数</li>
</ul>
<pre><code class="language-plain_text"> objdump  -j .text._ZN4MBTXC2Ev -x -C obj3.o 查看构造函数
 objdump -t -C obj3.o 查看函数符号表
 objdump  -x -C obj3.o 
</code></pre>
<h4><a id="%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拷贝构造函数</h4>
<ul>
<li>合成的拷贝构造函数也是在必要的时候才会被合成出来</li>
<li>成员变量初始化手法，int简单类型直接按值拷贝过去，不需要拷贝构造</li>
</ul>
<h4><a id="%E7%BC%96%E8%AF%91%E5%99%A8%E5%90%88%E6%88%90%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译器合成的拷贝构造函数</h4>
<ul>
<li>如果一个类没有拷贝构造函数，但是含有一个类类型CTB的成员变量，该类型CTB含有拷贝构造函数，当代码中有涉及到类A的拷贝构造函数，编译器会合成构造函数</li>
<li>如果一个类没有拷贝构造函数，但是有一个父类有拷贝构造函数，当代码中有涉及到拷贝构造时，编译器会合成拷贝构造函数</li>
<li>如果类没有拷贝构造函数，但是该类声明或者继承了虚函数，编译器会自动为其构建拷贝构造函数，为了设定类对象虚函数表指针</li>
<li>如果一个类中有虚基类时，涉及到该类的拷贝构造函数，编译器会为其生成拷贝构造</li>
<li>其他编译器合成拷贝构造函数的情况</li>
</ul>
<h4><a id="%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8C%96%E8%AF%AD%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>程序转化语义</h4>
<ul>
<li>编译器对代码进行拆分，拆分成编译器更容易理解和转化的语言</li>
<li>X x100,从编译器视角来看，并没有调用构造函数</li>
<li>x100.X::X(x0)</li>
</ul>
<h5><a id="%E8%BF%94%E5%9B%9E%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>返回值初始化</h5>
<ul>
<li>linux针对返回临时对象的优化NRV和NRVO的优化</li>
<li>关闭优化g++ -o test  -fno-elide-constructors obj10.cpp</li>
<li>优化可能犯错误</li>
</ul>
<h4><a id="%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E5%BF%85%E9%A1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拷贝构造函数是否必须</h4>
<ul>
<li>如果只有一些简单的成员变量类型int,double,根本不需要拷贝构造函数，编译器本身就支持bitewise copy</li>
<li>复杂类型的成员变量需要拷贝构造函数</li>
<li>如果增加了自己的拷贝构造函数，导致编译器本身的bitewise的拷贝构造失败，需要自己在拷贝构造函数进行成员变量初始化</li>
</ul>
<h4><a id="%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员列表</h4>
<h5><a id="%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>必须使用成员列表</h5>
<ul>
<li>成员是个引用</li>
<li>成员是个const</li>
<li>类继承基类，基类中有构造函数，基类构造函数有参数</li>
<li>成员变量是类类型，构造函数也是带参数的</li>
</ul>
<h5><a id="%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用初始化列表的优势</h5>
<ul>
<li>提高程序运行效率</li>
<li>初始化列表的代码还是会到函数体中执行，初始化的列表代码会被编译器移动进函数体</li>
<li>对于类类型的成员变量的初始化放到列表效率有明显的提升</li>
<li>简单类型放在初始化列表中</li>
<li>构造函数的代码是在构造函数代码之前执行</li>
<li>列表中的初始化顺序是类中定义的顺序，编译器按定义的值来赋值</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-13T15:23:24+08:00" itemprop="datePublished">2019/08/13 15:23 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15656810044878.html" itemprop="url">
		虚函数</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E4%BD%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚表指针位置</h4>
<ul>
<li>位于对象内存的开头</li>
</ul>
<h4><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h4>
<ul>
<li>一个类只有包含虚函数才会存在虚函数表，同属于一个类的对象共享虚函数表，但是有各种的vptr，所指向的虚函数表是一样的</li>
<li>父类中有虚函数，就等于子类中有虚函数</li>
<li>只要在父类中是虚函数，在子类中不写virtual，依旧是虚函数</li>
<li>不管是父类还是子类，只会有一个虚函数表</li>
<li>子类中是否有多个虚函数表呢？//todo</li>
<li>如果子类中完全没有新的虚函数，则我们认为子类的虚函数表内容和父类完全相同，在内存中不同位置</li>
<li>虚函数表的每一项保存着一个虚函数的首地址，但是如果子类的虚函数表项和父类的表项目代表同一个函数，</li>
<li>Base base = derive,编译器并没有把子类的虚函数表指针覆盖base对象的虚函数表指针</li>
<li>面向对象和基于对象概念</li>
<li>OB执行速度很快，因为函数调用不需要运行时决定</li>
</ul>
<h4><a id="%E5%A4%9A%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多继承</h4>
<ul>
<li>类中有多个基类，则有多个虚函数表指针，对应各个基类的vptr按继承顺序依次放在类的内存空间中，且子类与第一个基类共用第一个vptr，第二个基类有自己的vptr</li>
<li><img src="media/15656810044878/15657741993732.jpg" alt="" style="width:939px;" /></li>
<li>子类对象ins有两个虚函数表指针，vptr1, vptr2</li>
<li>子类中的虚函数覆盖了父类中的同名虚函数，</li>
</ul>
<h4><a id="vptr%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vptr工具</h4>
<ul>
<li>g++ -fdump-class-hierarchy -fsyntax-only obj15.cpp</li>
</ul>
<pre><code class="language-plain_text">Vtable for Derived
Derived::_ZTV7Derived: 12u entries
0     (int (*)(...))0
8     (int (*)(...))(&amp; _ZTI7Derived)
16    (int (*)(...))Derived::f
24    (int (*)(...))Base1::g
32    (int (*)(...))Derived::i
40    (int (*)(...))Derived::mh
48    (int (*)(...))Derived::mi
56    (int (*)(...))Derived::mj
64    (int (*)(...))-8
72    (int (*)(...))(&amp; _ZTI7Derived)
80    (int (*)(...))Base2::h
88    (int (*)(...))Derived::_ZThn8_N7Derived1iEv

Class Derived
   size=16 align=8
   base size=16 base align=8
Derived (0x0x7fd61ba60380) 0
    vptr=((&amp; Derived::_ZTV7Derived) + 16u)
  Base1 (0x0x7fd61b9a1780) 0 nearly-empty
      primary-for Derived (0x0x7fd61ba60380)
  Base2 (0x0x7fd61b9a17e0) 8 nearly-empty
      vptr=((&amp; Derived::_ZTV7Derived) + 80u
</code></pre>
<h4><a id="vptr%E5%88%9B%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vptr创建</h4>
<ul>
<li>vptr跟着对象，对象创建出来就创建了</li>
<li>构造函数中有给vptr赋值信息</li>
</ul>
<h4><a id="%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚函数表</h4>
<ul>
<li>虚函数表是编译器在编译期间生成的目标文件，为每一个类确定的虚函数表的vtbl的内容</li>
<li>在编译期间添加给vptr赋值的代码信息</li>
<li><img src="media/15656810044878/processmem.png" alt="processme" /></li>
</ul>
<h4><a id="%E5%8D%95%E7%BA%AF%E7%9A%84%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单纯的类</h4>
<ul>
<li>编译器向类内部增加一些不可见但是真实存在的成员变量</li>
<li>有这种变量的类，就不单纯了</li>
<li>隐藏的成员变量增加或者使用的时机在构造函数之前执行</li>
<li>普通函数地址和虚函数地址在编译的时候就确定好的</li>
<li>静态联合编译和动态联合编译</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-15T16:18:00+08:00" itemprop="datePublished">2019/08/15 16:18 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15658570800232.html" itemprop="url">
		数据语义学</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量绑定</h4>
<ul>
<li>编译器对成员函数的解析，是在类定义完毕以后开始，对类成员变量的解析和绑定，是在类定义完成之后发生的，只有类定义完毕后，编译器才能看到类A中的成员变量</li>
<li>::引用全局的myvar的变量</li>
</ul>
<h4><a id="%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员函数</h4>
<ul>
<li>成员函数参数类型在编译器第一个遇到类型的时候绑定的</li>
<li>为了尽早的看到类型type，类型定义typedef一定要挪到类中的最早定义</li>
</ul>
<h4><a id="%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程内存空间布局</h4>
<ul>
<li>nm查看</li>
<li>类的静态成员变量也存在数据段</li>
</ul>
<h4><a id="%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字节对齐</h4>
<pre><code class="language-plain_text">#pragma pack(1) 不对齐
#pragma pack() 取消不对齐，继续对齐
</code></pre>
<h4><a id="%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%81%8F%E7%A7%BB%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员变量偏移值</h4>
<ul>
<li>&amp;class::m_val</li>
</ul>
<h4><a id="%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AD%98%E5%8F%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态成员变量存取</h4>
<ul>
<li>静态成员变量地址始终不变，写入了可执行文件</li>
</ul>
<h4><a id="%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>非静态成员变量</h4>
<ul>
<li>类对象的首地址加上成员变量的偏移值</li>
</ul>
<h4><a id="%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%B8%83%E5%B1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据成员布局</h4>
<ul>
<li>成员边界填充</li>
<li>引入继承关系，会带来额外的内存空间的开销</li>
<li>对象中会产生虚函数表指针vptr</li>
<li>增加或者扩展构造函数，增加给虚函数表指针的vptr赋值的代码</li>
<li>多重继续，子类继续2个父类，如果子类还有自己的虚函数的话和第一个基类共用vptr</li>
</ul>
<pre><code class="language-plain_text">class Base {
 public:
  int m_bi;
  char m_b;
  char m_c;
  char m_d;
};
sizeof(Base)=8字节，填充一个字节

class Base {
 public:
  int m_bi;
  char m_b;
};

class Base2 : public Base {
 public:
  char m_c;
};

class Base3 : public Base2 {
 public:
  char m_d;
};
</code></pre>
<ul>
<li><img src="media/15658570800232/15659459670117.jpg" alt="" style="width:1206px;" /></li>
<li>内存拷贝要谨慎Base2拷贝到Base3，会产生内存拷贝</li>
</ul>
<h5><a id="%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E4%B8%8D%E5%B8%A6%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%88%90%E5%91%98%E5%B8%83%E5%B1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单一继承父类不带虚函数的成员布局</h5>
<ul>
<li><img src="media/15658570800232/15659491477127.jpg" alt="" style="width:337px;" />、</li>
</ul>
<pre><code class="language-plain_text">(gdb) p  obj
$1 = (Base3) {
  &lt;Base&gt; = {
    m_bi = 1
  },
  members of Base3:
  _vptr.Base3 = 0x400a80 &lt;vtable for Base3+16&gt;,
  m_i = 2,
  m_j = 3
}
(gdb) x/12x  &amp;obj
0x7fffffffdee0: 0x00400a80      0x00000000      0x00000001      0x00000002
0x7fffffffdef0: 0x00000003      0x00000000      0x00400740      0x00000000
0x7fffffffdf00: 0xffffdff0      0x00007fff      0x00000000      0x00000000
</code></pre>
<ul>
<li>依靠偏移值不能绘制真正的数据布局</li>
<li>vptr一直置顶</li>
</ul>
<h4><a id="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多重继承</h4>
<ul>
<li><img src="media/15658570800232/15660333053268.jpg" alt="" style="width:473px;" /></li>
<li>访问Base1不用跳，访问Base2变量this指针要偏移</li>
<li>先继承就顶格</li>
<li>this指针的调整都是编译器自动调整和偏移</li>
</ul>
<pre><code class="language-plain_text">(gdb) x/20d bs2
0x7fffffffdee0: 4197896 0       12      3
0x7fffffffdef0: 6       0       -8480   32767
0x7fffffffdf00: -8208   32767   0       0
0x7fffffffdf10: 0       0       -148827179      32767
0x7fffffffdf20: 0       32      -8200   32767
(gdb) x/20d &amp;obj
0x7fffffffded0: 4197864 0       9       0
0x7fffffffdee0: 4197896 0       12      3
0x7fffffffdef0: 6       0       -8480   32767
0x7fffffffdf00: -8208   32767   0       0
0x7fffffffdf10: 0       0       -148827179      32767
Derived obj;
Base2* bs2 = &amp;obj;
Base2* bs2 = (Base2*)(((char*)&amp;obj) + sizeof(Base1))
Base1* bs1 = &amp;obj;
bs1和bs2的地址并不相同
bs2指向的是bs2子对象的指针
</code></pre>
<h4><a id="%E8%99%9A%E5%9F%BA%E7%B1%BB%E4%B8%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚基类中</h4>
<ul>
<li>传统多重继承，空间问题，效率问题，二义性</li>
<li>让grand只被继承一次，在孙子类中只有一份</li>
</ul>
<h4><a id="%E8%99%9A%E5%9F%BA%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚基类</h4>
<ul>
<li>虚基类表</li>
<li>虚基类表指针</li>
<li>虚继承后，A1,A2会被插入一个虚基类表指针，C1会继承两个表指针</li>
<li><img src="media/15658570800232/15661179666970.jpg" alt="" style="width:725px;" /></li>
<li><img src="media/15658570800232/15661193718967.jpg" alt="" style="width:427px;" /></li>
<li>虚基类表记录偏移来找到虚基类子对象</li>
<li>虚基类表指针成员变量的首地址 + 偏移量 = 虚基类对象首地址</li>
</ul>
<h4><a id="%E8%A7%82%E5%AF%9F%E5%90%84%E7%A7%8D%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>观察各种继承</h4>
<ul>
<li>虚基类表的偏移值</li>
<li>虚基类表中的偏移量按照继承顺序来存放</li>
<li>虚基类子对象一直放在最下面</li>
</ul>
<h4><a id="%E8%99%9A%E5%9F%BA%E7%B1%BB1-4%E5%AD%97%E8%8A%82%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚基类1-4字节分析</h4>
<ul>
<li>虚基类表指针成员变量的首地址，和本对象A1首地址的偏移量，也就是虚基类表指针 - A1的对象的首地址</li>
<li>只有对虚基类成员进行赋值的时候，才会用到虚基类</li>
</ul>
<h4><a id="%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%E5%86%85%E5%AE%B9%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三层结构虚基类表内容分析</h4>
<ul>
<li><img src="media/15658570800232/15662039845414.jpg" alt="" style="width:743px;" /></li>
<li>虚基类在编译的时候已经固定了</li>
<li>vptr2基本没用到只用到vptr1</li>
<li>访问虚基类的成员变量要比普通成员变量慢</li>
</ul>
<h4><a id="%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%81%8F%E7%A7%BB%E5%92%8C%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员变量地址，偏移和指针</h4>
<h4><a id="%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%81%8F%E7%A7%BB%E5%80%BC%E5%92%8C%E5%81%8F%E7%A7%BB%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员变量偏移值和偏移指针</h4>
<ul>
<li>和具体对象没有关系</li>
<li>成员变量指针保存的是一个偏移值，不是实际内存地址</li>
<li>没有指向任何数据成员的指针</li>
</ul>
<pre><code class="language-plain_text">int main() {
  Obj obj;
  obj.m_i = obj.m_j = obj.m_k = 0;
  printf(&quot;mi = %p \n&quot;, &amp;obj.m_i);

  Obj* p = &amp;obj;
  printf(&quot;mi = %p \n&quot;, p-&gt;m_i);
  printf(&quot;mj = %p \n&quot;, p-&gt;m_j);

  int* p1 = &amp;obj.m_i;
  int* p2 = &amp;obj.m_j;

  *p1 = 15;
  *p2 = 30;
  printf(&quot;p1 = %p  p1 val %d \n&quot;, p1, *p1);
  printf(&quot;p2 = %p  p2 val %d \n&quot;, p2, *p2);

  printf(&quot;m_i offset %d \n&quot;, &amp;Obj::m_i);
  printf(&quot;m_j offset %d \n&quot;, &amp;Obj::m_j);
  printf(&quot;m_k offset %d \n&quot;, &amp;Obj::m_k);


  int Obj::*ptr = &amp;Obj::m_i;
  printf(&quot;m_k offset %d \n&quot;, ptr);
  obj.*ptr = 13;
  p-&gt;*ptr = 20;
  ptr = nullptr; 编译器会把ptr设置为-1
  ptr += 1//不允许
}
</code></pre>
<ul>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-20T15:39:54+08:00" itemprop="datePublished">2019/08/20 15:39 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15662867942391.html" itemprop="url">
		函数语义学</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员函数的调用方式</h4>
<ul>
<li>成员函数的调用转换成了全局的函数</li>
<li>成员函数有独立的内存地址，跟着类走的，成员函数的地址是编译时确定好的</li>
<li>编译器额外增加了一个this形参，指向生成的对象</li>
<li>常规成员变量的存取，都通过形参来进行。比如this-&gt;m_i</li>
</ul>
<h4><a id="%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚函数调用</h4>
<pre><code class="language-plain_text">  class Obj{
 public:
  int m_i;
  void func(int abc) {
    m_i += abc;
  }
  void virtual virfunc1() {
    virfunc2(); //通过虚函数表指针来寻址
    Obj::virfunc2(); //效率高, 等价于调用普通函数
  }
  void virtual virfunc2() {}
};
pmyacls-&gt;myvirfunc(); //要通过虚函数表指针查找虚函数表，通过虚函数表在好到虚函数的入口地址，完成对虚函数的调用
	//编译器视角
	//(*pmyacls-&gt;vptr[0])(pmyacls);
	//a)vptr，编译器给生成的虚函数表指针，指向虚函数表
	//b)[0] 虚函数表中第一项。代表myvirfunc()地址
	//c)传递一个参数进去，就是this，也是编译器给加的
	//d)*就得到了虚函数的地址
</code></pre>
<h4><a id="%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态函数</h4>
<ul>
<li>各种调用方式都是类名调用</li>
<li>静态函数不需要this指针</li>
</ul>
<pre><code class="language-plain_text">void func(int abc) {
    //m_i += abc;
    printf(&quot;func&quot;);
}
((Obj *)0)-&gt;func(2);可以执行
希望成员函数支持类对象之外的存取操作
//静态成员函数特性
	//a)静态成员函数没有this指针，这点最重要
	//b)无法直接存取类中普通的非静态成员变量；
	//c)静态成员函数不能在屁股后使用const，也不能设置为virtual 
	//d)可以用类对象调用，但不非一定要用类对象调用。
	//e)静态成员函数等同于非成员函数，有的需要提供回调函数的这种场合，可以将静态成员函数作为回调函数；
</code></pre>
<h4><a id="%E7%BB%A7%E6%89%BF%E7%9A%84%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0%E5%9D%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>继承的非虚函数坑</h4>
<pre><code class="language-plain_text"> Derive derive;
	Derive *pderive = &amp;derive;
	pderive-&gt;myfunc(); //Derive::myfunc()子类

	Base *pbase = &amp;derive;
	pbase-&gt;myfunc();//调用父类
</code></pre>
<ul>
<li>普通成员函数是静态绑定，换句话说，myfunc() 是普通成员函数。这里到底调用父类的myfunc还是子类的myfunc取决于调用者的静态类型；</li>
</ul>
<h4><a id="%E8%99%9A%E5%87%BD%E6%95%B0%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E5%9D%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚函数缺省参数的动态坑</h4>
<pre><code class="language-plain_text">class Base
{
public:
	void myfunc() //普通成员函数
	{
		cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl;
	}
	virtual void myvirfunc(int value = 1)
	{
		cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;
	}
};
class Derive :public Base
{
public:
	void myfunc() //普通成员函数
	{
		cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl;
	}
	virtual void myvirfunc(int value = 2)
	{
		cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;
	}
};
</code></pre>
<ul>
<li>虚函数缺省参数是静态绑定，考虑到执行效率的问题</li>
<li>不要重新定义虚函数缺省参数的值</li>
<li>不应该在子类中重新定义一个继承来的非虚函数</li>
</ul>
<h4><a id="%E5%A4%9A%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多态</h4>
<ul>
<li>调用虚函数没有查询虚函数表，不一定是多态</li>
<li>有继承关系</li>
<li>父类指针或者引用指向子类对象</li>
<li>派生类重写了子类的虚函数</li>
</ul>
<h4><a id="%E5%8D%95%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单继承</h4>
<pre><code class="language-plain_text">Base* pb = new Derived()
pb-&gt;g()
编译器视角
(*pb)-&gt;vptr[1](pb)
</code></pre>
<ul>
<li>执行期间需要确定的就是哪个虚函数表来调用虚函数</li>
</ul>
<h4><a id="%E5%9B%9E%E9%A1%BE%E5%92%8C%E4%B8%80%E4%BA%9B%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>回顾和一些测试</h4>
<ul>
<li>虚函数地址，编译期间确认下来</li>
<li>顺序记录每个虚函数的地址</li>
<li>vptr编译期间产生，编译器在构造函数中插入了给vptr赋值的代码。</li>
<li>纯虚函数依然会在虚函数表中占据一个表项目</li>
</ul>
<h4><a id="%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E7%AC%AC%E4%BA%8C%E5%9F%BA%E7%B1%BB%EF%BC%8C%E8%99%9A%E6%9E%90%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多继承虚函数，第二基类，虚析构</h4>
<pre><code class="language-plain_text">Base* pb2 = new Derived()
Derived* tmp = new Derived()
Base2* pb2 = (Base2*)((char*)tmp + sizeof(Base))
</code></pre>
<ul>
<li>如何成功删除用第二基类指针new出来的继承类对象</li>
<li>非虚析构函数仍然是个普通析构函数，系统释放的是pb2开头的内存仍然异常</li>
<li>Base2有个虚的析构函数则编译器实际执行~Derived(),~Base2(),Base()</li>
<li>Derived没有虚析构函数，编译器会为其合成虚析构函数，虚析构函数名可以跟父类不一样</li>
<li><img src="media/15662867942391/15663764207329.jpg" alt="" style="width:1174px;" /></li>
</ul>
<h4><a id="thunk" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>thunk</h4>
<ul>
<li>汇编代码</li>
<li>在多重继承中用于this指针调整</li>
<li>调用Derived析构函数</li>
</ul>
<pre><code class="language-plain_text">0000000000000044 &lt;non-virtual thunk to Derive::~Derive()&gt;:
  44:   48 83 ef 08             sub    rdi,0x8 this指针指向derived对象首地址
  48:   eb b6                   jmp    0 &lt;Derive::~Derive()&gt;
000000000000002b &lt;non-virtual thunk to Derive::~Derive()&gt;:
  2b:   48 83 ef 08             sub    rdi,0x8
  2f:   eb cf                   jmp    0 &lt;Derive::~Derive()&gt;
</code></pre>
<ul>
<li><img src="media/15662867942391/15663775575835.jpg" alt="" style="width:1112px;" /></li>
</ul>
<h4><a id="%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%AC%AC%E4%BA%8C%E5%9F%BA%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E6%94%AF%E6%8C%81%E5%92%8C%E8%99%9A%E7%BB%A7%E6%89%BF%E5%B8%A6%E8%99%9A%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多继承第二基类虚函数支持和虚继承带虚函数</h4>
<p>通过指向第二个基类的指针调用继承类的虚函数；<br />
Base2 *pb2 = new Derive();<br />
delete pb2; 调用继承类的虚析构函数<br />
一个指向派生类的指针，调用第二个基类中的虚函数<br />
Derive *pd2 = new Derive();<br />
pd2-&gt;hBase2();<br />
允许虚函数的返回值类型有所变化<br />
Base2 *pb1 = new Derive(); pb1指向的是Base2子对象的首地址<br />
Base2 *pb2 = pb1-&gt;clone(); Derive::clone();<br />
执行clone()时，pb1首先会调整回指向Derivce对象的首地址，这样调用的是Derive版本的clone()</p>
<h4><a id="%E8%99%9A%E7%BB%A7%E6%89%BF%E5%B8%A6%E8%99%9A%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚继承带虚函数</h4>
<ul>
<li><img src="media/15662867942391/15663819139099.jpg" alt="" style="width:378px;" /></li>
</ul>
<h4><a id="rtti" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RTTI</h4>
<ul>
<li>RTTI实现原理 typeid返回的是一个常量对象的引用，这个常量对象的类型一般是type_info（类）</li>
<li><img src="media/15662867942391/15664624057485.jpg" alt="" style="width:1035px;" /></li>
<li>vptr vtbl rtti的 type_info信息编译之后就存在</li>
</ul>
<h4><a id="%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译器优化</h4>
<ul>
<li>优化循环，把循环优化成1条语句；</li>
<li>在编译期间，编译器也具有运算能力，有些运算编译器在编译期间就能搞定；</li>
</ul>
<h4><a id="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多重继承</h4>
<ul>
<li>继承关系深度增加，开销一般也会增加</li>
<li>很多情况下，随着继承深度的增加，开销或者说执行时间也会增加；</li>
<li>多重继承一般也会导致开销增加</li>
</ul>
<h4><a id="%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88vall" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员函数指针&amp;&amp;vall</h4>
<ul>
<li>通过成员函数指针对常规的成员函数调用的成本，和通过普通的函数指针来调用静态成员函数，成本上差不多；</li>
<li>成员函数指针里保存的是vcall = virtual call 虚调用(vcall trunk)地址</li>
<li>直接把vcall看成虚函数表vcall{0}代表的就是虚函数表里的第一个函数，vcall{4}就代表虚函数表里的第二个虚函数</li>
<li>vcall地址就是虚函数在虚函数表中的偏移值，结合对象指针，就能确定具体的虚函数地址</li>
<li>成员函数地址是真正的地址</li>
</ul>
<h4><a id="inline%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>inline函数</h4>
<ul>
<li>inline会导致编译器内部有一个比较复杂的测试算法来评估这个inline函数的复杂度</li>
<li>赋值次数和内部函数调用，调用次数</li>
<li>开发者写的inline只是对编译器的建议</li>
<li>inline会带来额外的问题，比如函数求值，临时对象的生成和管理</li>
<li>局部变量的引入，能少用就尽量少用，能不用就不用</li>
<li>10行以内，少用循环</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-24T16:41:17+08:00" itemprop="datePublished">2019/08/24 16:41 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15666360771756.html" itemprop="url">
		对象构造语义学</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对象构造</h4>
<ul>
<li>构造函数中你自己的代码中使用诸如memcpy或者直接操作等手段，来修改虚函数表指针的值，否则，调用虚函数时就可能造成系统崩溃；</li>
</ul>
<h4><a id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AF%B9%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构造函数对虚函数的调用</h4>
<ul>
<li>某个类的构造函数 中 调用一个虚函数，那么走的不是虚函数表，而是直接调用。</li>
<li>从类中开始找，然后在父类中找</li>
</ul>
<h4><a id="%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89%E5%AD%A6%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89%E5%AD%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对象复制语义学，析构函数语义学</h4>
<ul>
<li>默认的对象赋值行为</li>
</ul>
<h4><a id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AF%AD%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>析构函数语义</h4>
<ul>
<li>析构函数被合成</li>
</ul>
<h5><a id="%E5%90%88%E6%88%90%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>合成情况</h5>
<ul>
<li>继承一个基类，基类带析构函数，编译器会帮忙合成</li>
<li>如果类成员是一个类类型成员，成员带析构函数，编译器会合成一个析构函数</li>
</ul>
<h5><a id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%A2%AB%E6%89%A9%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>析构函数被扩展</h5>
<ul>
<li>如果我们有自己的析构函数，编译器会扩展析构函数</li>
<li>如果类成员是一个类类型成员，并且自带析构函数，编译器会扩展类A的析构函数代码</li>
<li>先执行类A的析构函数，再执行成员函数析构函数</li>
<li>如果继承一个基类，基类中带析构函数，编译器会扩展A类的析构函数来调用基类的析构函数</li>
<li>虚基类扩展</li>
</ul>
<h4><a id="%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>局部对象和全局对象的构造和析构</h4>
<ul>
<li>全局对象构造和析构的步骤：<br />
a)全局对象g_aobj获得地址（编译时确定好的，内存也是编译时分配好的，内存时运行期间一直存在）<br />
b)把全局对象g_aobj的内存内容清0的能力（也叫静态初始化）<br />
c)调用全局对象g_aobj所对应的类A的构造函数</li>
<li>如何保证静态局部对象只被构造一次</li>
<li>编译器通过设置标记的方式</li>
<li>如何来析构局部对象</li>
<li>局部静态对象只会被构造一次，在调用的时候构造；在main函数执行完毕后析构</li>
</ul>
<h4><a id="malloc" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>malloc</h4>
<ul>
<li>分配0个字节</li>
</ul>
<h4><a id="new%E5%92%8Cdelete%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A4%E8%AF%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>new和delete进一步认识</h4>
<ul>
<li>A *pa = new A()会清零部分内存，如果有构造函数则不会清零</li>
<li>A *pa = new A不会清零</li>
</ul>
<h4><a id="new%E5%B9%B2%E4%BA%86%E5%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>new干了啥</h4>
<ul>
<li>operator new</li>
<li>malloc</li>
<li>A::A()</li>
</ul>
<h4><a id="delete" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>delete</h4>
<ul>
<li>A::~A()</li>
<li>operator delete()</li>
<li>free</li>
</ul>
<h4><a id="%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>嵌入式指针</h4>
<ul>
<li>一般应用在内存池代码</li>
<li>成功使用有个前提条件</li>
<li>借用了A对象占用的内存空间的前四个字节，4个字节用来链住空闲的内存块，一旦被分配</li>
<li>出去，这个块的前四个字节就不再需要，四个字节就可以使用</li>
</ul>
<pre><code class="language-plain_text">struct obj {
  struct obj* next; //next就是个嵌入式指针
}
</code></pre>
<h4><a id="placement-new" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>placement new</h4>
<ul>
<li>只有new没有delete</li>
<li>在已经分配的原始内存中初始化一个对象</li>
<li>定位new不分配内存</li>
<li>初始化对象</li>
<li>在预先分配号的内存中分配一个对象</li>
<li>new (address) 类类型</li>
</ul>
<pre><code class="language-plain_text">void *memPtr = (void*)new char[sizeof(A)];
  A* obj = new (memPtr) A();

  void *memPtr2 = (void*)new char[sizeof(A)];
  A* obj2 = new (memPtr2) A();

  obj-&gt;~A();
  obj2-&gt;~A();

  delete[](void*)obj;
  delete[](void*)obj2;
</code></pre>
<h4><a id="%E5%A4%9A%E7%89%88%E6%9C%AC%E7%9A%84operator-new" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多版本的operator new</h4>
<ul>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-28T15:44:04+08:00" itemprop="datePublished">2019/08/28 15:44 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15669782449531.html" itemprop="url">
		对象模型之巅</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数模板</h4>
<ul>
<li>针对T的类型推断，是编译器在编译的时候，根据针对funcadd的调用来确定的</li>
</ul>
<h4><a id="%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员函数实例化</h4>
<ul>
<li></li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>