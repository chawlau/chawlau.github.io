<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	RabbitMQ -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2022-09-26T11:04:24+08:00" itemprop="datePublished">2022/09/26 11:04 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16641614646449.html" itemprop="url">
		思维导图</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><img src="media/16641614646449/16641614685217.jpg" alt="" /></p>
<h4><a id="%E9%97%AE%E9%A2%98%E5%BD%92%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题归类</h4>
<ul>
<li>() Kafka、RabbitMQ 他们有类似的数据分片机制吗？他们是如何把一个逻辑上的数据集合概念（比如一个 Topic）给在物理上拆分为多个数据分片的？然后拆分后的多个数据分片又是如何在物理的多台机器上分布式存储的？</li>
</ul>
<p>(2) 为什么一定要让 MQ 实现数据分片的机制？如果不实现数据分片机制，让你来设计 MQ 中一个数据集合的分布式存储，你觉得好设计吗？</p>
<p>(3) 同步刷盘和异步刷盘两种策略，分别适用于什么不同的场景呢？</p>
<p>(④）异步刷盘可以提供超高的写入吞吐量，但是有丢失数据的风险，这个适用于什么业务场景？在你所知道的业务场景，或者工作接触过的业务场景中，有哪些场景需要超高的写入吞吐量，但是可以适度接受数据丢失？</p>
<p>(5) 同步刷盘会大幅度降低写入吞吐量，但是可以让你的数据不丢失，你接触哪些场景，是严格要求数据务必不能丢失任何一条，但是吞吐量并没有那么高的呢？</p>
<p>(⑥) Kafka、RabbitMQ 他们的 brokerl 收到消息之后是如何写入磁盘的？采用的是同步刷盘还是异步刷盘的策略？为什么？</p>
<p>(7) 每次写入都必须有超过半数的 Follower Broker 都写入消息才可以算做一次写入成功，那么大家思考一个问题，这样做是不是会对 Leader Broker 的写入性能产生影响？是不是会降低 TPS？是不是必须要在所有的场景都这么做？为什么呢？</p>
<p>(8) 一般我们获取到一批消息之后，什么时候才可以认为是处理完这批消息了？是刚拿到这批消息就算处理完吗？还是说要对这批消息执行完一大堆的数据库之类的操作，才算是处理完了？</p>
<p>(⑨）如果获取到了一批消息，还没处理完呢，结果机器就宕机了，此时会怎么样？这些消息会丢失，再也无法处理了吗？如果获取到了一批消息，已经处理完了，还买来得及提交消费进度，此时机器宕机了，会怎么样呢？</p>
<p>(10) 消费者机器到底是跟少数几台 Broker3 建立连接，还是跟所有 Broker 都建立连接？这是不少朋友之前在评论区提出的问题，但是我想这里大家肯定都有自己的答案了。</p>
<p>(11) RocketMQ 是支持主从架构下的读写分离的，而且什么时候找 Slave Brokeri 读取大家也都了解的很清楚了，那么大家思考一下，Kafka、RabbitMQ 他们支持主从架构下的读写分离吗？支持 Slave Broker 的读取吗？为什么呢？</p>
<p>(12) 如果支持读写分离的话，有没有一种可能，就是出现主从数据不一致的问题？比如有的数据刚刚到 Master Broker 和部分 Slave Broker，但是你刚好是从那个没有写入数据的 Slave Broker 去读取了？</p>
<p>(13) 消费吞吐量似乎是跟你的处理速度有很大关系，如果你消费到一批数据，处理太慢了，会导致你严重跟不上数据写入的速度，这会导致你后续几乎每次拉取数据都会从磁盘上读取，而不是 os cache！里读取，所以你觉得你在拉取到一批消息处理的时候，应该有哪些要点需要注意的？</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-15T06:45:55+08:00" itemprop="datePublished">2019/09/15 06:45 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15685011552675.html" itemprop="url">
		消息中间件</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%B8%BB%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主流中间件</h4>
<ul>
<li>kafka 对消息的重复、丢失、错误没有严格要求 专注高性能</li>
<li>RocketMQ 事务</li>
<li>NameServer源代码</li>
<li>RabbitMQ 数据一致性 稳定性 可靠性要求很高， 性能和吞吐量在其次</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-15T06:57:44+08:00" itemprop="datePublished">2019/09/15 06:57 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15685018644152.html" itemprop="url">
		RabbitMQ和AMQP协议</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li>导航<br />
<img src="media/15685018644152/15685019251376.jpg" alt="" style="width:788px;" /><br />
<img src="media/15685018644152/15685019353551.jpg" alt="" style="width:864px;" /><br />
<img src="media/15685018644152/15685019742034.jpg" alt="" style="width:912px;" /></li>
</ul>
<h4><a id="%E5%88%9D%E5%A7%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始</h4>
<ul>
<li>优点</li>
<li>集群模式丰富，表达式配置，HA 模式，镜像队列模型 √保证数据不丟失的前提做到高可靠性、可用性</li>
</ul>
<h4><a id="%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高性能原因</h4>
<ul>
<li>Erlang 语言最初在于交换机领域的架构模式，这样使得 Rabbitmq 在 Broker 之间进行数据交互的性能是非常优秀的</li>
<li>Erlang 的优点：Erlang 有着和原生 Socket-样的延迟</li>
</ul>
<h4><a id="amqp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AMQP</h4>
<ul>
<li><img src="media/15685018644152/15685025982263.jpg" alt="" style="width:1087px;" /></li>
<li>Server：又称 Broker，接受客户端的连接，实现 AMQP 实体服务</li>
<li>Connection：连接，应用程序与 Broker 的网络连接</li>
<li>Channel：网络信道，几乎所有的操作都在 Channels 中进行，Channel 是进行消息读写的通道。客户端可建立多个 hannel，每个 Channel 代表一个会话任务。</li>
<li>Message：消息、服务器和应用程序之间传送的数据，由 Properties 和 Body 组成。Properties 可以对消息进行修饰，比如消息的优先级延迟等高级特性；Body 则就是消息体内容。</li>
<li>Virtual host：虚拟地址，用于进行逻辑隔离，最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue，同一个 Virtual Host 里面不能有相同名称的 Exchange 或 Queue</li>
<li>Exchange 交换机，接收消息，根据路由键转发消息到绑定的队列</li>
<li>Binding: Exchange 和 Queue 之间的虚拟连接，binding 中可以包含 routing key</li>
<li>Routing Key 路由规则，虚拟机可用它来确定如何路由一个特定消息</li>
<li>Queue：也称为 Message Queue，消息队列，保存消息并将它们转发给消费者</li>
</ul>
<h4><a id="%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整体架构</h4>
<ul>
<li><img src="media/15685018644152/2018-12-12%2017-01-57%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="2018-12-12 17-01-57 的屏幕截图" /></li>
<li><img src="media/15685018644152/15685032427468.jpg" alt="" style="width:1095px;" /></li>
<li><img src="media/15685018644152/15685033008191.jpg" alt="" style="width:1125px;" /></li>
<li>生产者无需关系消息投递到哪个队列，消费者无须知道消息从哪个exchange来</li>
<li></li>
</ul>
<h4><a id="%E5%AE%89%E8%A3%85rabbitmq" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装rabbitmq</h4>
<ul>
<li><img src="media/15685018644152/15685094890042.jpg" alt="" style="width:477px;" /></li>
</ul>
<h4><a id="%E5%91%BD%E4%BB%A4%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命令行</h4>
<ul>
<li><img src="media/15685018644152/15685919640494.jpg" alt="" style="width:1284px;" /></li>
<li>rabbitmqctl list user permissions username：列出用户权限</li>
<li>rabbitmqctl change_ password username newpassword：修改密码</li>
<li>rabbitmqctl set permissions-p vhostpath username &quot;.<em>&quot; &quot;.</em>&quot; &quot;.*&quot; 设置用户权限</li>
<li>Rabbitmqctl add vhost vhostpath：创建虚拟主机</li>
<li>rabbitmgctl list vhosts：列出所有虚拟主机</li>
<li>rabbitmqctl list permissions- o vhostpath：列出虚拟主机上所有权限</li>
<li>rabbitmqctl delete_ vhost vhostpath：删除虚拟主机</li>
<li>rabbitmqctl reset</li>
<li>Rabbitmactl join cluster <clusternode> [--ram][--disc]：组成集群命令</li>
<li>rabbitmqctl cluster_status</li>
<li>rabbitmactl change cluster node type disc ram</li>
<li>rabbitmactl forget cluster node [-offline] 忘记节点（摘除节点)</li>
<li></li>
</ul>
<h4><a id="import-export" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>import&amp;export</h4>
<ul>
<li>批量导出配置文件</li>
</ul>
<h4><a id="%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生产者和消费者</h4>
<ul>
<li>消费端一定要创建consumer,声明消费队列</li>
<li>没有指定exchange,就会使用默认的路由规则</li>
</ul>
<h4><a id="exchange%E4%BA%A4%E6%8D%A2%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exchange交换机</h4>
<ul>
<li><img src="media/15685018644152/15686780874004.jpg" alt="" style="width:1196px;" /></li>
<li>蓝色表示SendMessage</li>
<li>绿色表示RecvMessage</li>
<li>黄色表示routing-key</li>
</ul>
<h5><a id="%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>交换机属性</h5>
<ul>
<li>Name：交换机名称</li>
<li>Type：交换机类型 direct、topic、fanout、headers</li>
<li>Durability 是否需要持久化，true 为持久</li>
<li>Auto Delete：当最后一个绑定到 Exchange 上的队列删除后，自动删除该 Exchange</li>
<li>Internal：当前 Exchange 是否用于 Rabbit MQP 内部使用，默认为 False</li>
<li>Arguments：扩展参数，用于扩展 AMQP 协议自制定化使用</li>
</ul>
<h5><a id="direct-exchange" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Direct Exchange</h5>
<ul>
<li>所有发送到 Direct Exchange 的消息被转发到 Routekey 中指定的 Queue</li>
<li>注意：Directa 模式可以使用 Rabbitmq 自带的 Exchange: default Exchange，所以不需要将 Exchange 进行任何绑定（binding）操作，消息传递时，Routekey 必须完全匹配才会被队列接收，否则该消息会被抛弃</li>
<li><img src="media/15685018644152/15686783728891.jpg" alt="" style="width:1301px;" /></li>
<li><img src="media/15685018644152/15713502113780.jpg" alt="" style="width:1426px;" /></li>
</ul>
<h5><a id="topic-exchange" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Topic Exchange</h5>
<ul>
<li>所有发送到 Topic Exchangee 的消息被转发到所有关心 Route Keyi 中指定 Topic 的 Queue 上</li>
<li>Exchange 将 Routekey 和某 Topic 进行模糊匹配，此时队列需要绑定一个 Topic</li>
<li><img src="media/15685018644152/15687601895357.jpg" alt="" style="width:984px;" /></li>
<li><img src="media/15685018644152/15687602026259.jpg" alt="" style="width:1131px;" /></li>
</ul>
<h4><a id="fanout-exchange" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fanout Exchange</h4>
<ul>
<li>不处理路由键，只需要简单的将队列绑定到交换机上</li>
<li>发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</li>
<li>Fanout 交换机转发消息是最快的</li>
<li><img src="media/15685018644152/15687618674083.jpg" alt="" style="width:1081px;" /></li>
</ul>
<h4><a id="binding" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Binding</h4>
<ul>
<li>Exchange？和 Exchange、Queue 之间的连接关系</li>
<li>Binding 中可以包含 Routing keyi 或者参数</li>
</ul>
<h4><a id="queue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Queue</h4>
<ul>
<li>消息队列，实际存储消息数据</li>
<li>Durability：是否持久化，Durable：是，Transient：否</li>
<li>Auto delete：如选 yes，代表当最后一个监听被移除之后</li>
<li>该 Queue 会自动被删除</li>
</ul>
<h4><a id="message" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Message</h4>
<ul>
<li>服务器和应用程序之间传送的数据</li>
<li>本质上就是一段数据，由 Properties 和 Payload (Body）组成</li>
<li>常用属性：delivery mode、headers（自定义属性</li>
<li>Content type、content encoding、priority correlation id、reply to、expiration、message_id timestamp、type、user-id、app_id、cluster id</li>
<li>correlation_id比较重要</li>
</ul>
<h4><a id="virtual-host" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Virtual host</h4>
<ul>
<li>虚拟地址，用于进行逻辑隔离，最上层的消息路由</li>
<li>一个 Virtual Host 里面可以有若干个 Exchange 和 Queue</li>
<li>同一个 Virtual Host 里面不能有相同名称的 Exchange 或 Queue</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-22T06:08:57+08:00" itemprop="datePublished">2019/09/22 06:08 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15691037377724.html" itemprop="url">
		SET架构</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8D%95%E5%85%83%E9%9B%86%E7%BE%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单元集群</h4>
<ul>
<li>随着大型互联网公司业务的多元化发展，就拿滴滴、美团等大厂来讲，如滴滴打车、单车、外卖、酒店、旅行、金融等业务持续高速增长，单个大型分布式体系的集群，通过加机器+集群内部拆分（kv、mq、MYSQLS 等），虽然具备了一定的可扩展性。但是，随着业务量的进一步增长，整个集群规模逐渐变得巨大，从而一定会在某个点上达到瓶颈，无法满足扩展性需要，并且大集群内核心服务出现问题，会影响全网所有用户。</li>
</ul>
<h4><a id="%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>大型分布式集群问题</h4>
<ul>
<li>容灾问题</li>
<li>核心服务（比如订单服务）挂掉，会影响全网所有用户导致整个业务不可用；<br />
数据库主库集中在一个 IDC，主机房挂掉，会影响全网所有用户，整个业务无法快速切换和恢复</li>
<li>资源扩展问题</li>
<li>单 IDC 的资源（机器、网络带宽等）已经没法满足，扩展 IDC 时，存在跨机房访问时延问题（增加异地机房时，时延问题更加严重）；数据库主库单点，连接数有限，不能支持应用程序的持续扩展</li>
<li>大集群拆分问题</li>
<li>核心问题：分布式集群规模扩大后，会相应的带来资源扩展大集群拆分以及容灾问题。<br />
所以出于对业务扩展性以及容灾需求的考虑，我们需要一套从底层架构彻底解决问题的方案，业界主流解决方案</li>
</ul>
<h5><a id="%E5%90%8C%E5%9F%8E%E5%8F%8C%E6%B4%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>同城双活</h5>
<ul>
<li>业务层面上已经做到真正的双活（或者多活），分别承担部分流量存储层面比如定时任务、缓存、持久层、数据分析等都是主从架构，会有跨机房写</li>
<li>个数据中心故障，可以手动切换流量，部分组件可以自动切换</li>
</ul>
<h5><a id="%E4%B8%A4%E5%9C%B0%E4%B8%89%E4%B8%AD%E5%BF%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>两地三中心</h5>
<ul>
<li>使用灾备的思想，在同城“双活”的基础上，在异地部署一套灾备数据中心，每个中心都具有完备的数据处理能力，只有当主节点故障需要容灾的时候才会紧急启动备用数据中心</li>
<li><img src="media/15691037377724/15691042588639.jpg" alt="" style="width:1163px;" /></li>
</ul>
<h4><a id="set%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E7%9B%AE%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SET优化方案目标</h4>
<ul>
<li>业务：解决业务遇到的扩展性和容灾等需求，支撑业务的高速发展</li>
<li>通用性：架构侧形成统一通用的解決方案，方便各业务线接入使用</li>
</ul>
<h4><a id="set%E5%8C%96%E6%9E%B6%E6%9E%84%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SET化架构策略</h4>
<ul>
<li><img src="media/15691037377724/15691044588654.jpg" alt="" style="width:1247px;" /></li>
</ul>
<h5><a id="%E6%B5%81%E9%87%8F%E8%B7%AF%E7%94%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>流量路由</h5>
<ul>
<li>按照特殊的 key（通常为 userid）进行路由，判断某次请求该路由到中心集群还是单元化集群</li>
</ul>
<h5><a id="%E4%B8%AD%E5%BF%83%E9%9B%86%E7%BE%A4%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中心集群：</h5>
<ul>
<li>未进行单元化改造的服务（通常不在核心交易链路，比如供应链系统）称为中心集群，跟当前架构保持一致</li>
</ul>
<h5><a id="%E5%8D%95%E5%85%83%E5%8C%96%E9%9B%86%E7%BE%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单元化集群</h5>
<ul>
<li>每个单元化集群只负责本单元内的流量处理，以实现流量拆分以及故障隔离</li>
<li>每个单元化集群前期只存储本单元产生的交易数据，后续会做双向数据同步，实现容灾切换需求</li>
</ul>
<h5><a id="%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中间件策略</h5>
<ul>
<li>中间件（RPC、KV、MQ 等）</li>
<li>RPC：对于 SET 服务，调用封闭在 SET 内；对于非 SET 服务，沿用现有路由逻辑</li>
<li>KV：支持分 SET 的数据生产和査询 MQ：支持分 SET 的消息生产和消费</li>
</ul>
<h5><a id="%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据同步</h5>
<ul>
<li>全局数据（数据量小且变化不大，比如商家的菜品数据）部署在中心集群，其他单元化集群同步全局数据到本单元化内；未来演变为昇地多活架构时，各单元化集群数据需要进行双向同步来实现容灾需要</li>
</ul>
<h5><a id="%E8%83%BD%E5%8A%9B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>能力</h5>
<ul>
<li>通过 SET 化架构的流量调度能力，将 SET 分别部署在不同地区的数据中心，实现跨地区容灾支持</li>
<li>利用前端位置信息采集和域名解析簽略，将流量路由到最近的 SET，提供最高效的本地化服务；</li>
<li>集装箱式扩展</li>
<li>SET 的封装性支持更灵活的部署扩展性，比如 SET 一键创 建/下线,SET一键发布等</li>
<li><img src="media/15691037377724/15691052560100.jpg" alt="" style="width:1077px;" /></li>
<li><img src="media/15691037377724/15691053560728.jpg" alt="" style="width:1277px;" /></li>
</ul>
<h4><a id="set%E5%8C%96%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SET化架构原则</h4>
<ul>
<li>对业务透明原则</li>
<li>SET 化架构的实现对业务代码透明，业务代码层面不需 要关心 SET 化规则，SET 的部署等问题</li>
<li>理论上，切分规则由业务层面按需定制 y 实现上，建议优先选最大的业务维度进行切分；</li>
<li>比如海量用户的 O20 业务，按用户位置信息进行切分。此外</li>
<li>接入层、逻辑层和数据层可以有独立的 SET 切分规则，有利于实现部署和运维成本的最优化。</li>
<li>部署规范原则</li>
<li>一个 SET 并不ー定只限制在一个机房，也可以跨机房或者</li>
<li>跨地区部署；为保证灵活性，单个 SET 内机器数不宜过多（如如不超过 1000 台物理机）</li>
</ul>
<h4><a id="rabbitmq-set" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rabbitmq-SET</h4>
<ul>
<li><img src="media/15691037377724/15691056825704.jpg" alt="" style="width:1367px;" /></li>
<li>集群之间Federation</li>
<li>rabbitmg-plugins enable rabbitmq federation</li>
<li>rabbitmq-plugins enable rabbitmq federation management</li>
<li>使用 Rabbitmq 通信插件 Federation</li>
<li>Federation 插件是一个在不需要 cluster，而 brokers之间传输消息的高性能插件。</li>
<li>Federation 插件可以在 brokers 或者 cluster 之间传输消息，链接的双方可以使用不同的 users 和 virtual hosts、或者双方的 rabbitmq和 erlang 版本不一致，federation 插件使用 AMQP 协议通信，可以接受不连续的传输。</li>
</ul>
<h5><a id="set%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SET规则</h5>
<ul>
<li>SET 化配置规则</li>
<li>第一，Federation Exchanges，可以看成 Downstream (82 节点）从 Upstream  (81 节点）主动拉取消息，但并不是拉取所有消息，必须是在 Downstream 上已经明确定义 Bindings 关系的 Exchange，也就是有实际的物理 Queue 来接收消息才会从 Upstream 拉取消息到 Downstream。使用 AMQP 协议实施代理间通信 , Downstream会将绑定关系组合在一起，绑定/解除绑定命令将发送到 Upstream 交换机</li>
<li>第二，经过配置后，Upstream 节点已经可以把消息直接通过 Federation Exchanges 路由给我们的 Downstream 节点，然后进行消费。<br />
也就是说可以实现消息的转发，接下来也可以在 Upstream 添加具体的队列去进行消费 Federation Exchanges 里的消息，我们一条消息分别发到了 2 个 Rabbitmq！集群并且消费，这样我们可以实现 SET 化的关键要素，就是集群间的消息同步了</li>
<li>第三，可以根据自己的业务规则去规划不同的集群去监听不同的消息队列，从而达到 SET 化的手段，保障了性能、可靠性、数据一致性。</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-23T06:59:38+08:00" itemprop="datePublished">2019/09/23 06:59 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15691931782312.html" itemprop="url">
		MQ组件实现思路和架构设计方案</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%9E%B6%E6%9E%84%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>架构图</h4>
<p><img src="media/15691931782312/15691932664810.jpg" alt="" style="width:1373px;" /></p>
<h4><a id="mq%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MQ组件实现功能点</h4>
<ul>
<li>支持消息高性能的序列化转换、异步化发送消息</li>
<li>支持消息生产实例与消费实例的链接池化缓存化提升性能</li>
<li>支持可靠性投递消息，保障消息的 100%不丢失</li>
<li>支持消费端的幂等操作，避免消费端重复消费的问题</li>
<li>支持迅速消息发送模式,在一些日志收集/统计分析等需求下可以保证高性能，超高吞吐量</li>
<li>支持延迟消息模式，消息可以延迟发送，指定延迟时间，用于某些延迟检查、服务限流坜景</li>
<li>支持事务消息，且 100%保暲可靠性投递，在金融行业单笔大金额操作时会有此类需求</li>
<li>支持顺序消息，保证消息送达消费端的前后顺序，例如下订单等复合性操作支持消息补偿,重试,以及快速定位异常/失败消息</li>
<li>支持集群消息负载均衡，保障消息落到具体 ST 集群的负載均衡</li>
<li>支持消息路由策略，指定某些消息路由到指定的 SET 集群</li>
</ul>
<h4><a id="%E8%BF%85%E9%80%9F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>迅速消息发送</h4>
<ul>
<li>迅速消息是指消息不进行落库存储，不做可靠性的保障</li>
<li>在一些非核心消息、日志数据、或者统计分析等场景下比较合适</li>
<li>迅速消息的优点就是性能最高，吞吐量最大<br />
<img src="media/15691931782312/15691934495696.jpg" alt="" style="width:984px;" /></li>
</ul>
<h4><a id="%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>确认消息发送</h4>
<p><img src="media/15691931782312/15691934804861.jpg" alt="" style="width:1310px;" /></p>
<h4><a id="%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>批量消息发送</h4>
<p><img src="media/15691931782312/15691936700066.jpg" alt="" style="width:1328px;" /><br />
<img src="media/15691931782312/15691936915904.jpg" alt="" style="width:1363px;" /></p>
<h4><a id="%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>延迟消息发送</h4>
<ul>
<li>延迟消息相对简单，就是我们在 Message 封装的时候添加 delay Time 属性即可，使得我们的消息可以进行延迟发送，根据具体的业务场景也可以很好的使用得到</li>
<li>应用场景</li>
<li>电商平台买到的商品签收后，不点击确认支付，那么系统自动会在 7 天（一定时间）去进行支付操作。</li>
<li>还有一些自动超时作废的场景,你的优惠券/红包有使用时间限制，也可以用延迟消息机制</li>
</ul>
<h4><a id="%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顺序消息</h4>
<ul>
<li>发送的顺序消息，必须保障消息投递到同一个队列，且这个消费者只能有一个独占模式）</li>
<li>然后需要统一提交（可能是合并成一个大消息，也可能是拆分为多个消息），并且所有消息的会话 ID 一致</li>
<li>添加消息属性：顺序标记的序号、和本次顺序消息的 SIZE 属性，进行落库操作</li>
<li>并行进行发送给自身的延退消息（注意带上关键属性：会话 ID、SIZE）进行后续处理消费</li>
<li>当收到延迟消息后，根据会话ID、SIZE抽取数据库数据进行处理即可</li>
<li>定时轮训补偿机制，对于异常情况</li>
<li>备注：比如生产端消息没有完全投追成功、或者消费端落库异常导致消费端落库后缺少消息条目的情況）<br />
<img src="media/15691931782312/15691939630945.jpg" alt="" style="width:1429px;" /></li>
</ul>
<h4><a id="%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>事务消息</h4>
<ul>
<li>txSelect</li>
<li>我们采用类似可靠性投递的机制，也就是补偿机制</li>
<li>但是我们的数据源必须是同一个，也就是业务操作 DB1 数据库和消息记录 DB2 数据库使用同一个数据源。<br />
<img src="media/15691931782312/15691943270894.jpg" alt="" style="width:1184px;" /></li>
</ul>
<h4><a id="%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息幂等性</h4>
<h5><a id="%E5%87%BA%E7%8E%B0%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E7%9A%84%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>出现重复消费的情况</h5>
<ul>
<li>可靠性消息投递机制</li>
<li>MQ Broker服务与消费端传输消息的过程中的网络抖动</li>
<li>消费端故障或异常<br />
<img src="media/15691931782312/15691944331805.jpg" alt="" style="width:1358px;" /></li>
</ul>
<h5><a id="" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a></h5>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-10-18T05:05:09+08:00" itemprop="datePublished">2019/10/18 05:05 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15713463097375.html" itemprop="url">
		消费者消息</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="direct%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>direct模式</h4>
<ul>
<li>1、消费者 1 和消费者 2 获取到的消息鬥容是不同的，同一个消息只能被一个消费者获取。</li>
<li>2、消费者 1 和消费者 2 获取到的消息的数量是相同的，一个是奇数一个是偶数。</li>
</ul>
<h4><a id="work%E6%A8%A1%E5%BC%8F%E8%83%BD%E8%80%85%E5%A4%9A%E5%8A%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>work模式能者多劳</h4>
<ul>
<li>Qos每次只发一条消息</li>
<li>消费者从队列中获取消息，服务端如何宍道消息已经被消呢？</li>
<li>模式 1: 自动确认只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费模式</li>
<li>2: 手动确认消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态</li>
<li>手动情况</li>
</ul>
<h4><a id="%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>订阅模式</h4>
<ul>
<li><img src="media/15713463097375/15713470609557.jpg" alt="" style="width:517px;" /></li>
<li>交换机只是转发，没有存储消息功能</li>
<li>消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的力，消息只能存在在队列中。</li>
<li>同一个消息被多个消费者获取</li>
</ul>
<h4><a id="%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%95%86%E5%93%81%E7%9A%84%E5%90%8C%E6%AD%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>订阅模式实现商品的同步</h4>
<ul>
<li>可以的。</li>
<li>后台系统就是消息的生产者。前台系统和搜索系统是消息的消费者。</li>
<li>后台系统将消息发送到交换机中，前台系统和搜素系统都创建自己的队列，然后将队列绑定到交换机，即可实现。</li>
<li>消息，新增商品、修改商品、删除商品。</li>
<li>消费者有选择性的接收消息</li>
</ul>
<h4><a id="%E6%8C%81%E4%B9%85%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>持久化</h4>
<ul>
<li>非持久化性能高于持久化</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-18T07:43:17+08:00" itemprop="datePublished">2019/09/18 07:43 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15687637976768.html" itemprop="url">
		消息可靠性投递</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%AF%BC%E8%88%AA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>导航</h4>
<ul>
<li>消息如何保障 100%的投递成功？</li>
<li>幂等性概念详解</li>
<li>在海量订单产生的业务高峰期，如何避免消息的重复消费问题？</li>
<li>Confirm 确认消息、Return 返回消息</li>
<li>自定义消费者</li>
<li>消息的 ACK 与重回队列</li>
<li>消息的限流</li>
<li>TTL 消息</li>
</ul>
<h4><a id="%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息有序性</h4>
<ul>
<li>exclude</li>
<li>如果消息不能路由到queue，消息就会被丢弃</li>
</ul>
<h4><a id="%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可靠性投递</h4>
<ul>
<li>保障消息的成功发出</li>
<li>保障 MQ 节点的成功接收</li>
<li>发送端收到 MQ 节点（Broker）确认应答</li>
<li>完善的消息进行补偿机制</li>
</ul>
<h5><a id="%E6%B6%88%E6%81%AF%E8%90%BD%E5%BA%93%EF%BC%8C%E5%AF%B9%E6%B6%88%E6%81%AF%E7%8A%B6%E6%80%81%E8%BF%9B%E8%A1%8C%E6%89%93%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息落库，对消息状态进行打标</h5>
<p><img src="media/15687637976768/15687639498887.jpg" alt="" style="width:1249px;" /></p>
<h5><a id="%E4%B8%9A%E5%8A%A1%E6%B6%88%E6%81%AF%E8%90%BD%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>业务消息落库</h5>
<p><img src="media/15687637976768/15687640188248.jpg" alt="" style="width:1300px;" /></p>
<h4><a id="%E5%B9%82%E7%AD%89%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>幂等性</h4>
<ul>
<li>多次操作结果都是一样的</li>
<li><img src="media/15687637976768/15717869014026.jpg" alt="" style="width:779px;" /></li>
</ul>
<h5><a id="%E5%94%AF%E4%B8%80id%E6%8C%87%E7%BA%B9%E7%A0%81%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%88%A9%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E5%8E%BB%E9%87%8D%E5%88%A9%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>唯一ID+指纹码机制，利用数据库主键去重利用</h5>
<ul>
<li>唯一 ID+指纹码机制，利用数据库主键去重</li>
<li>SELECT COUNT (1) FROM T ORDER WHERE D=唯一 ID+指纹码</li>
<li>好处：实现简单</li>
<li>坏处：高并发下有数据库写入的性能瓶颈</li>
<li>解决方案：跟进 ID 进行分库分表进行算法路由</li>
</ul>
<h5><a id="redise%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8E%BB%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Redise 的原子性去实现</h5>
<ul>
<li>使用 Redis 进行幂等，需要考虑的问题</li>
<li>第一：我们是否要进行数据落库，如果落库的话，关键解決的问题是数据库和缓存如何做到原子性？</li>
<li>第二：如果不进行落库，那么都存储到缓存中，如何设置定时同步的策略？</li>
</ul>
<h4><a id="confirm%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Confirm机制</h4>
<ul>
<li>消息的确认，是指生产者投递消息后，如果 Brokerl 收到消息，则会给我们生产者一个应答。</li>
<li>生产者进行接收应答，用来确定这条消息是否正常的发送到 Broker，这种方式也是消息的可靠性投递的核心保障！</li>
<li><img src="media/15687637976768/15687655634522.jpg" alt="" style="width:1141px;" /></li>
<li>第一步：在 channel 上开启确认模式：Confirm</li>
<li>第二步：在 channel 上添加监听：NotifyConfirm(ack, nack chan uint64) 监听成功和失败的返回结果，根据具体的结果对消息进行重新发送、或记录日志等后续处理！</li>
<li>如果ACK和NACK都没有，利用定时任务抓去做中间状态进行补偿</li>
</ul>
<h4><a id="exchange" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exchange</h4>
<ul>
<li>在客户端和服务端声明都可以</li>
<li>如果声明的时候路由key不一样，则会生成两个</li>
<li></li>
</ul>
<h4><a id="return%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Return消息机制</h4>
<ul>
<li>Return Listener 用于处理一些不可路由的消息</li>
<li>我们的消息生产者，通过指定一个 Exchange 和 Routingkey，把消息送达到某一个队列中去，然后我们的消费者监听队列，进行消费处理操作！</li>
<li>但是在某些情况下，如果我们在发送消息的时候，当前的 exchange不存在或者指定的路由 key 略由不到，这个时候如果我们需要监听这种不可达的消息，就要使用 Return Listener</li>
<li>Mandatory：如果为 true，则监听器会接收到路由不可达的消息，然后进行后续处理，如果为 false，那么 brokers 端自动删除该消息</li>
<li><img src="media/15687637976768/15688492958280.jpg" alt="" style="width:943px;" /></li>
</ul>
<h4><a id="%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消费端限流</h4>
<ul>
<li>Rabbit MQ 提供了一种 qos（服务质量保证）功能，即在非自动确认消息的前提下，如果一定数目的消息（通过基于 Consume 或者 channeli 设置 Qos 的值）未被确认前，不进行消费新的消息。</li>
</ul>
<pre><code class="language-plain_text">type basicQos struct {
  PrefetchSize  uint32 0不做限制
  PrefetchCount uint16 一次处理多少条消息
  Global        bool //channel true consumer false
}
</code></pre>
<ul>
<li>Prefetchsize: 0</li>
<li>Prefetch Count：会告诉 Rabbitmq 不要同时给一个消费者推送多于 N 个消息，即一旦有 N 个消息还没有 ack，则该 consumer 将 block 掉，直到有消息 ack</li>
<li>global: true\false 是否将上面设置应用于 channel简单点说，就是上面限制是 chann인l 级别的还是 consumer client级别</li>
<li>autoAck设置为false</li>
</ul>
<h4><a id="%E6%B6%88%E8%B4%B9%E7%AB%AFack%E5%92%8C%E9%87%8D%E5%9B%9E%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消费端ACK和重回队列</h4>
<ul>
<li>消费端的手工 ACK 和 NACK， NACK保证消息重回队列</li>
<li>消费端进行消费的时候，如果由于业务异常我们可以进行日志的记<br />
录，然后进行补偿</li>
<li>如果由于服务器宕机等严重问题，那我们就需要手工进行 ACK 保障消费端消费成功</li>
</ul>
<h5><a id="%E9%87%8D%E5%9B%9E%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重回队列</h5>
<ul>
<li>消费端重回队列是为了对没有处理成功的消息，把消息重新会递给Broker</li>
<li>一般我们在实际应用中，都会关闭重回队列，也就是设置为 False</li>
</ul>
<pre><code class="language-plain_text">type basicNack struct {
  DeliveryTag uint64
  Multiple    bool
  Requeue     bool
}
type basicAck struct {
  DeliveryTag uint64
  Multiple    bool
}
Nack(tag uint64, multiple bool, requeue bool)
multiple 是否批量
requeue 是否重回队列
Ack(tag uint64, multiple bool)
</code></pre>
<h4><a id="ttl%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TTL队列/消息</h4>
<ul>
<li>TTL 是 Time To Live 的缩写，也就是生存时间</li>
<li>Rabbitmq 支持消息的过期时间，在消息发送时可以进行指定</li>
<li>Rabbitmq 支持队列的过期时间，从消息入队列开始计算，只要超过了队列的超时时间配置，那么消息会自动的清除</li>
<li>针对队列</li>
<li>expiration针对单个消息</li>
</ul>
<h4><a id="%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>死信队列</h4>
<ul>
<li>死信队列：DLX, Dead- Letter- Exchange</li>
<li>利用 DLX，当消息在一个队列中变成死信（dead message）之后</li>
<li>它能被重新 publish 到另一个 Exchange，这个 Exchange 就是 DLX</li>
<li><img src="media/15687637976768/15718066699196.jpg" alt="" style="width:1159px;" /></li>
</ul>
<h5><a id="%E5%88%86%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分类</h5>
<ul>
<li>消息被拒绝（basic. Reject/ basic. Nack）并且 requeue= false 消息 TTL 过期队列达到最大长度</li>
<li>DLX 也是一个正常的 Exchange，和一般的 xchange 没有区別，它能在任何的队列上被指定，实际上就是设置某个队列的属性。</li>
<li>当这个队列中有死信时，Rabbitmq 就会自动的将这个消息重新发布到设置的 Exchange 上去，进而被路由到另一个队列</li>
<li>可以监听这个队列中消息做相应的处理，这个特性可以弥补 Rabbitmq 3.0 以前支持的 immediate 参数的功能。</li>
</ul>
<h5><a id="%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置</h5>
<ul>
<li>首先需要设置死信队列的 exchange 和 queue，然后进行绑定</li>
<li>Exchange: dlx. Exchange</li>
<li>Queue dlxqueue v Routing Key: #</li>
<li>arguments.Put(&quot;x-dead-letter-exchange&quot;, dlx.exchange&quot;)</li>
<li>这样消息在过期、requeue、队列在达到最大长度时，消息就可以直接路由到死信队列！</li>
</ul>
<h4><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h4>
<ul>
<li>本章节主要和大家一起学习了 Rabbitmqp 的高级特性，首先介绍了互联网大厂在实际使用中是如何保障 100%的消息投递成功和幕等性的，以及对 Rabbitmqf 的确认消息、返回消息、ACK 与重回队列、消息的限流，以及对超时时间、死信队列的使用</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-21T05:28:31+08:00" itemprop="datePublished">2019/09/21 05:28 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RabbitMQ.html'>RabbitMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15690149118717.html" itemprop="url">
		集群模式</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li>首先是了解 Rabbitmq！集群架构模式</li>
<li>接下来从零开始构建一个高可靠的 Rabbitmq 集群</li>
<li>集群的配置文件与集群运维故障、失败转移讲解</li>
<li>高级插件的使用</li>
</ul>
<h4><a id="%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>集群架构模式</h4>
<ul>
<li>主备模式：实现 Rabbitmqp 的高可用集群，一般在并发和数据量不高的情况下，这种模型非常的好用且简单。主备模式也称之为 Warren 模式</li>
<li><img src="media/15690149118717/15690156274138.jpg" alt="" style="width:942px;" /></li>
</ul>
<h4><a id="haproxy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HAProxy</h4>
<ul>
<li><img src="media/15690149118717/15690157084976.jpg" alt="" style="width:972px;" /><br />
备注：rabbitmq 集群节点配置#inter 每隔五秒对 mq 集群做健康检查，2 次正确证明服务器可用，2 次失败证明服务器不可用，并且配置主备机</li>
</ul>
<h4><a id="%E8%BF%9C%E7%A8%8B%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>远程模式</h4>
<ul>
<li>远程模式：远程模式可以实现双活的一种模式，简称 Shovel 模式，所谓 Shovel 就是我们可以把消息进行不同数据中心的复制工作，我们可以跨地域的让俩个 mq 集群互联</li>
<li>远程模式：远距离通信和复制，所谓 Shovel 就是我们可以把消息进行不同数据中心的复制工作，我们可以跨地域的让俩个 mq 集群互联。我们们下面看一下 Shovel 架构模型</li>
<li><img src="media/15690149118717/15690158773792.jpg" alt="" style="width:1151px;" /></li>
<li><img src="media/15690149118717/15690159808973.jpg" alt="" style="width:1006px;" /></li>
<li>rabbitmq-plugins enable amqp_client</li>
<li>rabbitmq-plugins enable rabbitma shovel</li>
<li><img src="media/15690149118717/15690160849763.jpg" alt="" style="width:1170px;" /></li>
</ul>
<h4><a id="%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>镜像模式</h4>
<ul>
<li>镜像模式：集群模式非常经典的就是 Mirr 镜像模式，保证 100%数据不丢失，在实际工作中也是用的最多的。并且实现集群非常的简单，一般互联网大厂都会构建这种镜像集群模式</li>
<li>mirror镜像队列，目的是为了保证 rabbitmq 数据的高可靠性解决方案，主要就是实现数据的同步，一般来讲是 2-3 个节点实现数据同步（对于 100%数据可靠性解决方案一般是 3 节点）集群架构如下</li>
<li><img src="media/15690149118717/15690162262774.jpg" alt="" style="width:1199px;" /></li>
</ul>
<h4><a id="%E5%A4%9A%E6%B4%BB%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多活模式</h4>
<ul>
<li>多活模式：这种模式也是实现异地数据复制的主流模式，因为 Shovel 模式配置比较复杂，所以一般来说实现异地集群都是使用这种双活或者多活模型来取实现的。这种模型需要依赖 rabbitmg 的 federation 插件，可以实现持续的可靠的 AMQP 数据通信，多活模式在实际配置与应用非常的简单</li>
<li><img src="media/15690149118717/15690165040414.jpg" alt="" style="width:1166px;" /></li>
<li>Federation 插件是一个不需要构建 Cluster，而在 Brokers 之间传输消息的高性能插件，Federation 插件可以在 Brokers 或者 Cluster 之间传输消息，连接的双方可以使用不同的 users 和 virtual hosts，双方也可以使用版本不同的 Rabbitmq 和 Erlang。Federation 插件使用 AMQP 协议通讯，可以接受不连续的传输</li>
<li><img src="media/15690149118717/15690166447455.jpg" alt="" style="width:1076px;" /></li>
<li>Federation Exchanges，可以看成 Downstream 从 Upstream 主动拉取消息，但并不是拉取所有消息，必须是在 Downstream 上已经明确定义 Bindings 关系的 Exchange，也就是有实际的物理 Queue 来接收消息，才会从 Upstream 拉取消息到 Downstream。使用 AMQP 协议实施代理间通信，Downstream 会将绑定关系 组合在一起,绑定/解除绑定命令将发送到∪ pstream 交换机。因此，Federation Exchange 只接收具有订阅的消消</li>
</ul>
<h4><a id="%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F%E6%9E%84%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>镜像模式构建</h4>
<ul>
<li><img src="media/15690149118717/15690169031673.jpg" alt="" style="width:1171px;" /></li>
</ul>
<h4><a id="haproxy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Haproxy</h4>
<ul>
<li>Haproxy 借助于 OS 上几种常见的技术来实现性能的最大化</li>
<li>单进程、事件驱动模型显著降低了上下文切换的开销及内存占用</li>
<li>在任何可用的情况下，单缓冲（(single buffering）机制能以不复制任何数据的方式完成读写操作，这会节约大量的 CPU 时钟周期及内存带宽</li>
<li>3 借助于 Linux2.6 (&gt; =2.6.27.19) 上的 splice 系统调用，Haproxy 可以实现零复制转发（Zero- copy forwarding），在 Linux3.5 及以上的 OS 中还可以实现零复制启动（zero- starting)</li>
<li>4 内存分配器在固定大小的内存池中可实现即时内存分配，这能够显著减少创建个会话的时长</li>
<li>5 树型存储：侧重于使用作者多年前开发的弹性二叉树，实现了以 O (og (N）的低开销来保持计时器命令、保持运行队列命令及管理轮询及最少连接队列</li>
</ul>
<h4><a id="keepalived" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>KeepAlived</h4>
<ul>
<li>Keepalived 软件主要是通过 VRRP 协议实现高可用功能的。VRRP 是 Virtual Router Redundancy Protocol（虚拟路由器元余协议）的缩写 VRRP 出现的目的就是为了解决静态路由单点故障问题的，它能够保证当个别节点宕机时，整个网络可以不间断地运行所以，Keepalived-方面具有配置管理∨VS 的功能，同时还具有对 LVS 下面节点进行健康检查的功能，另一方面也可实现系统网络服务的高可用功能</li>
</ul>
<h5><a id="%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>功能</h5>
<p>Keepalived 服务的三个重要功能<br />
管理∨S 负载妁衡软件<br />
实现 VS 集群节点的健康检査中<br />
作为系统网络服务的高可用性（failover)</p>
<h4><a id="%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>集群配置文件</h4>
<ul>
<li>Tcp_ listerners 设置 rabbimg 的监听端口，默认为【5672</li>
<li>disk free limit 磁盘低水位线，若磁盘容量低于指定值则停止接收数据，默</li>
<li>认值为{ mem relative,1.0｝，即与内存相关联 1:1, 也可定制为多少 byte</li>
<li>vm_memory high watermark，设置内存低水位线，若低于该水位线，则</li>
<li>开启流控机制，默认值是 0.4, 即内存总量的 40%</li>
<li>Hipe_ compile 将部分 rabbimq 代码用 High Performance Erlang compiler 编译，可提升性能，该参数是实验性，若出现 erlang vm segfaults，应关掉</li>
<li>force fine_ statlstlcs，该参数属于 rabbimg_ management，若为 true 则进行精细化的统计，但会影响性能</li>
<li>集群节点模式： Disk为磁盘模式存储/Ramn为内存模式存储</li>
</ul>
<h4><a id="%E9%9B%86%E7%BE%A4%E6%81%A2%E5%A4%8D%E5%92%8C%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>集群恢复和故障转移</h4>
<ul>
<li><img src="media/15690149118717/15690206360764.jpg" alt="" style="width:1216px;" /></li>
<li><img src="media/15690149118717/15690206459784.jpg" alt="" style="width:1287px;" /></li>
<li><img src="media/15690149118717/15690206702174.jpg" alt="" style="width:1266px;" /></li>
<li><img src="media/15690149118717/15690207258964.jpg" alt="" style="width:1325px;" /></li>
<li><img src="media/15690149118717/15690208366480.jpg" alt="" style="width:1199px;" /></li>
<li><img src="media/15690149118717/15690209799298.jpg" alt="" style="width:1303px;" /></li>
</ul>
<h4><a id="%E5%BB%B6%E8%BF%9F%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>延迟插件</h4>
<ul>
<li>延迟队列可以做什么事情？</li>
<li>比如消息的延迟推送、定时任务（消息）的执行。包括一些消息重试策略的配合使用，以及用于业务削峰限流降级的异步延迟消息机制，都是延迟队列的实际应用场景</li>
<li></li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>