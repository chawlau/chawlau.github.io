<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  设计模式 - eredin-blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="eredin-blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; eredin-blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html">C++基础与提高</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html">设计模式之美</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
        
            <li><a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Linux性能优化实战</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15814649492497.html">
                
                  <h1>Simple Factory</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>接口编程</h4>

<ul>
<li>接口从语法层面上来说，是一种特殊的抽象类，是一个纯虚的类。从软件设计的意义<br/>
上来说，我们通常用接口来定义实现类的外观，就相当于一份契约，根据外部应用需要的功能，约定了实现类应该要实现的功能</li>
<li>软件开发中永恒的主题是“变化“，“只有变化才是永恒不変！“，接口最重要的一个设计语义就是封装变化。所谓“封装变化”就是隔离变化。</li>
<li>从软件的整体结构上看，只要接口不变，内部实现的变化就不会影响到外部应用，从而使得系统更灵活，具有更好的扩展性和可维护性。</li>
</ul>

<h4>简单工厂模式</h4>

<ul>
<li>实现客户端调用和具体类的分离，实现了变化隔离</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Api {
    public:
    virtual void test(string&amp;&amp; s) = 0;
    protected:
    Api(){}
};

class Impl : public Api {
    public:
    void test(string&amp;&amp; s) override {
        cout &lt;&lt; &quot;Iml class &quot; &lt;&lt; s &lt;&lt; &#39;\n&#39;;
    }
    using Api::Api;
};

class ImplPro : public Api {
    public:
    void test(string&amp;&amp; s) override {
        cout &lt;&lt; &quot;Iml class &quot; &lt;&lt; s &lt;&lt; &#39;\n&#39;;
    }
    using Api::Api;
};


class Factory {
    public:
    static Api* createApi(int type) {
        cout &lt;&lt; &quot;Simple Factory create instance \n&quot; ;
        Api* api = nullptr;
        if (type == 1) {
            api = new Impl();
        } else if (type == 2) {
            api = new ImplPro();
        }
        return api;
    }
};

int main() {
    Api* api = Factory::createApi(2);
    api-&gt;test(&quot;hello&quot;);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/02/12 07:49 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15787865983142.html">
                
                  <h1>定时器设计</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>case</h4>

<pre class="line-numbers"><code class="language-go">type TimerTask struct {
    t *time.Timer
    d time.Duration
}

func (e *TimerTask) run() {
    for {
        select {
        case &lt;- e.t.C:
            fmt.Println(&quot;run&quot;)
            e.t.Reset(e.d)
        }
    }
}

func main() {
    dur := time.Duration(1) * time.Second
    executor := &amp;TimerTask{d: dur, t: time.NewTimer(dur)}
    executor.run()
    select {}
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/12 07:49 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15782640669384.html">
                
                  <h1>解析器</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>动机</h4>

<ul>
<li><p>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。</p></li>
<li><p>在这种情况下，将特定领域的问题表达为某种语法规则下的句子然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。</p></li>
</ul>

<h4>模式定义</h4>

<ul>
<li>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。</li>
</ul>

<h4>结构</h4>

<ul>
<li><img src="media/15782640669384/15782652005755.jpg" alt="" style="width:598px;"/></li>
</ul>

<h4>要点总结</h4>

<ul>
<li>Interpreter 模式的应用场合是 Interpreter。模式应用中的难点，只有满足“业务规则频繁变化，<strong><em>且类似的结构不断重复出现，并且容易抽象为语法规则的问题”才适合使用 Interpreter/模式。</em></strong></li>
<li>使用 Interpreter 模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展”文法</li>
<li>interpreter/模式比较适合简单的文法表示,对于复杂的文法表示, nterperter/模式会产生比较大的类层次结构,需要求助于语法分析生成器这样的标准工具</li>
</ul>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package design_pattern

import (
    &quot;strconv&quot;
    &quot;strings&quot;
)

type Node interface {
    Interpret() int
}

type ValNode struct {
    val int
}

func (n *ValNode) Interpret() int {
    return n.val
}

type AddNode struct {
    left, right Node
}

func (n *AddNode) Interpret() int {
    return n.left.Interpret() + n.right.Interpret()
}

type MinNode struct {
    left, right Node
}

func (n *MinNode) Interpret() int {
    return n.left.Interpret() - n.right.Interpret()
}

type Parser struct {
    exp   []string
    index int
    prev  Node
}

func (p *Parser) Parse(exp string) {
    p.exp = strings.Split(exp, &quot; &quot;)

    for {
        if p.index &gt;= len(p.exp) {
            return
        }
        switch p.exp[p.index] {
        case &quot;+&quot;:
            p.prev = p.newAddNode()
        case &quot;-&quot;:
            p.prev = p.newMinNode()
        default:
            p.prev = p.newValNode()
        }
    }
}

func (p *Parser) newAddNode() Node {
    p.index++
    return &amp;AddNode{
        left:  p.prev,
        right: p.newValNode(),
    }
}

func (p *Parser) newMinNode() Node {
    p.index++
    return &amp;MinNode{
        left:  p.prev,
        right: p.newValNode(),
    }
}

func (p *Parser) newValNode() Node {
    v, _ := strconv.Atoi(p.exp[p.index])
    p.index++
    return &amp;ValNode{
        val: v,
    }
}

func (p *Parser) Result() Node {
    return p.prev
}

import &quot;testing&quot;

func TestInterpreter(t *testing.T) {
    p := &amp;Parser{}
    p.Parse(&quot;1 + 2 + 3 - 4 + 5 - 6&quot;)
    res := p.Result().Interpret()
    expect := 1
    if res != expect {
        t.Fatalf(&quot;expect %d got %d&quot;, expect, res)
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/06 06:41 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15782299761779.html">
                
                  <h1>访问器模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>动机</h4>

<ul>
<li>在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。</li>
<li>如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？</li>
</ul>

<h4>定义</h4>

<ul>
<li>表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。</li>
</ul>

<h4>结构</h4>

<ul>
<li><img src="media/15782299761779/15782309016996.jpg" alt="" style="width:696px;"/></li>
</ul>

<h4>要点总结</h4>

<ul>
<li><p>Visitor 模式通过所谓双重分发（double dispatch）来实现在不更改（不添加新的操作-编译时）Elementa 类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作（支持变化）。</p></li>
<li><p>所谓双重分发即 Visitor 模式中间包括了两个多态分发（注意其中的多态机制）：第一个为 accept 方法的多态辨析；第二个为 /isitelementx 方法的多态辨析。</p></li>
<li><p>Visitor 模式的最大缺点在于扩展类层次结构（增添新的 Element 子类），会导致 Visitor？类的改变。<strong><em>因此 Vistor 模式适用于Element 类层次结构稳定，而其中的操作却经常面临频繁改动</em></strong>。</p></li>
</ul>

<h4>cpp_demo</h4>

<pre class="line-numbers"><code class="language-cpp">//
// Created by eredinliu on 2020-01-05.
//

#include &lt;iostream&gt;

using namespace std;

class Visitor;

class Element {
public:
    virtual void accept(Visitor&amp; visitor) = 0;
};

class ElementA : public Element {
public:
    void accept(Visitor&amp; visitor) override {
        visitor.visitElementA(*this);
    }
};

class ElementB : public Element {
public:
    void accept(Visitor&amp; visitor) override {
        visitor.visitElementB(*this);
    }
};


class Visitor {
public:
    virtual void visitElementA(ElementA&amp; e) = 0;
    virtual void visitElementB(ElementB&amp; e) = 0;
};

class VisitorA : public Visitor {
public:
    void visitElementA(ElementA&amp; e) override {
        cout &lt;&lt; &quot;VisitorA is processing Element A &quot; &lt;&lt; endl;
    }

    void visitElementB(ElementB&amp; e) override {
        cout &lt;&lt; &quot;VisitorA is processing Element B &quot; &lt;&lt; endl;
    }
};

class VisitorB : public Visitor {
public:
    void visitElementA(ElementA&amp; e) override {
        cout &lt;&lt; &quot;VisitorB is processing Element A &quot; &lt;&lt; endl;
    }

    void visitElementB(ElementB&amp; e) override {
        cout &lt;&lt; &quot;VisitorB is processing Element B &quot; &lt;&lt; endl;
    }
};

int main() {
    VisitorA visitorA;
    VisitorB visitor;
    ElementB elementB;
    elementB.accept(visitor);
    elementB.accept(visitorA);


    ElementA elementA;
    elementA.accept(visitor);
    elementA.accept(visitorA);
}
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package design_pattern

import &quot;fmt&quot;

type Element interface {
    Accept(Visitor)
}

type Visitor interface {
    visitA(*ElementA)
    visitB(*ElementB)
}

type ElementA struct {
}

func (e *ElementA) Accept(visitor Visitor) {
    visitor.visitA(e)
}

type ElementB struct {
}

func (e *ElementB) Accept(visitor Visitor) {
    visitor.visitB(e)
}

type VisitorA struct {
}

func (v *VisitorA) visitA(e *ElementA) {
    fmt.Println(&quot;VisitorA is processing Element A &quot; )
}

func (v *VisitorA) visitB(e *ElementB) {
    fmt.Println(&quot;VisitorA is processing Element B &quot; )
}

type VisitorB struct {
}

func (v *VisitorB) visitA(e *ElementA) {
    fmt.Println(&quot;VisitorB is processing Element A &quot; )
}

func (v *VisitorB) visitB(e *ElementB) {
    fmt.Println(&quot;VisitorB is processing Element B &quot; )
}

type ObjectStructure struct {
    elements map[Element]bool
}

func (o *ObjectStructure) Attach(e Element) {
    o.elements[e] = true
}

func (o *ObjectStructure) Detach(e Element) {
    delete(o.elements, e)
}

func (o *ObjectStructure) Accept(visitor Visitor) {
    for k, _ := range o.elements {
        k.Accept(visitor)
    }
}

func NewObjectStructure() *ObjectStructure {
    return &amp;ObjectStructure{
        elements: make(map[Element]bool),
    }
}

package design_pattern

import &quot;testing&quot;

func TestVisitor(t *testing.T) {
    obj := NewObjectStructure()

    elementB := &amp;ElementB{}
    elementA := &amp;ElementA{}

    obj.Attach(elementA)
    obj.Attach(elementB)

    vA := &amp;VisitorA{}
    vB := &amp;VisitorB{}
    obj.Accept(vA)
    obj.Accept(vB)
}
</code></pre>

<h4>python_code</h4>

<pre class="line-numbers"><code class="language-python">from abc import ABCMeta, abstractmethod

class Element(metaclass=ABCMeta):

    @abstractmethod
    def accept(self, visitor):
        pass

class Visitor(metaclass=ABCMeta):

    @abstractmethod
    def visitA(self, elementA):
        pass

    @abstractmethod
    def visitB(self, elementB):
        pass

class ElementA(Element):

    def accept(self, visitor):
        visitor.visitA(self)

class ElementB(Element):

    def accept(self, visitor):
        visitor.visitB(self)

class VisitorA(Visitor):

    def visitA(self, elementA):
        print(type(self).__name__, &quot; process elementA&quot;)

    def visitB(self, elementB):
        print(type(self).__name__, &quot; process elementB&quot;)


class VisitorB(Visitor):

    def visitA(self, elementA):
        print(type(self).__name__, &quot; process elementA&quot;)

    def visitB(self, elementB):
        print(type(self).__name__, &quot; process elementB&quot;)

class ObjectStructure(object):

    def __init__(self):
        self.elements = []

    def attach(self, element):
        self.elements.append(element)

    def detach(self, element):
        self.elements.remove(element)

    def accept(self, visitor):
        for e in self.elements:
            e.accept(visitor)

if __name__ == &#39;__main__&#39;:
    obj = ObjectStructure()

    eA = ElementA()
    eB = ElementB()

    obj.attach(eA)
    obj.attach(eB)

    va = VisitorA()
    vb = VisitorB()

    obj.accept(va)
    obj.accept(vb)
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/05 21:12 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15775908801763.html">
                
                  <h1>Command</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>行为变化模式</h4>

<ul>
<li>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化“模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</li>
</ul>

<h4>动机</h4>

<ul>
<li>在软件构建过程中，“行为请求者”与“行为实现者通常呈现一种“紧耦合”。但在某些场合一一比如需要对行为进行“记录、撤销/重（undo/redo)、事务”等处理,这种无法抵御变化的紧耦合是不合适 的</li>
<li>在这种情况下，如何将“行为请求者“与“行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li>
</ul>

<h4>模式定义</h4>

<ul>
<li>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撇销的操作。</li>
</ul>

<h4>结构</h4>

<ul>
<li><img src="media/15775908801763/15811582346417.jpg" alt="" style="width:787px;"/></li>
</ul>

<h4>要点总结</h4>

<ul>
<li>Command 模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象</li>
<li>实现 Command 接口的具体命令对象 Concrete Command 有时侯根据需要可能会保存一些额外的状态信息。通过使用 Composite 模式可以将多个“命令“封装为ー个“复合命令“Macro Command</li>
<li>Command 模式与 C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command 以面向对象中的“接口-实现”来定义行为接口规范，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。</li>
<li>编译时多态</li>
<li>范形编程+函数对象解决了迭代器模式和命令模式</li>
<li>设计模式是弥补语言设计的不足出现的</li>
</ul>

<h4>优缺点</h4>

<h5>优点</h5>

<ul>
<li>将调用操作的类与知道如何执行该操作的对象解耦；</li>
<li>提供队列系统后，可以创建一系列命令；</li>
<li>添加新命令更加容易，并且无需更改现有代码；</li>
<li>还可以使用命令模式来定义回滚系统，例如，在向导示例中，我们可以编写一个回滚方法。</li>
</ul>

<h6>缺点：</h6>

<ul>
<li>为了实现目标，需要大量的类和对象进行协作。应用程序开发人员为了正确开发这些类，需要倍加小心；</li>
<li>每个单独的命令都是一个ConcreteCommand类，从而增加了需要实现和维护的类的数量。</li>
</ul>

<h4>cpp_code</h4>

<pre class="line-numbers"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

class Command {
    public:
    virtual void execute() = 0;
    Command() {}
};

class Barbecue {
    public:
    void bake_mutton() {cout &lt;&lt; &quot;bake mutton \n&quot;;}
    void bake_chicken() {cout &lt;&lt; &quot;bake chicken\n&quot;;}
};

class MuttonCommand : public Command {
    public:
    MuttonCommand(Barbecue* barbecue) : barbecue_(barbecue) {}

    void execute() {
        this-&gt;barbecue_-&gt;bake_mutton();
    }
    private:
    Barbecue* barbecue_ = nullptr;
};

class ChickenCommand : public Command {
    public:
    ChickenCommand(Barbecue* barbecue) : barbecue_(barbecue) {}

    void execute() {
        this-&gt;barbecue_-&gt;bake_chicken();
    }
    private:
    Barbecue* barbecue_ = nullptr;
};

class Waiter {
    public:
    Waiter() {}

    void AddOrder(Command* cmd) {
        this-&gt;orders.push_back(cmd);
    }

    void DelOrder(Command* cmd) {
        this-&gt;orders.remove(cmd);
    }

    void Notify() {
        for (auto it : this-&gt;orders) {
            it-&gt;execute();
        }
    }
    private:
    list&lt;Command*&gt; orders;
};

int main() {
    auto boy = new Barbecue();
    Command* cmd1 = new MuttonCommand(boy);
    Command* cmd2 = new MuttonCommand(boy);
    Command* cmd3 = new ChickenCommand(boy);
    auto waiter = new Waiter();
    waiter-&gt;AddOrder(cmd1);
    waiter-&gt;AddOrder(cmd2);
    waiter-&gt;AddOrder(cmd3);
    waiter-&gt;Notify();
}
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package desian_pattern_practise


import &quot;fmt&quot;

type Command interface {
    ExecuteCommand()
}

type Barbecue struct {}

func (b *Barbecue) BakeMutton() {
    fmt.Println(&quot;BakeMutton&quot;)
}

func (b *Barbecue) BakeChicken() {
    fmt.Println(&quot;BakeChicken&quot;)
}

type MuttonCommand struct {
    *Barbecue
}

func NewMuttonCommand(boy *Barbecue) *MuttonCommand {
    return &amp;MuttonCommand{
        Barbecue: boy,
    }
}

func (m *MuttonCommand) ExecuteCommand() {
    m.Barbecue.BakeMutton()
}

type BakeCommand struct {
    *Barbecue
}

func NewBakeCommand(boy *Barbecue) *BakeCommand {
    return &amp;BakeCommand{
        Barbecue: boy,
    }
}

func (b *BakeCommand) ExecuteCommand() {
    b.Barbecue.BakeChicken()
}

type Waiter struct {
    orders map[Command]bool
}

func NewWaiter() *Waiter {
    return &amp;Waiter{
        orders: make(map[Command]bool),
    }
}

func (w *Waiter) AddOrder(cmd Command) {
    w.orders[cmd] = true
}

func (w *Waiter) CancelOrder(cmd Command) {
    delete(w.orders, cmd)
}

func (w *Waiter) Notify() {
    for k, _ := range w.orders {
        k.ExecuteCommand()
    }
}
func TestBakeCommand_ExecuteCommand(t *testing.T) {
    boy := &amp;Barbecue{}

    cmd1, cmd2  := NewMuttonCommand(boy), NewMuttonCommand(boy)
    cmd3 := NewBakeCommand(boy)

    waiter := NewWaiter()
    waiter.AddOrder(cmd1)

    waiter.AddOrder(cmd2)

    waiter.AddOrder(cmd3)

    waiter.CancelOrder(cmd1)
    waiter.Notify()
}
</code></pre>

<h4>python_demo</h4>

<pre class="line-numbers"><code class="language-python">from abc import ABCMeta, abstractmethod

class Command(metaclass=ABCMeta):

    @abstractmethod
    def execute_command(self):
        pass

class Barbecue(object):

    def bake_mutton(self):
        print(&quot;bake mutton&quot;)

    def bake_chicken(self):
        print(&quot;bake chicken&quot;)

class MuttonCommand(Command):

    def __init__(self, barbecue):
        self.barbecue = barbecue

    def execute_command(self):
        self.barbecue.bake_mutton()


class ChickenCommand(Command):

    def __init__(self, barbecue):
        self.barbecue = barbecue

    def execute_command(self):
        self.barbecue.bake_chicken()

class Waiter(object):

    def __init__(self):
        self.__orders = []

    def add_order(self, cmd):
        self.__orders.append(cmd)

    def cancel_order(self, cmd):
        self.__orders.remove(cmd)

    def notify(self):
        for order in self.__orders:
            order.execute_command()

if __name__ == &#39;__main__&#39;:
    boy = Barbecue()

    cmd1 = MuttonCommand(boy)
    cmd2 = MuttonCommand(boy)
    cmd3 = ChickenCommand(boy)

    waiter = Waiter()

    waiter.add_order(cmd1)
    waiter.add_order(cmd2)
    waiter.add_order(cmd3)

    waiter.notify()
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/29 11:41 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15768853718636.html">
                
                  <h1>Chain of Responsibility</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>模式定义</h4>

<ul>
<li>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止</li>
</ul>

<h4>结构</h4>

<ul>
<li><img src="media/15768853718636/15806441423658.jpg" alt="" style="width:799px;"/></li>
</ul>

<h4>要点总结</h4>

<ul>
<li>Chain of Responsibility 7 模式的应用场合在于“一个请求可能有多个接受者，但是最后真正的接受者只有一个“，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化</li>
<li>应用了 Chain of Responsibility 模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加/修改请求的处理职责。</li>
<li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li>
<li>这里发出这个请求的客户端并不知道这当中的哪一个对象最终处理这个请求，这样系统的更改可以在不影响客户端的情况下动态地重新组织和分配责任</li>
</ul>

<h4>cpp_demo</h4>

<pre class="line-numbers"><code class="language-cpp">//
// Created by eredinliu on 2020-02-03.
//

#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
using namespace std;

class Request {
public:
    Request(const string&amp; name, const string&amp; reason, int day_off) :
            name_(name), reason_(reason), day_off_(day_off) {}
    string name_, reason_;
    int day_off_;
};

class Responsible {
public:
    void SetSuperior(Responsible* superior) {this-&gt;superior_ = superior;}
    Responsible() {}

    bool SuperiorHandle(Request* request) {
        if (this-&gt;superior_ != nullptr) {
            return this-&gt;superior_-&gt;HandleRequest(request);
        }

        cout &lt;&lt; &quot;Out of power, reject \n&quot;;
        return false;
    }

    virtual bool HandleRequest(Request* request) = 0;

private:
    Responsible* superior_;
};

class Supervisor : public  Responsible {
public:
    bool HandleRequest(Request* request) {
        if (request-&gt;day_off_ &gt; 0 &amp;&amp; request-&gt;day_off_ &lt;= 2) {
            cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; permit \n&quot;;
            return true;
        }

        return this-&gt;SuperiorHandle(request);
    }
};

class Depmanager : public  Responsible {
public:
    bool HandleRequest(Request* request) {
        if (request-&gt;day_off_ &gt; 2 &amp;&amp; request-&gt;day_off_ &lt;= 5) {
            cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; permit \n&quot;;
            return true;
        }

        return this-&gt;SuperiorHandle(request);
    }
};

class CEO : public  Responsible {
public:
    bool HandleRequest(Request* request) {
        if (request-&gt;day_off_ &gt; 5 &amp;&amp; request-&gt;day_off_ &lt;= 12) {
            cout &lt;&lt; typeid(this).name() &lt;&lt; &quot; permit \n&quot;;
            return true;
        }

        return this-&gt;SuperiorHandle(request);
    }
};

int main() {
    Responsible* ceo = new CEO();
    Responsible* dep = new Depmanager();
    Responsible* super = new Supervisor();
    dep-&gt;SetSuperior(ceo);
    super-&gt;SetSuperior(dep);

    Request* req = new Request(&quot;ming&quot;, &quot;sick&quot;, 10);
    super-&gt;HandleRequest(req);
}
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package design_pattern

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type Request struct {
    name, reason string
    dayOff int
}

type Responsible interface {
    HandlerRequest(*Request) bool
}

type Manager struct {
    superior Responsible
}

func (m *Manager) HandlerRequest(*Request) bool {
    return true
}

func (m *Manager) SetSuperior(superior Responsible) {
    m.superior = superior
}

func (m *Manager) SuperHandle(r *Request) bool {
    if m.superior != nil {
      return m.superior.HandlerRequest(r)
    }

    fmt.Println(&quot;out of power, reject&quot;)
    return false
}

type Supervisor struct {
    *Manager
}

func (s *Supervisor) HandlerRequest(r *Request) bool {
    
    if r.dayOff &gt; 0 &amp;&amp; r.dayOff &lt;=2 {
        fmt.Println(reflect.TypeOf(s).String() + &quot; Permit&quot;)
        return true
    }

    return s.SuperHandle(r)
}

func NewSupervisor() *Supervisor {
    return &amp;Supervisor{
        Manager: &amp;Manager{},
    }
}

type DepManager struct {
    *Manager
}

func (s *DepManager) HandlerRequest(r *Request) bool {

    if r.dayOff &gt; 2 &amp;&amp; r.dayOff &lt;=5 {
        fmt.Println(reflect.TypeOf(s).String() + &quot; Permit&quot;)
        return true
    }

    return s.SuperHandle(r)
}

func NewDepManager() *DepManager {
    return &amp;DepManager{
        Manager: &amp;Manager{},
    }
}

type CEO struct {
    *Manager
}

func (s *CEO) HandlerRequest(r *Request) bool {

    if r.dayOff &gt; 5 &amp;&amp; r.dayOff &lt;=22 {
        fmt.Println(reflect.TypeOf(s).String() + &quot; Permit&quot;)
        return true
    }

    return s.SuperHandle(r)
}

func NewCEO() *CEO{
    return &amp;CEO{
        Manager: &amp;Manager{},
    }
}

func TestRequestChain(t *testing.T) {
    c1 := NewCEO()
    c1.SetSuperior(nil)
    c2 := NewDepManager()
    c2.SetSuperior(c1)
    c3 := NewSupervisor()
    c3.SetSuperior(c2)

    request := &amp;Request{
        name: &quot;ming&quot;,
        reason: &quot;sick&quot;,
        dayOff: 23,
    }

    c3.HandlerRequest(request)
}
</code></pre>

<h4>python_code</h4>

<pre class="line-numbers"><code class="language-python">from abc import ABCMeta, abstractmethod

class Request(object):

    def __init__(self, name, reason, dayOff):
        self.name, self.reason, self.dayOff = name, reason, dayOff

class Responsible(metaclass=ABCMeta):

    @abstractmethod
    def HandleRequest(self, request):
        pass

    def __init__(self):
        self.__superior = None

    def set_superior(self, superior):
        self.__superior = superior

    def super_handler(self, request):
        if not self.__superior is None:
            return self.__superior.HandleRequest(request)

        print(&quot;out of power, reject&quot;)
        return False


class Supervisor(Responsible):

    def HandleRequest(self, request):
        if request.dayOff &gt; 0 and request.dayOff &lt;= 2:
           print(type(self).__name__ + &#39; permit&#39;)
           return True

        return self.super_handler(request)


class DepManager(Responsible):

    def HandleRequest(self, request):
        if request.dayOff &gt; 2 and request.dayOff &lt;= 5:
            print(type(self).__name__ + &#39; permit&#39;)
            return True

        return self.super_handler(request)

class CEO(Responsible):

    def HandleRequest(self, request):
        if request.dayOff &gt; 2 and request.dayOff &lt;= 5:
            print(type(self).__name__ + &#39; permit&#39;)
            return True

        return self.super_handler(request)


if __name__ == &#39;__main__&#39;:
    c1 = CEO()
    c2 = DepManager()
    c2.set_superior(c1)
    c3 = Supervisor()
    c3.set_superior(c2)

    req = Request(&quot;ming&quot;, &quot;sick&quot;, 2)
    c3.HandleRequest(req)
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/21 07:42 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15765398211231.html">
                
                  <h1>迭代器模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>动机</h4>

<ul>
<li><p>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访词其中包含的元素；同时这种“透明遍历”也为同一种算法在多种集合对象上进行操作”提供了可能。</p></li>
<li><p>使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。</p></li>
</ul>

<h4>要点总结</h4>

<ul>
<li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支</li>
<li>持同样的算法在不同的集合结构上进行操作。</li>
<li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/17 07:43 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755898090270.html">
                
                  <h1>Composite</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>Composite</h4>

<ul>
<li>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</li>
</ul>

<h4>动机</h4>

<ul>
<li>在软件在某些情況下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</li>
<li>如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象样来处理复杂的对象容器？</li>
</ul>

<h4>结构</h4>

<ul>
<li><img src="media/15755898090270/15807244643257.jpg" alt="" style="width:828px;"/></li>
</ul>

<h4>要点</h4>

<ul>
<li>Composite 模式采用树形结构来实现普遍存在的对象容器从 i 致地く意用）处運对案和对象容器无需笑心处的是单个的对象，还的对象容器。</li>
<li>将“客户代码与复杂的对象容器结构“解耦是 Composite 的核心，解耦之后，客户代码将与纯粹的抽象接口-而非对象容器的内部实现机构-产生依赖，从而更能应对变化</li>
<li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li>
</ul>

<h4>Cpp_demo</h4>

<pre class="line-numbers"><code class="language-cpp">//
// Created by 刘超 on 2019-12-06.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;

using namespace std;

class Component {
public:
    virtual ~Component(){};
    virtual void Operation() = 0;
};

class Composite : public Component {
public:
    Composite(const string&amp; _name) : name(_name) {}
    ~Composite() {}

    void Operation() {
        for (auto&amp; iter : comList) {
            std::cout &lt;&lt; &quot;Composite Operation&quot; &lt;&lt; std::endl;
            iter-&gt;Operation();
        }
    }
    void Add(Component* com) {
        comList.push_back(com);
    }
    void Remove(Component* com) {
        comList.remove(com);
    }

private:
    list&lt;Component*&gt; comList;
    string name;
};

class Leaf : public Component {
public:
    Leaf(const string&amp; name) : _name(name) {}
    ~Leaf() {
        cout &lt;&lt; &quot;Leaf::~leaf()&quot; &lt;&lt; endl;
    }
    void Operation() {
        std::cout &lt;&lt; name &lt;&lt; &quot; Operation&quot; &lt;&lt; std::endl;
    }

private:
    string _name;
};

int main() {
    Composite* root = new Composite(&quot;root&quot;);
    Composite* node1 = new Composite(&quot;node1&quot;);
    Composite* node2 = new Composite(&quot;node2&quot;);
    Composite* node3 = new Composite(&quot;node3&quot;);
    Composite* node4 = new Composite(&quot;node4&quot;);
    Leaf* lf1 = new Leaf(&quot;lf1&quot;);
    Leaf* lf2 = new Leaf(&quot;lf2&quot;);

    root-&gt;Add(node1);
    node1-&gt;Add(node2);
    node2-&gt;Add(lf1);

    root-&gt;Add(node3);
    node3-&gt;Add(node4);
    node4-&gt;Add(lf2);
    root-&gt;Operation();
}
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package design_pattern

import (
    &quot;fmt&quot;
)

type IComponent interface {
    Display(dep int)
}

func (l *Leaf) Display(dep int) {
    fmt.Println(RetString(dep) + l.name)
}

type Leaf struct {
    name string
}

func RetString(depth int) string {
    var ret []byte
    for i := 0; i &lt; depth; i++ {
        ret = append(ret, &#39;-&#39;)
    }

    return string(ret)
}

func NewLeaf(name string) *Leaf {
    return &amp;Leaf{name: name}
}

type Composite struct {
    name string
    comList map[IComponent]bool
}

func NewComposite(name string) *Composite {
    return  &amp;Composite{
        comList: make(map[IComponent]bool),
        name: name,
    }
}

func (c *Composite) Add(i IComponent) {
    c.comList[i] = true
}

func (c *Composite) Remove(i IComponent) {
    delete(c.comList, i)
}

func (c *Composite) Display(dep int) {

    fmt.Println(RetString(dep) + c.name)
    for k, _ := range c.comList {
        k.Display(dep + 1)
    }
}
</code></pre>

<h4>python_code</h4>

<pre class="line-numbers"><code class="language-python">from abc import ABCMeta, abstractmethod

class Component(metaclass=ABCMeta):

    @abstractmethod
    def display(self):
        pass

class Composite(Component):

    def __init__(self, name):
        self.com_list = []
        self.__name = name

    def add(self, com):
        self.com_list.append(com)

    def remove(self, com):
        self.com_list.remove(com)

    def display(self):
        print(&#39;{} display&#39;.format(self.__name))
        for com in self.com_list:
            com.display()

class Leaf(Component):

    def __init__(self, name):
        self.__name = name

    def display(self):
        print(&#39;{} display&#39;.format(self.__name))

if __name__ == &#39;__main__&#39;:
    root = Composite(&quot;root&quot;)

    node1 = Composite(&quot;node1&quot;)
    node2 = Composite(&quot;node2&quot;)
    node3 = Composite(&quot;node3&quot;)
    node4 = Composite(&quot;node4&quot;)

    lf1 = Leaf(&quot;lf1&quot;)
    lf2 = Leaf(&quot;lf2&quot;)
    lf3 = Leaf(&quot;lf3&quot;)

    root.add(node1)
    node1.add(node2)
    node2.add(lf1)

    root.add(node3)
    node3.add(node4)
    node4.add(lf2)

    root.add(node4)

    root.display()

    print(&quot;=============================&quot;)
    root.remove(node1)
    root.display()
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/06 07:50 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15755890034719.html">
                
                  <h1>Memento</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>定义</h4>

<ul>
<li>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化模式为这一问题提供了一种解决方案。</li>
</ul>

<h4>动机</h4>

<ul>
<li>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</li>
<li>如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性。</li>
</ul>

<h4>结构</h4>

<ul>
<li><p><img src="media/15755890034719/15815148061622.jpg" alt="" style="width:736px;"/></p></li>
<li><p>设计模式是94年</p></li>
<li><p>序列化的方案实现memento</p></li>
</ul>

<h5>golang_demo</h5>

<pre class="line-numbers"><code class="language-go">package design_pattern

type GameRole struct {
    atk, def, vit int
}

func (g *GameRole) InitState() {
    g.atk, g.def, g.vit = 100, 100, 100
}

func (g *GameRole) SaveState() *RoleMemento {
    return &amp;RoleMemento{g.atk, g.def, g.vit}
}

func (g *GameRole) ResumeState(m *RoleMemento) {
    g.atk, g.def, g.vit = m.atk, m.def, m.vit
}

func (g *GameRole) Fight() {
    g.atk, g.def, g.vit = 0, 0, 0
}

type RoleCaretaker struct {
    m *RoleMemento
}

type Originator struct {
    state string
}

type Memento struct {
    state string
}

type RoleMemento struct {
    vit, atk, def int
}

func (o *Originator) CreateMemento() *Memento {
    return &amp;Memento{o.state}
}

func (o *Originator) SetMemento(m *Memento) {
    o.state = m.state
}

type Caretaker struct {
    memento *Memento
}
</code></pre>

<h4>python_demo</h4>

<pre class="line-numbers"><code class="language-python">from abc import ABCMeta, abstractmethod

class Snapshot(object):

    def __init__(self, state):
        self.state = state


class Caretake(object):

    def __init__(self):
        pass

    def add_snapshot(self, snapshot):
        self.snapshot = snapshot

class Editor(object):

    def __init__(self, state):
        self.state = state

    def create_snapshot(self):
        return Snapshot(self.state)

    def recover_snapshot(self, snapshot):
        self.state = snapshot.state

    def change_state(self, state):
        self.state = state

if __name__ == &#39;__main__&#39;:
    editor = Editor(&quot;original&quot;)
    snapshot = editor.create_snapshot()
    print(editor.state)
    editor.change_state(&quot;state2&quot;)
    print(editor.state)
    editor.recover_snapshot(snapshot)
    print(editor.state)
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/06 07:36 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15748977610569.html">
                
                  <h1>State</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>定义</h4>

<ul>
<li>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化“模式为这一问题提供了一种解决方案。</li>
</ul>

<h4>典型模式</h4>

<ul>
<li>State</li>
<li>Memento</li>
</ul>

<h4>动机</h4>

<ul>
<li>在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</li>
<li>如何在运行时根据对象的状态来透明地更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？</li>
<li>虚函数本质上是运行态的if else</li>
</ul>

<h4>模式定义</h4>

<ul>
<li>允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。</li>
</ul>

<h4>结构</h4>

<ul>
<li><img src="media/15748977610569/15802943356618.jpg" alt="" style="width:799px;"/></li>
</ul>

<h4>要点总结</h4>

<ul>
<li>State 模式将所有与个特定状态相关的行为都放入ー个 State 的子<br/>
类对象中，往对象状态切換时应的对象但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。</li>
<li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的-即要么彻底转换过来，要么不转换</li>
<li>如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省开销</li>
</ul>

<h4>cpp_demo</h4>

<pre class="line-numbers"><code class="language-cpp">//
// Created by geraltliu on 2019-12-07.
//

#ifndef CPPCODE_STATE2_H
#define CPPCODE_STATE2_H
//
// Created by geraltliu on 2019-12-07.
//

#include &lt;iostream&gt;

//
// Created by 刘超 on 2019-11-28.
//

class NetworkState {
public:
    NetworkState *pNext;

    virtual void Operation1() = 0;

    virtual void Operation2() = 0;

    virtual void Operation3() = 0;

    virtual ~NetworkState() {}
};

class OpenState : public NetworkState {
    static NetworkState *m_instance;
public:
    static NetworkState *getInstance();

    void Operation1();

    void Operation2();

    void Operation3();
};


class CloseState : public NetworkState {
    static NetworkState *m_instance;
public:
    static NetworkState *getInstance();

    void Operation1();

    void Operation2();

    void Operation3();
};

class ConnectState : public NetworkState {
    static NetworkState *m_instance;
public:
    static NetworkState *getInstance();

    void Operation1();

    void Operation2();

    void Operation3();
};


class NetworkProcessor {
    NetworkState *pState;
public:
    NetworkProcessor(NetworkState *pState) {
        this-&gt;pState = pState;
    }

    void Operation1() {
        pState-&gt;Operation1();
        pState = pState-&gt;pNext;
    }

    void Operation2() {
        pState-&gt;Operation2();
        pState = pState-&gt;pNext;
    }

    void Operation3() {
        pState-&gt;Operation3();
        pState = pState-&gt;pNext;
    }
};

#endif //CPPCODE_STATE2_H

//
// Created by geraltliu on 2019-12-07.
//

#include &quot;state2.h&quot;

//
// Created by 刘超 on 2019-11-28.
//

NetworkState *OpenState::m_instance = nullptr;
NetworkState *OpenState::getInstance() {
    if (m_instance == nullptr) {
        m_instance = new OpenState();
    }
    return m_instance;
}


void OpenState::Operation1() {
    pNext = OpenState::getInstance();
    std::cout &lt;&lt; &quot;switch to open&quot; &lt;&lt; std::endl;
}

void OpenState::Operation2() {
    pNext = ConnectState::getInstance();
    std::cout &lt;&lt; &quot;switch to connect&quot; &lt;&lt; std::endl;
}

void OpenState::Operation3() {
    pNext = CloseState::getInstance();
    std::cout &lt;&lt; &quot;switch to close&quot; &lt;&lt; std::endl;
}


NetworkState *CloseState::m_instance = nullptr;
NetworkState *CloseState::getInstance() {
    if (m_instance == nullptr) {
        m_instance = new OpenState();
    }
    return m_instance;
}

void CloseState::Operation1() {
    pNext = OpenState::getInstance();
    std::cout &lt;&lt; &quot;switch to open&quot; &lt;&lt; std::endl;
}

void CloseState::Operation2() {
    pNext = ConnectState::getInstance();
    std::cout &lt;&lt; &quot;switch to connect&quot; &lt;&lt; std::endl;
}

void CloseState::Operation3() {
    pNext = CloseState::getInstance();
    std::cout &lt;&lt; &quot;switch to close&quot; &lt;&lt; std::endl;
}

NetworkState *ConnectState::m_instance = nullptr;
NetworkState *ConnectState::getInstance() {
    if (m_instance == nullptr) {
        m_instance = new OpenState();
    }
    return m_instance;
}

void ConnectState::Operation1() {
    pNext = OpenState::getInstance();
    std::cout &lt;&lt; &quot;switch to open&quot; &lt;&lt; std::endl;
}

void ConnectState::Operation2() {
    pNext = ConnectState::getInstance();
    std::cout &lt;&lt; &quot;switch to connect&quot; &lt;&lt; std::endl;
}

void ConnectState::Operation3() {
    pNext = CloseState::getInstance();
    std::cout &lt;&lt; &quot;switch to close&quot; &lt;&lt; std::endl;
}

int main() {
    NetworkProcessor *process = new NetworkProcessor(new ConnectState());
    process-&gt;Operation1();
    process-&gt;Operation2();
    process-&gt;Operation3();
}
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package geek

import &quot;fmt&quot;

type Week interface {
    Today()
    Next(*DayContext)
}

type DayContext struct {
    today Week
}

func NewDayContext() *DayContext {
    return &amp;DayContext{
        today: &amp;Sunday{},
    }
}

func (d *DayContext) Today() {
    d.today.Today()
}

func (d *DayContext) Next() {
    d.today.Next(d)
}

type Sunday struct{}

func (*Sunday) Today() {
    fmt.Println(&quot;Sunday&quot;)
}

func (*Sunday) Next(ctx *DayContext) {
    ctx.today = &amp;Monday{}
}

type Monday struct{}

func (*Monday) Today() {
    fmt.Println(&quot;Monday&quot;)
}

func (*Monday) Next(ctx *DayContext) {
    ctx.today = &amp;Monday{}
}

type Tuesday struct{}

func (*Tuesday) Today() {
    fmt.Println(&quot;Tuesday&quot;)
}

func (*Tuesday) Next(ctx *DayContext) {
    ctx.today = &amp;Tuesday{}
}
func TestWeek(t *testing.T) {
    ctx := NewDayContext()
    todayAndNext := func() {
        ctx.Today()
        ctx.Next()
    }

    for i := 0; i &lt; 3; i++ {
        todayAndNext()
    }
}
</code></pre>

<h4>golang_demo2</h4>

<pre class="line-numbers"><code class="language-go">package design_pattern

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

var (
    openState    *OpenState
    connectState *ConnectState
    closeState   *CloseState
    stateCtx     *StateContext
    open         sync.Once
    conn         sync.Once
    close        sync.Once
    state        sync.Once
)

type NetWorkState interface {
    State()
    Next(*StateContext)
}

type StateContext struct {
    netState NetWorkState
}

func GetStateCtxInstance() *StateContext {
    state.Do(func () {
        stateCtx = &amp;StateContext{
            netState: &amp;OpenState{},
        }
    })
    return stateCtx
}

func (s *StateContext) State() {
    s.netState.State()
}

func (s *StateContext) Next() {
    s.netState.Next(s)
}

type OpenState struct{}

func GetOpenInstance() *OpenState {
    open.Do(func() {
        openState = &amp;OpenState{}
    })
    return openState
}

func (o *OpenState) State() {
    fmt.Println(&quot;OpenState&quot;)
}

func (o *OpenState) Next(ctx *StateContext) {
    ctx.netState = GetConnectInstance()
}

type ConnectState struct{}

func GetConnectInstance() *ConnectState {
    conn.Do(func() {
        connectState = &amp;ConnectState{}
    })
    return connectState
}

func (o *ConnectState) State() {
    fmt.Println(&quot;ConnectState&quot;)
}

func (o *ConnectState) Next(ctx *StateContext) {
    ctx.netState = GetCloseInstance()
}

type CloseState struct{}

func GetCloseInstance() *CloseState {
    close.Do(func() {
        closeState = &amp;CloseState{}
    })
    return closeState
}

func (o *CloseState) State() {
    fmt.Println(&quot;CloseState&quot;)
}

func (o *CloseState) Next(ctx *StateContext) {
    ctx.netState = GetOpenInstance()
}


func TestState(t *testing.T) {
    stateCtx = GetStateCtxInstance()
    stateCtx.State()
    stateCtx.Next()

    stateCtx.State()
    stateCtx.Next()

    stateCtx.State()
    stateCtx.Next()

    stateCtx.State()
    stateCtx.Next()
}
</code></pre>

<h4>python_code</h4>

<pre class="line-numbers"><code class="language-python">from abc import abstractmethod, ABCMeta

class Week(metaclass=ABCMeta):
   @abstractmethod
   def today(self):
      pass

   def next(self, context):
      pass

class DayContext(object):

   def __init__(self, day):
      self.day = day

   def today(self):
      self.day.today()

   def next(self):
      self.day.next(self)

class Sunday(Week):

    def today(self):
       print(&quot;Sunday&quot;)

    def next(self, context):
       context.day = Monday()


class Monday(Week):

   def today(self):
      print(&quot;Tuesday&quot;)

   def next(self, context):
      context.day = Tuesday()


class Tuesday(Week):

   def today(self):
      print(&quot;Tuesday&quot;)

   def next(self, context):
      context.day = Wensday()


class Wensday(Week):

   def today(self):
      print(&quot;Wensday&quot;)

   def next(self, context):
      context.day = Friday()

class Friday(Week):

   def today(self):
      print(&quot;Friday&quot;)

   def next(self, context):
      context.day = Sunday()

if __name__ == &#39;__main__&#39;:
  context = DayContext(Sunday())
  context.today()
  context.next()
  context.today()
</code></pre>

<h4>python_demo3</h4>

<pre class="line-numbers"><code class="language-python">from abc import ABCMeta, abstractmethod


class Context(metaclass=ABCMeta):

    def __init__(self):
        self.__states = []
        self.__cur_state = None
        self.__temperature = 0

    def add_state(self, state):

        if state not in self.__states:
            self.__states.append(state)

    def change_state(self, state):

        if state is None:
            return False

        if self.__cur_state is None:
            print(&quot;init state {}&quot;.format(state.get_name()))
        else:
            print(&quot;change from {} to {}&quot;.format(self.__cur_state.get_name(),
                                                state.get_name()))
        self.__cur_state = state
        self.add_state(state)
        return True

    def get_state(self):
        return self.__cur_state


    def _set_temperature(self, temperature):
        self.__temperature = temperature
        for state in self.__states:
            if state.is_match(temperature):
                self.change_state(state)

    def _get_temperature(self):
        return self.__temperature

class Water(Context):

    def __init__(self):
        super().__init__()
        self.add_state(SolidState(&#39;Solid&#39;))
        self.add_state(LiquidState(&#39;Liquid&#39;))
        self.add_state(GaseousState(&#39;Gaseous&#39;))
        self.set_temperature(25)

    def set_temperature(self, temp):
        self._set_temperature(temp)

    def get_temperature(self):
        return self._get_temperature()

    def rise_temperature(self, step):
        self.set_temperature(self.get_temperature() + step)

    def reduce_temperature(self, step):
        self.set_temperature(self.get_temperature() - step)

    def behavior(self):
        state = self.get_state()
        if isinstance(state, State):
            state.behavior(self)

class State(metaclass=ABCMeta):

    def __init__(self, name):
        self.__name = name

    def get_name(self):
        return self.__name

    def is_match(self, temperature):
        return False

    @abstractmethod
    def behavior(self, context):
        pass


def singleton(cls, *args, **kwargs):
    instance = {}

    def __singleton(*args, **kwargs):
        if cls not in instance:
            instance[cls] = cls(*args, **kwargs)
        return instance[cls]

    return __singleton

@singleton
class SolidState(State):

    def __init__(self, name):
        super().__init__(name)


    def is_match(self, temperature):
        return temperature &lt; 0

    def behavior(self, context):
        print(&quot;SolidState current temperature {} C &quot;.format(
            context._get_temperature()))


@singleton
class LiquidState(State):

    def __init__(self, name):
        super().__init__(name)

    def is_match(self, temperature):
        return temperature &gt; 0 and temperature &lt; 100

    def behavior(self, context):
        print(&quot;LiquidState current temperature {} C &quot;.format(
            context._get_temperature()))

@singleton
class GaseousState(State):

    def __init__(self, name):
        super().__init__(name)

    def is_match(self, temperature):
        return temperature &gt;= 100

    def behavior(self, context):
        print(&quot;GaseousState current temperature {} C &quot;.format(
            context.get_temperature()))

if __name__ == &#39;__main__&#39;:
    # water = Water(LiquidState(&quot;Liquid&quot;))
    water = Water()
    water.behavior()
    water.set_temperature(-4)
    water.behavior()
    water.rise_temperature(100)
    water.behavior()
    water.set_temperature(120)
    water.behavior()
    water.set_temperature(180)
    water.behavior()
</code></pre>

<h4>golang_demo</h4>

<pre class="line-numbers"><code class="language-go">package desian_pattern_practise

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;sync&quot;
)

var  (
  once sync.Once
  liquidState *LiquidState
  solidState  *SolidState
    gaseousState *GaseousState
)


type Context interface {
    AddState(IState)
    ChangeState(IState)
}

type Water struct {
    states map[IState]bool
    curState IState
    temperature float64
}

func NewWater() *Water {
    water := &amp;Water{
        states: make(map[IState]bool),
        curState: nil,
        temperature: 25,
    }
    water.AddState(NewLiquidState(&quot;Liquid&quot;))
    water.AddState(NewSolidState(&quot;Solid&quot;))
    water.AddState(NewGaseousState(&quot;Gaseous&quot;))
    return water
}

func (w *Water) AddState(state IState) {
    if _, ok := w.states[state]; !ok {
      w.states[state] = true
    }
}

func (w *Water) ChangeState(state IState) {
    if state == nil {
        return
    }

    if w.curState == nil {
        fmt.Println(&quot;Init State &quot;, reflect.TypeOf(w).String())
    } else {
        fmt.Println(&quot;change from state &quot;, reflect.TypeOf(w.curState).String(),
            &quot; to state &quot;, reflect.TypeOf(state).String())
    }

    w.curState = state
    w.AddState(state)
}

func (w *Water) Behavior() {
    if w.curState != nil {
      w.curState.Behavior(w)
    }
}

func (w *Water) SetTemperature(temp float64) {
    w.temperature = temp
    for k, _ :=range w.states {
        if k.IsMatch(temp) {
            w.ChangeState(k)
        }
    }
}

func (w *Water) RiseTemperature(temp float64) {
    w.SetTemperature(w.temperature + temp)
}

func (w *Water) ReduceTemperature(temp float64) {
    w.SetTemperature(w.temperature - temp)
}

type IState interface {
    Behavior(Context)
    IsMatch(float64) bool
}

type State struct {
    name string
}

func (s *State) Behavior(ctx Context) {
}

type LiquidState struct {
    *State
}

func (l *LiquidState) IsMatch(temp float64) bool {
    return temp &gt; 0 &amp;&amp; temp &lt; 100;
}

func NewLiquidState(name string) *LiquidState {
    once.Do(func() {
        liquidState = &amp;LiquidState{State: &amp;State{name:name}}
    })
    return liquidState
}

func (l *LiquidState) Behavior(ctx Context) {
    fmt.Println(reflect.TypeOf(l).String() + &quot;current temperature is &quot;,
        ctx.(*Water).temperature, &quot; C&quot;)
}

type SolidState struct {
    *State
}

func (l *SolidState) IsMatch(temp float64) bool {
    return temp &lt;= 0;
}

func NewSolidState(name string) *SolidState {
    once.Do(func() {
        solidState = &amp;SolidState{State: &amp;State{name:name}}
    })
    return solidState
}

func (l *SolidState) Behavior(ctx Context) {
    fmt.Println(reflect.TypeOf(l).String() + &quot;current temperature is &quot;,
        ctx.(*Water).temperature, &quot; C&quot;)
}

type GaseousState struct {
    *State
}

func (l *GaseousState) IsMatch(temp float64) bool {
    return temp &gt;= 100;
}

func NewGaseousState(name string) *GaseousState {
    once.Do(func() {
        gaseousState = &amp;GaseousState{State: &amp;State{name:name}}
    })
    return gaseousState
}

func (l *GaseousState) Behavior(ctx Context) {
    fmt.Println(reflect.TypeOf(l).String() + &quot;current temperature is &quot;,
        ctx.(*Water).temperature, &quot; C&quot;)
}

func TestState_Behavior(t *testing.T) {
    water := NewWater()
    water.Behavior()
    water.SetTemperature(-4)
    water.Behavior()
    water.SetTemperature(100)
    water.Behavior()
    water.ReduceTemperature(50)
    water.Behavior()
}
</code></pre>

<h4>cpp_demo</h4>

<pre class="line-numbers"><code class="language-cpp">//
// Created by eredinliu on 2020-01-30.
//

#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;

using namespace std;

class LiquidState;
class GaseousState;
class SolidState;

class Context;

class State {
public:
    virtual bool IsMatch(float temperature) = 0;
    virtual void Behavior(Context* ctx) = 0;
    State(const string&amp; _name) : name(_name) {}
private:
    string name;
    friend class Context;
};

class Context {

public:
    void AddState(State* state) {
        if (find(states.begin(), states.end(), state) == states.end()) {
            states.push_back(state);
        }
    }
    void ChangeState(State* state) {
        if (state == nullptr) {
            return;
        }

        if (cur_state == nullptr) {
            cout &lt;&lt; &quot;init state &quot; &lt;&lt; state-&gt;name &lt;&lt; endl;
        } else {
            if (cur_state != state) {
                cout &lt;&lt; &quot;change from &quot; &lt;&lt; this-&gt;cur_state-&gt;name &lt;&lt; &quot; to &quot; &lt;&lt;
                     state-&gt;name &lt;&lt; endl;
            }
        }

        cur_state = state;
        states.push_back(cur_state);
    }

    virtual void Behavior() = 0;

protected:
    State* cur_state;
    list&lt;State*&gt; states;
};

class Water : public Context {
public:
    Water();

    void SetTemperature(float temp) {
        temperature = temp;

        list&lt;State*&gt; tmp = states;
        for (auto&amp; it : tmp) {
            if (it-&gt;IsMatch(temp)) {
                ChangeState(it);
            }
        }
    }

    float GetTemperature() {
        return this-&gt;temperature;
    }

    void RiseTemperature(float temp) {
        SetTemperature(this-&gt;temperature + temp);
    }

    void ReduceTemperature(float temp) {
        SetTemperature(this-&gt;temperature - temp);
    }


    void Behavior() {
        if (cur_state != nullptr) {
          cur_state-&gt;Behavior(this);
        }
    }
private:
    float temperature = 25;
};

class SolidState : public State {
public:
    bool IsMatch(float temp) {
        return temp &lt;= 0;
    }

    void Behavior(Context* ctx) {
        Water* water = reinterpret_cast&lt;Water*&gt;(ctx);
        cout &lt;&lt; &quot;SolidState current temperature &quot; &lt;&lt; water-&gt;GetTemperature()
            &lt;&lt; &quot; C &quot; &lt;&lt; endl;
    }

    static State* GetInstance() {
        static std::once_flag flag;
        call_once(flag, [&amp;](){solidState = new SolidState(&quot;SolidState&quot;);});
        return solidState;
    }

    static State* solidState;
private:
    SolidState(const string&amp; _name) : State(_name) {}
};

class LiquidState : public State {
public:
    bool IsMatch(float temp) {
        return temp &gt; 0 &amp;&amp; temp &lt; 100;
    }

    void Behavior(Context* ctx) {
        Water* water = reinterpret_cast&lt;Water*&gt;(ctx);
        cout &lt;&lt; &quot;LiquidState current temperature &quot; &lt;&lt; water-&gt;GetTemperature()
             &lt;&lt; &quot; C &quot; &lt;&lt; endl;
    }

    static State* GetInstance() {
        static std::once_flag flag;
        call_once(flag, [&amp;](){liquidState = new LiquidState(&quot;LiquidState&quot;);});
        return liquidState;
    }

    static State* liquidState;
private:
    LiquidState(const string&amp; _name) : State(_name) {}
};


class GaseousState : public State {
public:
    bool IsMatch(float temp) {
        return temp &gt; 100;
    }

    void Behavior(Context* ctx) {
        Water* water = reinterpret_cast&lt;Water*&gt;(ctx);
        cout &lt;&lt; &quot;GaseousState current temperature &quot; &lt;&lt; water-&gt;GetTemperature()
             &lt;&lt; &quot; C &quot; &lt;&lt; endl;
    }

    static State* GetInstance() {
        static std::once_flag flag;
        call_once(flag, [&amp;](){gaseousState = new GaseousState(&quot;GaseousState&quot;);});
        return gaseousState;
    }

    static State* gaseousState;
private:
    GaseousState(const string&amp; _name) : State(_name) {}
};

State* LiquidState::liquidState = nullptr;
State* GaseousState::gaseousState = nullptr;
State* SolidState::solidState = nullptr;

Water::Water() : Context() {
    this-&gt;states.push_back(LiquidState::GetInstance());
    this-&gt;states.push_back(SolidState::GetInstance());
    this-&gt;states.push_back(GaseousState::GetInstance());
}

int main() {
    Water* water = new Water();
    water-&gt;Behavior();
    water-&gt;SetTemperature(50);
    water-&gt;Behavior();
    water-&gt;SetTemperature(-4);
    water-&gt;Behavior();
    water-&gt;SetTemperature(50);
    water-&gt;Behavior();
    water-&gt;SetTemperature(120);
    water-&gt;Behavior();
    water-&gt;RiseTemperature(30);
    water-&gt;Behavior();
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/28 07:36 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="设计模式_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>eredin-blog</h1>
                <div class="site-des">生命的意义是成为你自己！</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html"><strong>C++基础与提高</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html"><strong>设计模式之美</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
        
            <a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Linux性能优化实战</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15814649492497.html">Simple Factory</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814189410719.html">代码的可测试性</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814188057978.html">重构</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813811739408.html">tuple 使用</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813101435484.html">列表&字典&集合进阶用法</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
