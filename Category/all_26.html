<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  eredin-blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="eredin-blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; eredin-blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Prometheus.html">Prometheus</a></li>
        
            <li><a href="RocketMQ.html">RocketMQ</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html">网络协议</a></li>
        
            <li><a href="Golang.html">Golang</a></li>
        
            <li><a href="Django.html">Django</a></li>
        
            <li><a href="C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98.html">C++设计模式实战</a></li>
        
            <li><a href="%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes.html">深入剖析Kubernetes</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html">数据结构和算法</a></li>
        
            <li><a href="%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务</a></li>
        
            <li><a href="%E6%9E%B6%E6%9E%84.html">架构</a></li>
        
            <li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">操作系统原理</a></li>
        
            <li><a href="Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Mysql优化实战</a></li>
        
            <li><a href="Kafka.html">Kafka</a></li>
        
            <li><a href="linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html">linux服务器研发</a></li>
        
            <li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html">计算机组成原理</a></li>
        
            <li><a href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html">程序员的自我修养</a></li>
        
            <li><a href="C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6.html">C语言进阶</a></li>
        
            <li><a href="http_study.html">http_study</a></li>
        
            <li><a href="%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html">玩转算法</a></li>
        
            <li><a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html">C++对象模型</a></li>
        
            <li><a href="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html">SQL必知必会</a></li>
        
            <li><a href="Zookeeper.html">Zookeeper</a></li>
        
            <li><a href="Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html">Redis从入门到精通</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6.html">数据结构和算法进阶</a></li>
        
            <li><a href="Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">Mysql性能管理和架构设计</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html">网络编程实战</a></li>
        
            <li><a href="Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html">Redis高并发缓存</a></li>
        
            <li><a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html">C++基础与提高</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html">设计模式之美</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
        
            <li><a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Linux性能优化实战</a></li>
        
            <li><a href="%E5%80%99%E6%8D%B7STL.html">候捷STL</a></li>
        
            <li><a href="%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE.html">性能工程高手课</a></li>
        
            <li><a href="%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html">性能测试</a></li>
        
            <li><a href="ElasticSearch.html">ElasticSearch</a></li>
        
            <li><a href="RabbitMQ.html">RabbitMQ</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15666360771756.html">
                
                  <h1>对象构造语义学</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>对象构造</h4>

<ul>
<li>构造函数中你自己的代码中使用诸如memcpy或者直接操作等手段，来修改虚函数表指针的值，否则，调用虚函数时就可能造成系统崩溃；</li>
</ul>

<h4>构造函数对虚函数的调用</h4>

<ul>
<li>某个类的构造函数 中 调用一个虚函数，那么走的不是虚函数表，而是直接调用。</li>
<li>从类中开始找，然后在父类中找</li>
</ul>

<h4>对象复制语义学，析构函数语义学</h4>

<ul>
<li>默认的对象赋值行为</li>
</ul>

<h4>析构函数语义</h4>

<ul>
<li>析构函数被合成</li>
</ul>

<h5>合成情况</h5>

<ul>
<li>继承一个基类，基类带析构函数，编译器会帮忙合成</li>
<li>如果类成员是一个类类型成员，成员带析构函数，编译器会合成一个析构函数</li>
</ul>

<h5>析构函数被扩展</h5>

<ul>
<li>如果我们有自己的析构函数，编译器会扩展析构函数</li>
<li>如果类成员是一个类类型成员，并且自带析构函数，编译器会扩展类A的析构函数代码</li>
<li>先执行类A的析构函数，再执行成员函数析构函数</li>
<li>如果继承一个基类，基类中带析构函数，编译器会扩展A类的析构函数来调用基类的析构函数</li>
<li>虚基类扩展</li>
</ul>

<h4>局部对象和全局对象的构造和析构</h4>

<ul>
<li>全局对象构造和析构的步骤：<br/>
a)全局对象g_aobj获得地址（编译时确定好的，内存也是编译时分配好的，内存时运行期间一直存在）<br/>
b)把全局对象g_aobj的内存内容清0的能力（也叫静态初始化）<br/>
c)调用全局对象g_aobj所对应的类A的构造函数</li>
<li>如何保证静态局部对象只被构造一次</li>
<li>编译器通过设置标记的方式</li>
<li>如何来析构局部对象</li>
<li>局部静态对象只会被构造一次，在调用的时候构造；在main函数执行完毕后析构</li>
</ul>

<h4>malloc</h4>

<ul>
<li>分配0个字节</li>
</ul>

<h4>new和delete进一步认识</h4>

<ul>
<li>A *pa = new A()会清零部分内存，如果有构造函数则不会清零</li>
<li>A *pa = new A不会清零</li>
</ul>

<h4>new干了啥</h4>

<ul>
<li>operator new</li>
<li>malloc</li>
<li>A::A()</li>
</ul>

<h4>delete</h4>

<ul>
<li>A::~A()</li>
<li>operator delete()</li>
<li>free</li>
</ul>

<h4>嵌入式指针</h4>

<ul>
<li>一般应用在内存池代码</li>
<li>成功使用有个前提条件</li>
<li>借用了A对象占用的内存空间的前四个字节，4个字节用来链住空闲的内存块，一旦被分配</li>
<li>出去，这个块的前四个字节就不再需要，四个字节就可以使用</li>
</ul>

<pre class="line-numbers"><code class="language-text">struct obj {
  struct obj* next; //next就是个嵌入式指针
}
</code></pre>

<h4>placement new</h4>

<ul>
<li>只有new没有delete</li>
<li>在已经分配的原始内存中初始化一个对象</li>
<li>定位new不分配内存</li>
<li>初始化对象</li>
<li>在预先分配号的内存中分配一个对象</li>
<li>new (address) 类类型</li>
</ul>

<pre class="line-numbers"><code class="language-text">void *memPtr = (void*)new char[sizeof(A)];
  A* obj = new (memPtr) A();

  void *memPtr2 = (void*)new char[sizeof(A)];
  A* obj2 = new (memPtr2) A();

  obj-&gt;~A();
  obj2-&gt;~A();

  delete[](void*)obj;
  delete[](void*)obj2;
</code></pre>

<h4>多版本的operator new</h4>

<ul>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/24 16:41 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15665280444092.html">
                
                  <h1>二叉树和递归</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>天然递归结构</h4>

<ul>
<li>空也是一棵二叉树</li>
<li>是否存在键值</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">bool contain(Node8 node, Key key) {
  if (!node) return false;
  
  if (key == node-&gt;key) return true;
  
  if(contain(node-&gt;left, key) ||
     contain(node-&gt;right, key)) return true;
  return false;
}
</code></pre>

<ul>
<li>leet_104</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));
    }
};
</code></pre>

<ul>
<li>leet_111</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a binary tree, find its minimum depth.
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        if (!root-&gt;left) return 1 + minDepth(root-&gt;right);
        if (!root-&gt;right) return 1 + minDepth(root-&gt;left);
        return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right));
    }
};
</code></pre>

<ul>
<li>leet_226</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Invert a binary tree.

     4
   /   \
  2     7
 / \   / \
1   3 6   9

to
     4
   /   \
  7     2
 / \   / \
9   6 3   1

// Recursion
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) return NULL;
        TreeNode *tmp = root-&gt;left;
        root-&gt;left = invertTree(root-&gt;right);
        root-&gt;right = invertTree(tmp);
        return root;
    }
};

// Non-Recursion
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) return NULL;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while (!q.empty()) {
            TreeNode *node = q.front(); q.pop();
            TreeNode *tmp = node-&gt;left;
            node-&gt;left = node-&gt;right;
            node-&gt;right = tmp;
            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }
        return root;
    }
};
</code></pre>

<ul>
<li>leet_100</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">判断两棵树是否相同
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if (!p &amp;&amp; !q) return true;
        if ((p &amp;&amp; !q) || (!p &amp;&amp; q) || (p-&gt;val != q-&gt;val)) return false;
        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre>

<ul>
<li>leet_101</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3

class Solution {
public:
    bool isSymmetric(TreeNode *root) {
        if (!root) return true;
        return isSymmetric(root-&gt;left, root-&gt;right);
    }
    bool isSymmetric(TreeNode *left, TreeNode *right) {
        if (!left &amp;&amp; !right) return true;
        if (left &amp;&amp; !right || !left &amp;&amp; right || left-&gt;val != right-&gt;val) return false;
        return isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left);
    }
    
};
</code></pre>

<ul>
<li>leet_222</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a complete binary tree, count the number of nodes.
Input: 
    1
   / \
  2   3
 / \  /
4  5 6

Output: 6
由 root 根结点往下，分别找最靠左边和最靠右边的路径长度，如果长度相等，则证明二叉树最后一层节点是满的，是满二叉树，直接返回节点个数，如果不相等，则节点个数为左子树的节点个数加上右子树的节点个数再加1(根节点)，

class Solution {
public:
    int countNodes(TreeNode* root) {
        int hLeft = leftHeight(root);
        int hRight = rightHeight(root);
        if (hLeft == hRight) return pow(2, hLeft) - 1;
        return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;
    }
    int leftHeight(TreeNode* root) {
        if (!root) return 0;
        return 1 + leftHeight(root-&gt;left);
    }
    int rightHeight(TreeNode* root) {
        if (!root) return 0;
        return 1 + rightHeight(root-&gt;right);
    }
};

class Solution {
public:
    int countNodes(TreeNode* root) {
        int res = 0, h = getHeight(root);
        if (h &lt; 0) return 0;
        if (getHeight(root-&gt;right) == h - 1) return (1 &lt;&lt; h) + countNodes(root-&gt;right);
        return (1 &lt;&lt; (h - 1)) + countNodes(root-&gt;left);
    }
    int getHeight(TreeNode* node) {
        return node ? (1 + getHeight(node-&gt;left)) : -1;
    }
};
</code></pre>

<ul>
<li>leet_110</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a binary tree, determine if it is height-balanced.
class Solution {
public:    
    bool isBalanced(TreeNode *root) {
        if (checkDepth(root) == -1) return false;
        else return true;
    }
    int checkDepth(TreeNode *root) {
        if (!root) return 0;
        int left = checkDepth(root-&gt;left);
        if (left == -1) return -1;
        int right = checkDepth(root-&gt;right);
        if (right == -1) return -1;
        int diff = abs(left - right);
        if (diff &gt; 1) return -1;
        else return 1 + max(left, right);
    }
};
</code></pre>

<ul>
<li>leet_112</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1

class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (!root) return false;
        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == sum ) return true;
        return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);
    }
};
</code></pre>

<ul>
<li>leet_111</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a binary tree, find its minimum depth.
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        if (!root-&gt;left) return 1 + minDepth(root-&gt;right);
        if (!root-&gt;right) return 1 + minDepth(root-&gt;left);
        return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right));
    }
};
</code></pre>

<ul>
<li>leet_404</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Find the sum of all left leaves in a given binary tree.
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return 0;
        int res = 0;
        helper(root-&gt;left, true, res);
        helper(root-&gt;right, false, res);
        return res;
    }
    void helper(TreeNode* node, bool left, int&amp; res) {
        if (!node) return;
        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; left) res += node-&gt;val;
        helper(node-&gt;left, true, res);
        helper(node-&gt;right, false, res);
    }
};

class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return 0;
        int res = 0;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while (!q.empty()) {
            TreeNode *t = q.front(); q.pop();
            if (t-&gt;left &amp;&amp; !t-&gt;left-&gt;left &amp;&amp; !t-&gt;left-&gt;right) res += t-&gt;left-&gt;val;
            if (t-&gt;left) q.push(t-&gt;left);
            if (t-&gt;right) q.push(t-&gt;right);
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_257</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">For example, given the following binary tree:
   1
 /   \
2     3
 \
  5
All root-to-leaf paths are:
[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

class Solution {
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
        vector&lt;string&gt; res;
        if (root) helper(root, &quot;&quot;, res);
        return res;
    }
    void helper(TreeNode* node, string out, vector&lt;string&gt;&amp; res) {
        if (!node-&gt;left &amp;&amp; !node-&gt;right) res.push_back(out + to_string(node-&gt;val));
        if (node-&gt;left) helper(node-&gt;left, out + to_string(node-&gt;val) + &quot;-&gt;&quot;, res);
        if (node-&gt;right) helper(node-&gt;right, out + to_string(node-&gt;val) + &quot;-&gt;&quot;, res);
    }
};
</code></pre>

<ul>
<li>leet_113</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
return
[
   [5,4,11,2],
   [5,8,4,5]
]

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; out;
        helper(root, sum, out, res);
        return res;
    }
    void helper(TreeNode* node, int sum, vector&lt;int&gt;&amp; out, vector&lt;vector&lt;int&gt;&gt;&amp; res) {
        if (!node) return;
        out.push_back(node-&gt;val);
        if (sum == node-&gt;val &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right) {
            res.push_back(out);
        }
        helper(node-&gt;left, sum - node-&gt;val, out, res);
        helper(node-&gt;right, sum - node-&gt;val, out, res);
        out.pop_back();
    }
};
</code></pre>

<ul>
<li>leet_129</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1-&gt;2 represents the number 12.
The root-to-leaf path 1-&gt;3 represents the number 13.
Therefore, sum = 12 + 13 = 25.

class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return sumNumbersDFS(root, 0);
    }
    int sumNumbersDFS(TreeNode* root, int sum) {
        if (!root) return 0;
        sum = sum * 10 + root-&gt;val;
        if (!root-&gt;left &amp;&amp; !root-&gt;right) return sum;
        return sumNumbersDFS(root-&gt;left, sum) + sumNumbersDFS(root-&gt;right, sum);
    }
};
</code></pre>

<h4>二分搜索树</h4>

<ul>
<li>leet_235</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root) return NULL;
        if (root-&gt;val &gt; max(p-&gt;val, q-&gt;val)) 
            return lowestCommonAncestor(root-&gt;left, p, q);
        else if (root-&gt;val &lt; min(p-&gt;val, q-&gt;val)) 
            return lowestCommonAncestor(root-&gt;right, p, q);
        else return root;
    }
};
</code></pre>

<ul>
<li>leet_98</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a binary tree, determine if it is a valid binary search tree (BST).

class Solution {
public:
  bool isValidBST(TreeNode* root) {
    return isValidBST(root, nullptr, nullptr);
  }

  bool isValidBST(TreeNode* root, TreeNode* min, TreeNode* max) {
    if (!root) return true;

    if (min &amp;&amp; min-&gt;val &gt;= root-&gt;val || max &amp;&amp; max-&gt;val &lt;= root-&gt;val)
      return false;

    return isValidBST(root-&gt;left, min, root) &amp;&amp; isValidBST(root-&gt;right, root, max);
  } 
};
</code></pre>

<ul>
<li>leet_450</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the following BST.

    5
   / \
  4   6
 /     \
2       7

class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root) return NULL;
        if (root-&gt;val &gt; key) {
            root-&gt;left = deleteNode(root-&gt;left, key);
        } else if (root-&gt;val &lt; key) {
            root-&gt;right = deleteNode(root-&gt;right, key);
        } else {
            if (!root-&gt;left || !root-&gt;right) {
                root = (root-&gt;left) ? root-&gt;left : root-&gt;right;
            } else {
                TreeNode *cur = root-&gt;right;
                while (cur-&gt;left) cur = cur-&gt;left;
                root-&gt;val = cur-&gt;val;
                root-&gt;right = deleteNode(root-&gt;right, cur-&gt;val);
            }
        }
        return root;
    }
};
</code></pre>

<ul>
<li>leet_108</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        return helper(nums, 0 , (int)nums.size() - 1);
    }
    TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right) {
        if (left &gt; right) return NULL;
        int mid = left + (right - left) / 2;
        TreeNode *cur = new TreeNode(nums[mid]);
        cur-&gt;left = helper(nums, left, mid - 1);
        cur-&gt;right = helper(nums, mid + 1, right);
        return cur;
    }
};
</code></pre>

<ul>
<li>leet_230</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int cnt = 0;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (p || !s.empty()) {
            while (p) {
                s.push(p);
                p = p-&gt;left;
            }
            p = s.top(); s.pop();
            ++cnt;
            if (cnt == k) return p-&gt;val;
            p = p-&gt;right;
        }
        return 0;
    }
};
</code></pre>

<ul>
<li>leet_236</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
       if (!root || p == root || q == root) return root;
       TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);
       TreeNode *right = lowestCommonAncestor(root-&gt;right, p , q);
       if (left &amp;&amp; right) return root;
       return left ? left : right;
    }
};
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/23 10:40 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15665187356600.html">
                
                  <h1>kafka认证</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>认证机制</h4>

<ul>
<li>Broker和客户端的双路认证</li>
<li>SASL</li>
</ul>

<h4>对比</h4>

<ul>
<li>SASL/SCRAM支持用户的动态删减</li>
</ul>

<h4>SCRAM</h4>

<ul>
<li>创建broker </li>
</ul>

<pre class="line-numbers"><code class="language-text">  KafkaServer {
  org.apache.kafka.common.security.scram.ScramLoginModule required
  username=&quot;admin&quot;
  password=&quot;admin&quot;;
};--&gt;kafka_broker_jaas.conf
</code></pre>

<ul>
<li>启动broker</li>
</ul>

<pre class="line-numbers"><code class="language-text">export KAFKA_OPTS=-Djava.security.auth.login.config=/root/kafka_2.12-2.2.0/config/kafka_broker_jaas.conf &amp;&amp; kafka-server-start.sh server1.properties
</code></pre>

<ul>
<li>启动生产者</li>
</ul>

<pre class="line-numbers"><code class="language-text">producer.conf
security.protocol=SASL_PLAINTEXT
sasl.mechanism=SCRAM-SHA-256
sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username=&quot;writer&quot; password=&quot;writer&quot;; --&gt;producer.conf
kafka-console-producer.sh --broker-list master:9092,node1:9093 --topic test_ssl  --producer.config producer.conf
</code></pre>

<ul>
<li>启动消费者</li>
</ul>

<pre class="line-numbers"><code class="language-text">consumer.conf
security.protocol=SASL_PLAINTEXT
sasl.mechanism=SCRAM-SHA-256
sasl.jaas.config=org.apache.kafka.common.security.scram.ScramLoginModule required username=&quot;reader&quot; password=&quot;reader&quot;; --&gt;consumer.conf
kafka-console-consumer.sh --bootstrap-server master:9092,node1:9093 --topic test --from-beginning --consumer.config consumer.conf
</code></pre>

<ul>
<li>删除用户</li>
</ul>

<pre class="line-numbers"><code class="language-text">kafka-configs.sh --zookeeper localhost:2181 --alter --delete-config &#39;SCRAM-SHA-256&#39; --entity-type users --entity-name writer
kafka-configs.sh --zookeeper localhost:2181 --alter --delete-config &#39;SCRAM-SHA-512&#39; --entity-type users --entity-name writer
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/23 08:05 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Kafka.html'>Kafka</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15664703415424.html">
                
                  <h1>左值和右值</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>左值和右值</h4>

<ul>
<li>左值 能用在赋值语句=左边的东西</li>
<li>C++表达式要么是左值，要么是右值</li>
<li>i = i + 1 i有右值属性，i出现在左边，拥有左值属性</li>
<li>赋值运算符</li>
<li>取地址</li>
<li>string vector []左值 iter是迭代器</li>
<li>看一个运算符在一个字面值能不能操作</li>
<li>左值表达式 左值</li>
<li>右值表达式 右值</li>
</ul>

<h4>引用分类</h4>

<ul>
<li>左值引用 绑定到左值</li>
<li>const引用 左值引用</li>
<li>右值引用 绑定到右值，临时对象 </li>
</ul>

<h4>左值引用</h4>

<ul>
<li>左值引用不能绑定到右值</li>
<li>const 左值引用可以绑定到右值</li>
</ul>

<h4>右值引用</h4>

<ul>
<li>来绑定一些临时对象和即将销毁的对象</li>
<li>右值引用理解为对象</li>
<li>绑定到坐值的引用，一般都不能绑定到右值</li>
<li>&amp;&amp;代表新的数据类型</li>
<li>提高程序运行效率，把拷贝对象变成移动对象，转换对象的所有者</li>
<li>移动对象如何发生 移动构造函数，应付移动构造函数</li>
</ul>

<h4>总结</h4>

<ul>
<li>返回左值引用的函数，连同赋值，下标，解引用都是左值引用 --i </li>
<li>i-- 右值引用</li>
<li>++i ++i直接给变量i+1,然后返回i本身</li>
<li>i是变量，所以可以被赋值</li>
<li>右值引用的变量本身是左值</li>
<li>任何函数的行参都是左值func(int&amp;&amp; w) w是左值</li>
<li>临时对象都是右值</li>
<li>如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。</li>
</ul>

<h4>std::move</h4>

<ul>
<li>把一个左值强制转换成右值</li>
</ul>

<h4>指分左右</h4>

<p><img src="media/15808686074669/18b692072537d4ce179d3857a8a0133c.png" alt="18b692072537d4ce179d3857a8a0133"/></p>

<ul>
<li>一个 lvalue 是通常可以放在等号左边的表达式 左值</li>
<li>一个 rvalue 是通常只能放在等号右边的表达式，右值</li>
<li>一个 glvalue 是 generalized lvalue，广义左值</li>
<li>一个 xvalue 是 expiring lvalue，将亡值</li>
<li>一个 prvalue 是 pure rvalue，纯右值</li>
</ul>

<h4>对比</h4>

<pre class="line-numbers"><code class="language-cpp">smart_ptr&lt;shape&gt; ptr1{new circle()};
smart_ptr&lt;shape&gt; ptr2 = std::move(ptr1);
</code></pre>

<ul>
<li> std::move(ptr) 就有趣点了。它的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。从实用的角度，在我们这儿 std::move(ptr1) 等价于 static_cast<smart_ptr<shape>&amp;&amp;&gt;(ptr1)</li>
<li> 把 std::move(ptr1) 看作是一个有名字的右值。为了跟无名的纯右值 prvalue 相区别，C++ 里目前就把这种表达式叫做 xvalue。跟左值 lvalue 不同，xvalue 仍然是不能取地址的——这点上，xvalue 和 prvalue 相同。所以，xvalue 和 prvalue 都被归为右值 rvalue</li>
<li> <img src="media/15808686074669/15808730621501.jpg" alt="" style="width:583px;"/></li>
</ul>

<h4>字符串绑定</h4>

<pre class="line-numbers"><code class="language-cpp">string str{&quot;I love china&quot;};
  string&amp; s1{str};

  //左值引用不能绑定到临时变量,临时变量被系统当右值
  //string&amp; s2{&quot;I love china&quot;};
  //const引用绑定到右值，执行隐式转换并放入string临时变量
  const string&amp; s3{&quot;I love china&quot;};
  //string&amp;&amp; s4{s3};
  string&amp;&amp; s5{&quot;I love China&quot;};//可以绑定到一个临时变量，
</code></pre>

<h4>Move函数</h4>

<pre class="line-numbers"><code class="language-cpp">  int tmp = 10;
  int&amp; l1 = tmp;
  int&amp;&amp; l2 = tmp * 100;
  const int&amp; l4 = i * 100;
  const int&amp;&amp; r5 = i * 100;
  //成功绑定右值,但是此后r6的值和tmp没有关系
  int&amp;&amp; r6 = tmp++;
  tmp = 12;
  printf(&quot; %d %d \n&quot;, r6, tmp);
  int&amp;&amp; r7 = std::move(tmp);
  r7 = 35;
  printf(&quot; %d %d \n&quot;, r7, tmp);

  int&amp;&amp; r8 = 100;
  int&amp;&amp; r9 = std::move(r8);
  printf(&quot; %d %d \n&quot;, r8, r9);

  string st = &quot;Im ok&quot;;
  //sring移动构造函数把st的内容拷贝到def，def重新开辟内存,同时把st清空
  //string def = std::move(st);
  //sring移动构造函数把st的内容拷贝到def，def重新开辟内存,同时把st清空
  string&amp;&amp; sr  = std::move(st);
  cout &lt;&lt; sr &lt;&lt; &quot; &quot; &lt;&lt; st &lt;&lt; endl;
</code></pre>

<h4>返回值优化</h4>

<ul>
<li>一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO</li>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/22 18:39 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15664699170964.html">
                
                  <h1>继承关系</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>final</h4>

<ul>
<li>不能再继续继承下去</li>
</ul>

<h4>静态类型和动态类型</h4>

<ul>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/22 18:31 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15663826839072.html">
                
                  <h1>RTTI dynamic_cat typeid 虚函数表</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>RTTI</h4>

<ul>
<li>运行时类型识别</li>
<li>dynamic_cast 能够将基类的指针转为派生类的指针或者引用</li>
<li>typeid 返回指针或者引用指向的实际类型</li>
<li>想让RTTI正常工作，基类中必须有虚函数，只有虚函数存在才会使用动态类型</li>
<li>对于引用会抛出std::bad_cast</li>
</ul>

<h4>typeid</h4>

<ul>
<li>拿到对象类型信息，typeid返回常量对象的引用，对象类型是const std::typeinfo&amp;</li>
<li>主要是为了比较两个指针指向的类型是否相同</li>
<li>指针定义的类型相同。不管new的是啥, typeid都相等</li>
</ul>

<pre class="line-numbers"><code class="language-text">Human* h1 = new Men;
Human* h2 = new Women;
typeid(h1) == typeid(h2)
</code></pre>

<ul>
<li>指针指向的类型是否相同</li>
</ul>

<pre class="line-numbers"><code class="language-text">Men* h1 = new Men;
Woman* h2 = new Men;
typeid(*h1) == typeid(*h2)
</code></pre>

<ul>
<li> 只有基类有虚函数的时候，编译器才会对表达式求值得</li>
</ul>

<h4>typeinfo</h4>

<ul>
<li></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/21 18:18 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15662867942391.html">
                
                  <h1>函数语义学</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>成员函数的调用方式</h4>

<ul>
<li>成员函数的调用转换成了全局的函数</li>
<li>成员函数有独立的内存地址，跟着类走的，成员函数的地址是编译时确定好的</li>
<li>编译器额外增加了一个this形参，指向生成的对象</li>
<li>常规成员变量的存取，都通过形参来进行。比如this-&gt;m_i</li>
</ul>

<h4>虚函数调用</h4>

<pre class="line-numbers"><code class="language-text">  class Obj{
 public:
  int m_i;
  void func(int abc) {
    m_i += abc;
  }
  void virtual virfunc1() {
    virfunc2(); //通过虚函数表指针来寻址
    Obj::virfunc2(); //效率高, 等价于调用普通函数
  }
  void virtual virfunc2() {}
};
pmyacls-&gt;myvirfunc(); //要通过虚函数表指针查找虚函数表，通过虚函数表在好到虚函数的入口地址，完成对虚函数的调用
    //编译器视角
    //(*pmyacls-&gt;vptr[0])(pmyacls);
    //a)vptr，编译器给生成的虚函数表指针，指向虚函数表
    //b)[0] 虚函数表中第一项。代表myvirfunc()地址
    //c)传递一个参数进去，就是this，也是编译器给加的
    //d)*就得到了虚函数的地址
</code></pre>

<h4>静态函数</h4>

<ul>
<li>各种调用方式都是类名调用</li>
<li>静态函数不需要this指针</li>
</ul>

<pre class="line-numbers"><code class="language-text">void func(int abc) {
    //m_i += abc;
    printf(&quot;func&quot;);
}
((Obj *)0)-&gt;func(2);可以执行
希望成员函数支持类对象之外的存取操作
//静态成员函数特性
    //a)静态成员函数没有this指针，这点最重要
    //b)无法直接存取类中普通的非静态成员变量；
    //c)静态成员函数不能在屁股后使用const，也不能设置为virtual 
    //d)可以用类对象调用，但不非一定要用类对象调用。
    //e)静态成员函数等同于非成员函数，有的需要提供回调函数的这种场合，可以将静态成员函数作为回调函数；
</code></pre>

<h4>继承的非虚函数坑</h4>

<pre class="line-numbers"><code class="language-text"> Derive derive;
    Derive *pderive = &amp;derive;
    pderive-&gt;myfunc(); //Derive::myfunc()子类

    Base *pbase = &amp;derive;
    pbase-&gt;myfunc();//调用父类
</code></pre>

<ul>
<li>普通成员函数是静态绑定，换句话说，myfunc() 是普通成员函数。这里到底调用父类的myfunc还是子类的myfunc取决于调用者的静态类型；</li>
</ul>

<h4>虚函数缺省参数的动态坑</h4>

<pre class="line-numbers"><code class="language-text">class Base
{
public:
    void myfunc() //普通成员函数
    {
        cout &lt;&lt; &quot;Base::myfunc()&quot; &lt;&lt; endl;
    }
    virtual void myvirfunc(int value = 1)
    {
        cout &lt;&lt; &quot;Base::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;
    }
};
class Derive :public Base
{
public:
    void myfunc() //普通成员函数
    {
        cout &lt;&lt; &quot;Derive::myfunc()&quot; &lt;&lt; endl;
    }
    virtual void myvirfunc(int value = 2)
    {
        cout &lt;&lt; &quot;Derive::myvirfunc(),value = &quot; &lt;&lt; value &lt;&lt; endl;
    }
};
</code></pre>

<ul>
<li>虚函数缺省参数是静态绑定，考虑到执行效率的问题</li>
<li>不要重新定义虚函数缺省参数的值</li>
<li>不应该在子类中重新定义一个继承来的非虚函数</li>
</ul>

<h4>多态</h4>

<ul>
<li>调用虚函数没有查询虚函数表，不一定是多态</li>
<li>有继承关系</li>
<li>父类指针或者引用指向子类对象</li>
<li>派生类重写了子类的虚函数</li>
</ul>

<h4>单继承</h4>

<pre class="line-numbers"><code class="language-text">Base* pb = new Derived()
pb-&gt;g()
编译器视角
(*pb)-&gt;vptr[1](pb)
</code></pre>

<ul>
<li>执行期间需要确定的就是哪个虚函数表来调用虚函数</li>
</ul>

<h4>回顾和一些测试</h4>

<ul>
<li>虚函数地址，编译期间确认下来</li>
<li>顺序记录每个虚函数的地址</li>
<li>vptr编译期间产生，编译器在构造函数中插入了给vptr赋值的代码。</li>
<li>纯虚函数依然会在虚函数表中占据一个表项目</li>
</ul>

<h4>多继承虚函数，第二基类，虚析构</h4>

<pre class="line-numbers"><code class="language-text">Base* pb2 = new Derived()
Derived* tmp = new Derived()
Base2* pb2 = (Base2*)((char*)tmp + sizeof(Base))
</code></pre>

<ul>
<li>如何成功删除用第二基类指针new出来的继承类对象</li>
<li>非虚析构函数仍然是个普通析构函数，系统释放的是pb2开头的内存仍然异常</li>
<li>Base2有个虚的析构函数则编译器实际执行~Derived(),~Base2(),Base()</li>
<li>Derived没有虚析构函数，编译器会为其合成虚析构函数，虚析构函数名可以跟父类不一样</li>
<li><img src="media/15662867942391/15663764207329.jpg" alt="" style="width:1174px;"/></li>
</ul>

<h4>thunk</h4>

<ul>
<li>汇编代码</li>
<li>在多重继承中用于this指针调整</li>
<li>调用Derived析构函数</li>
</ul>

<pre class="line-numbers"><code class="language-text">0000000000000044 &lt;non-virtual thunk to Derive::~Derive()&gt;:
  44:   48 83 ef 08             sub    rdi,0x8 this指针指向derived对象首地址
  48:   eb b6                   jmp    0 &lt;Derive::~Derive()&gt;
000000000000002b &lt;non-virtual thunk to Derive::~Derive()&gt;:
  2b:   48 83 ef 08             sub    rdi,0x8
  2f:   eb cf                   jmp    0 &lt;Derive::~Derive()&gt;
</code></pre>

<ul>
<li><img src="media/15662867942391/15663775575835.jpg" alt="" style="width:1112px;"/></li>
</ul>

<h4>多继承第二基类虚函数支持和虚继承带虚函数</h4>

<p>通过指向第二个基类的指针调用继承类的虚函数；<br/>
Base2 *pb2 = new Derive();<br/>
delete pb2; 调用继承类的虚析构函数<br/>
一个指向派生类的指针，调用第二个基类中的虚函数<br/>
Derive *pd2 = new Derive();<br/>
pd2-&gt;hBase2();<br/>
允许虚函数的返回值类型有所变化<br/>
Base2 *pb1 = new Derive(); pb1指向的是Base2子对象的首地址<br/>
Base2 *pb2 = pb1-&gt;clone(); Derive::clone();<br/>
执行clone()时，pb1首先会调整回指向Derivce对象的首地址，这样调用的是Derive版本的clone()</p>

<h4>虚继承带虚函数</h4>

<ul>
<li><img src="media/15662867942391/15663819139099.jpg" alt="" style="width:378px;"/></li>
</ul>

<h4>RTTI</h4>

<ul>
<li>RTTI实现原理 typeid返回的是一个常量对象的引用，这个常量对象的类型一般是type_info（类）</li>
<li><img src="media/15662867942391/15664624057485.jpg" alt="" style="width:1035px;"/></li>
<li>vptr vtbl rtti的 type_info信息编译之后就存在</li>
</ul>

<h4>编译器优化</h4>

<ul>
<li>优化循环，把循环优化成1条语句；</li>
<li>在编译期间，编译器也具有运算能力，有些运算编译器在编译期间就能搞定；</li>
</ul>

<h4>多重继承</h4>

<ul>
<li>继承关系深度增加，开销一般也会增加</li>
<li>很多情况下，随着继承深度的增加，开销或者说执行时间也会增加；</li>
<li>多重继承一般也会导致开销增加</li>
</ul>

<h4>成员函数指针&amp;&amp;vall</h4>

<ul>
<li>通过成员函数指针对常规的成员函数调用的成本，和通过普通的函数指针来调用静态成员函数，成本上差不多；</li>
<li>成员函数指针里保存的是vcall = virtual call 虚调用(vcall trunk)地址</li>
<li>直接把vcall看成虚函数表vcall{0}代表的就是虚函数表里的第一个函数，vcall{4}就代表虚函数表里的第二个虚函数</li>
<li>vcall地址就是虚函数在虚函数表中的偏移值，结合对象指针，就能确定具体的虚函数地址</li>
<li>成员函数地址是真正的地址</li>
</ul>

<h4>inline函数</h4>

<ul>
<li>inline会导致编译器内部有一个比较复杂的测试算法来评估这个inline函数的复杂度</li>
<li>赋值次数和内部函数调用，调用次数</li>
<li>开发者写的inline只是对编译器的建议</li>
<li>inline会带来额外的问题，比如函数求值，临时对象的生成和管理</li>
<li>局部变量的引入，能少用就尽量少用，能不用就不用</li>
<li>10行以内，少用循环</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/20 15:39 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html'>C++对象模型</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15662646498238.html">
                
                  <h1>队列</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>栈</h4>

<ul>
<li>leet_20</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.
class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; parentheses;
        for (int i = 0; i &lt; s.size(); ++i) {
            if (s[i] == &#39;(&#39; || s[i] == &#39;[&#39; || s[i] == &#39;{&#39;) parentheses.push(s[i]);
            else {
                if (parentheses.empty()) return false;
                if (s[i] == &#39;)&#39; &amp;&amp; parentheses.top() != &#39;(&#39;) return false;
                if (s[i] == &#39;]&#39; &amp;&amp; parentheses.top() != &#39;[&#39;) return false;
                if (s[i] == &#39;}&#39; &amp;&amp; parentheses.top() != &#39;{&#39;) return false;
                parentheses.pop();
            }
        }
        return parentheses.empty();
    }
}; 
</code></pre>

<ul>
<li>leet_150</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
Output: 9
Explanation: ((2 + 1) * 3) = 9
class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        if (tokens.size() == 1) return stoi(tokens[0]);
        stack&lt;int&gt; st;
        for (int i = 0; i &lt; tokens.size(); ++i) {
            if (tokens[i] != &quot;+&quot; &amp;&amp; tokens[i] != &quot;-&quot; &amp;&amp; tokens[i] != &quot;*&quot; &amp;&amp; tokens[i] != &quot;/&quot;) {
                st.push(stoi(tokens[i]));
            } else {
                int num1 = st.top(); st.pop();
                int num2 = st.top(); st.pop();
                if (tokens[i] == &quot;+&quot;) st.push(num2 + num1);
                if (tokens[i] == &quot;-&quot;) st.push(num2 - num1);
                if (tokens[i] == &quot;*&quot;) st.push(num2 * num1);
                if (tokens[i] == &quot;/&quot;) st.push(num2 / num1);
            }
        }
        return st.top();
    }
};

class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        int op = (int)tokens.size() - 1;
        return helper(tokens, op);
    }
    int helper(vector&lt;string&gt;&amp; tokens, int&amp; op) {
        string str = tokens[op];
        if (str != &quot;+&quot; &amp;&amp; str != &quot;-&quot; &amp;&amp; str != &quot;*&quot; &amp;&amp; str != &quot;/&quot;) return stoi(str);
        int num1 = helper(tokens, --op);
        int num2 = helper(tokens, --op);
        if (str == &quot;+&quot;) return num2 + num1;
        if (str == &quot;-&quot;) return num2 - num1;
        if (str == &quot;*&quot;) return num2 * num1;
        return num2 / num1;
    }
};
</code></pre>

<ul>
<li>leet_71</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">For example,
path = &quot;/home/&quot;, =&gt; &quot;/home&quot;
path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot;
class Solution {
public:
    string simplifyPath(string path) {
        vector&lt;string&gt; v;
        int i = 0;
        while (i &lt; path.size()) {
            while (path[i] == &#39;/&#39; &amp;&amp; i &lt; path.size()) ++i;
            if (i == path.size()) break;
            int start = i;
            while (path[i] != &#39;/&#39; &amp;&amp; i &lt; path.size()) ++i;
            int end = i - 1;
            string s = path.substr(start, end - start + 1);
            if (s == &quot;..&quot;) {
                if (!v.empty()) v.pop_back(); 
            } else if (s != &quot;.&quot;) {
                v.push_back(s);
            }
        }
        if (v.empty()) return &quot;/&quot;;
        string res;
        for (int i = 0; i &lt; v.size(); ++i) {
            res += &#39;/&#39; + v[i];
        }
        return res;
    }
};
</code></pre>

<h4>栈和递归的紧密关系</h4>

<ul>
<li>leet_144 </li>
</ul>

<pre class="line-numbers"><code class="language-cpp">For example:
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3
 
return [1,2,3].
class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (!s.empty() || p) {
            if (p) {
                s.push(p);
                res.push_back(p-&gt;val);
                p = p-&gt;left;
            } else {
                TreeNode *t = s.top(); s.pop();
                p = t-&gt;right;
            }
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_94 middle</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a binary tree, return the  inorder  traversal of its nodes&#39; values.
Example:
Input: [1,null,2,3]
   1
    \
     2
    /
   3
Output: [1,3,2]

class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (!s.empty() || p) {
            if (p) {
                s.push(p);
                p = p-&gt;left;
            } else {
               TreeNode* t = s.top(); s.pop();
                res.push_back(t-&gt;val);
                p = t-&gt;right;
            }
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_145</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a binary tree, return the postorder traversal of its nodes&#39; values.

For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [3,2,1].

class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (!s.empty() || p) {
            if (p) {
                s.push(p);
                res.insert(res.begin(), p-&gt;val);
                p = p-&gt;right;
            } else {
                TreeNode *t = s.top(); s.pop();
                p = t-&gt;left;
            }
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_341 </li>
</ul>

<pre class="line-numbers"><code class="language-cpp">class NestedIterator {
public:
    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) {
        for (int i = nestedList.size() - 1; i &gt;= 0; --i) {
            s.push(nestedList[i]);
        }
    }

    int next() {
        NestedInteger t = s.top(); s.pop();
        return t.getInteger();
    }

    bool hasNext() {
        while (!s.empty()) {
            NestedInteger t = s.top(); 
            if (t.isInteger()) return true;
            s.pop();
            for (int i = t.getList().size() - 1; i &gt;= 0; --i) {
                s.push(t.getList()[i]);
            }
        }
        return false;
    }  

private:
    stack&lt;NestedInteger&gt; s;
};
</code></pre>

<h4>队列</h4>

<ul>
<li>广度优先遍历</li>
<li>树 层序遍历</li>
<li>图 无权图的最短路径</li>
<li>leet_102</li>
</ul>

<pre class="line-numbers"><code class="language-text">Given a binary tree, return the  level order  traversal of its nodes&#39; values. (ie, from left to right, level by level).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        if (!root) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; q{{root}};
        while (!q.empty()) {
            vector&lt;int&gt; oneLevel;
            for (int i = q.size(); i &gt; 0; --i) {
                TreeNode *t = q.front(); q.pop();
                oneLevel.push_back(t-&gt;val);
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            res.push_back(oneLevel);
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_107</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7 
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode* root) {
        if (!root) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; q{{root}};
        while (!q.empty()) {
            vector&lt;int&gt; oneLevel;
            for (int i = q.size(); i &gt; 0; --i) {
                TreeNode *t = q.front(); q.pop();
                oneLevel.push_back(t-&gt;val);
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            res.insert(res.begin(), oneLevel);
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_103</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
        if (!root) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; q{{root}};
        bool leftToRight = true;
        while (!q.empty()) {
            int size = q.size();
            vector&lt;int&gt; oneLevel(size);
            for (int i = 0; i &lt; size; ++i) {
                TreeNode *t = q.front(); q.pop();
                int idx = leftToRight ? i : (size - 1 - i);
                oneLevel[idx] = t-&gt;val;
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            leftToRight = !leftToRight;
            res.push_back(oneLevel);
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_199</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a binary tree, imagine yourself standing on the  right  side of it, return the values of the nodes you can see ordered from top to bottom.

For example:
Given the following binary tree,

   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---

class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode *root) {
        vector&lt;int&gt; res;
        if (!root) return res;
        queue&lt;TreeNode*&gt; q{{root}};
        while (!q.empty()) {
            res.push_back(q.back()-&gt;val);
            int size = q.size();
            for (int i = 0; i &lt; size; ++i) {
                TreeNode *node = q.front();
                q.pop();
                if (node-&gt;left) q.push(node-&gt;left);
                if (node-&gt;right) q.push(node-&gt;right);
            }
        }
        return res;
    }
};
</code></pre>

<h4>BFS</h4>

<ul>
<li>leet_279</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a positive integer  n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to  n.

Example 1:

Input: _n_ = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.

class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i &lt;= n; ++i) {
            for (int j = 1; i + j * j &lt;= n; ++j) {
                dp[i + j * j] = min(dp[i + j * j], dp[i] + 1);
            }
        }
        return dp.back();
    }
};

class Solution {
public:
    int numSquares(int n) {
        
      int ret;
      assert(n &gt; 0);
      vector&lt;bool&gt; visited(n+1, false);
      visited[n] = true;
      queue&lt;pair&lt;int, int&gt;&gt; q;

      q.push(make_pair(n, 0));

      while (!q.empty()) {
        int num = q.front().first;
        int step = q.front().second;
        q.pop();

        for (int i = 1; ; i++) {
          int a = num - i * i;

          if (a &lt; 0) break;

          if (a == 0) return ret = step + 1;

          if (!visited[a]) {
            visited[a] = true;
            q.push(make_pair(a, step + 1));
          }
        }
      }
      return ret;
    }
};

</code></pre>

<ul>
<li>leet_127</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Input:
beginWord = &quot;hit&quot;,
endWord = &quot;cog&quot;,
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]

Output: 5

Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,
return its length 5.
class Solution {
  public:
  int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {
    unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());
    if (!wordSet.count(endWord)) return 0;
    queue&lt;string&gt; q{{beginWord}};
    int res = 0;
    while (!q.empty()) {
      for (int k = q.size(); k &gt; 0; --k) {
        string word = q.front(); q.pop();
        if (word == endWord) return res + 1;
        for (int i = 0; i &lt; word.size(); ++i) {
          string newWord = word;
          for (char ch = &#39;a&#39;; ch &lt;= &#39;z&#39;; ++ch) {
            newWord[i] = ch;
            if (wordSet.count(newWord) &amp;&amp; newWord != word) {
              q.push(newWord);
              wordSet.erase(newWord);
            }   
          }
        }
      }
      ++res;
    }
    return 0;
  }
};
</code></pre>

<ul>
<li>leet_126</li>
</ul>

<h4>优先级队列</h4>

<ul>
<li>底层实现,堆</li>
<li>堆的底层实现, 白板编程</li>
<li>priority_queue</li>
<li>leet_347 O(nlog(n-k)) O(nlog(n-k))</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a non-empty array of integers, return the  k  most frequent elements.

Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
class Solution {
public:
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; m;
        priority_queue&lt;pair&lt;int, int&gt;&gt; q;
        vector&lt;int&gt; res;
        for (auto a : nums) ++m[a];
        for (auto it : m) q.push({it.second, it.first});
        for (int i = 0; i &lt; k; ++i) {
            res.push_back(q.top().second); q.pop();
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_23 </li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Merge  k  sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
class Solution {
  public:
  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode node(0), *p = &amp;node;

    while (l1 &amp;&amp; l2) {
      if (l1-&gt;val &lt; l2-&gt;val) {
        p-&gt;next = l1;
        l1 = l1-&gt;next;
      } else {
        p-&gt;next = l2;
        l2 = l2-&gt;next;
      }
      p = p-&gt;next;
    }

    p-&gt;next = l1 ? l1 : l2;
    return node.next;
  }
  
  ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {

    if (lists.empty()) return nullptr;
    
    while (lists.size() &gt; 1) {
      lists.push_back(mergeTwoLists(lists[0], lists[1]));
      lists.erase(lists.begin());
      lists.erase(lists.begin());
    }
    
    return lists[0];
  }
};
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/20 09:30 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15662625086752.html">
                
                  <h1>启发式搜索算法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>启发函数</h4>

<ul>
<li>欧几里得距离，来近似地估计这个顶点跟终点的路径长度</li>
<li>曼哈顿距离是两点之间横纵坐标的距离之和</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/20 08:55 上午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html'>数据结构和算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15662228481979.html">
                
                  <h1>WAF</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h4>威胁</h4>

<ul>
<li>DDOs攻击 发起大量无效请求</li>
<li>SQL注入</li>
<li>HTTP头注入</li>
<li>跨站脚本攻击</li>
</ul>

<h4>WAF</h4>

<ul>
<li>工作在七层 HTTP入侵检测和防御机制</li>
<li>IP 黑名单和白名单，拒绝黑名单上地址的访问，或者只允许白名单上的用户访问；</li>
<li>URI 黑名单和白名单，与 IP 黑白名单类似，允许或禁止对某些 URI 的访问；</li>
<li>防护 DDoS 攻击，对特定的 IP 地址限连限速；</li>
<li>过滤请求报文，防御“代码注入”攻击；</li>
<li>过滤响应报文，防御敏感信息外泄；</li>
<li>审计日志，记录所有检测到的入侵操作</li>
</ul>

<h4>本质</h4>

<ul>
<li>模式匹配和数据过滤</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/08/19 21:54 下午</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='http_study.html'>http_study</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_25.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_27.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>eredin-blog</h1>
                <div class="site-des">生命的意义是成为你自己！</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Prometheus.html"><strong>Prometheus</strong></a>
        
            <a href="RocketMQ.html"><strong>RocketMQ</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html"><strong>网络协议</strong></a>
        
            <a href="Golang.html"><strong>Golang</strong></a>
        
            <a href="Django.html"><strong>Django</strong></a>
        
            <a href="C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98.html"><strong>C++设计模式实战</strong></a>
        
            <a href="%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes.html"><strong>深入剖析Kubernetes</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html"><strong>数据结构和算法</strong></a>
        
            <a href="%E5%BE%AE%E6%9C%8D%E5%8A%A1.html"><strong>微服务</strong></a>
        
            <a href="%E6%9E%B6%E6%9E%84.html"><strong>架构</strong></a>
        
            <a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html"><strong>操作系统原理</strong></a>
        
            <a href="Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Mysql优化实战</strong></a>
        
            <a href="Kafka.html"><strong>Kafka</strong></a>
        
            <a href="linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html"><strong>linux服务器研发</strong></a>
        
            <a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html"><strong>计算机组成原理</strong></a>
        
            <a href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html"><strong>程序员的自我修养</strong></a>
        
            <a href="C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6.html"><strong>C语言进阶</strong></a>
        
            <a href="http_study.html"><strong>http_study</strong></a>
        
            <a href="%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html"><strong>玩转算法</strong></a>
        
            <a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html"><strong>C++对象模型</strong></a>
        
            <a href="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html"><strong>SQL必知必会</strong></a>
        
            <a href="Zookeeper.html"><strong>Zookeeper</strong></a>
        
            <a href="Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html"><strong>Redis从入门到精通</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6.html"><strong>数据结构和算法进阶</strong></a>
        
            <a href="Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html"><strong>Mysql性能管理和架构设计</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html"><strong>网络编程实战</strong></a>
        
            <a href="Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html"><strong>Redis高并发缓存</strong></a>
        
            <a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html"><strong>C++基础与提高</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html"><strong>设计模式之美</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
        
            <a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Linux性能优化实战</strong></a>
        
            <a href="%E5%80%99%E6%8D%B7STL.html"><strong>候捷STL</strong></a>
        
            <a href="%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE.html"><strong>性能工程高手课</strong></a>
        
            <a href="%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html"><strong>性能测试</strong></a>
        
            <a href="ElasticSearch.html"><strong>ElasticSearch</strong></a>
        
            <a href="RabbitMQ.html"><strong>RabbitMQ</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15817697569868.html">字符串分割</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15817610843879.html">编译期</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814649492497.html">Simple Factory</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814189410719.html">代码的可测试性</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814188057978.html">重构</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
