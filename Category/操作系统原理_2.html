<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	操作系统原理 -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-25T08:07:42+08:00" itemprop="datePublished">2019/05/25 08:07 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15587428626726.html" itemprop="url">
		用户态内存映射</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存映射</h4>
<ul>
<li>物理内存和虚拟内存之间的映射</li>
<li>文件中的内容映射到虚拟内存空间</li>
<li><img src="media/15587428626726/f0dcb83fcaa4f185a8e36c9d28f12345.jpg" alt="f0dcb83fcaa4f185a8e36c9d28f12345" /></li>
</ul>
<h4><a id="%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存映射文件流程</h4>
<ul>
<li>通过文件描述符fd获取struct file</li>
<li>调用 get_unmapped_area 找到一个没有映射的区域；</li>
<li>调用 mmap_region 映射这个区域</li>
</ul>
<h5><a id="%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>匿名映射</h5>
<ul>
<li>调用 mm_struct 里面的get_unmapped_area 函数</li>
<li>查找vm_area_struct红黑树的位置</li>
</ul>
<h5><a id="%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件映射</h5>
<ul>
<li>struct file-&gt;file_operations-&gt;thp_get_unmapped_area</li>
<li>get_unmapped_area</li>
</ul>
<h4><a id="%E6%98%A0%E5%B0%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>映射内存区域</h4>
<ul>
<li>找到前一个虚拟内存区域的vm_area_struct</li>
<li>如果不能合并，创建新的vm_area_struct加入队列</li>
<li>通过__vma_link_file建立文件到内存的映射关系</li>
<li>struct_file的vm_area_struct挂在i_mmap的红黑树上</li>
</ul>
<h4><a id="%E7%94%A8%E6%88%B7%E6%80%81%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户态缺页异常</h4>
<ul>
<li>访问虚拟内存没有对应的物理页面</li>
<li>调用handle_mm_fault映射区域</li>
<li>通过五级进程页表PGD-&gt;PUD-&gt;PMD-&gt;PTE-&gt;Offset</li>
<li>页表项 task_struct-&gt;mm_struct-&gt;pgd</li>
<li>进程的虚拟地址空间分为用户态和内核态两部分</li>
<li>页表也分为用户地址空间的页表和内核页表</li>
<li>用户地址空间需要等到进程在CPU上运行，对内存访问的时候</li>
</ul>
<h4><a id="%E8%AE%BF%E9%97%AE%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>访问物理内存</h4>
<ul>
<li>context_switch-&gt;switch_mm_irqs_off-&gt;load_new_mm_cr3</li>
<li><img src="media/15587428626726/15587453477914.jpg" alt="" style="width:649px;" /></li>
</ul>
<h4><a id="%E6%98%A0%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>映射</h4>
<ul>
<li>匿名页面 分配页表项-&gt;分配页</li>
<li>文件映射  filemap_fault  kmap_atomic，将物理内存映射到内核的虚拟地址空间，得到内核中的地址 kaddr</li>
<li>swap page  kmap_atomic 映射</li>
</ul>
<h4><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h4>
<ul>
<li><img src="media/15587428626726/f0dcb83fcaa4f185a8e36c9d28f12345.jpg" alt="f0dcb83fcaa4f185a8e36c9d28f12345" /></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-23T07:06:45+08:00" itemprop="datePublished">2019/05/23 07:06 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15585664053810.html" itemprop="url">
		Slub分配器</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="kmem-cache-alloc-node" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kmem_cache_alloc_node</h4>
<ul>
<li>创建 task_struct 的时候，我们不用到内存里面去分配，先在缓存里面看看有没有直接可用的，这就是kmem_cache_alloc_node的作用</li>
<li>进程结束，task_struct 也不用直接被销毁，而是放回到缓存中，这就是kmem_cache_free的作用</li>
</ul>
<h4><a id="kmem-cache" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kmem_cache</h4>
<pre><code class="language-plain_text">struct kmem_cache {
   struct kmem_cache_cpu __percpu *cpu_slab;
   struct kmem_cache_node *node[MAX_NUMNODES];
}
</code></pre>
<h4><a id="kmem-cache-cpu" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kmem_cache_cpu</h4>
<ul>
<li>分配缓存的快速通道</li>
<li></li>
</ul>
<h4><a id="kmem-cache-node" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kmem_cache_node</h4>
<ul>
<li>分配缓存的普通通道</li>
</ul>
<h4><a id="%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存分配</h4>
<ul>
<li><a href="https://www.cnblogs.com/luoahong/p/10907734.html">https://www.cnblogs.com/luoahong/p/10907734.html</a></li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-21T08:46:18+08:00" itemprop="datePublished">2019/05/21 08:46 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15583995782246.html" itemprop="url">
		进程空间管理</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户态和内核态</h4>
<ul>
<li><img src="media/15583995782246/89723dc967b59f6f49419082f6ab7659.jpg" alt="89723dc967b59f6f49419082f6ab7659" /></li>
</ul>
<h4><a id="%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4%E9%83%A8%E7%BD%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程空间部署</h4>
<ul>
<li><img src="media/15583995782246/f83b8d49b4e74c0e255b5735044c1eb1.jpg" alt="f83b8d49b4e74c0e255b5735044c1eb1" /></li>
</ul>
<h5><a id="%E5%90%84%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>各区域的位置信息</h5>
<ul>
<li>total_vm 是总共映射的页的数目。</li>
<li>locked_vm 就是被锁定不能换出，pinned_vm 是不能换出，也不能移动。</li>
<li>data_vm 是存放数据的页的数目，exec_vm 是存放可执行文件的页的数目，stack_vm 是栈所占的页的数目。</li>
<li>start_code 和 end_code 表示可执行代码的开始和结束位置，start_data 和 end_data 表示已初始化数据的开始位置和结束位置。</li>
<li>start_brk 是堆的起始位置，brk 是堆当前的结束位置。前面咱们讲过 malloc 申请一小块内存的话，就是通过改变 brk 位置实现的。</li>
<li>start_stack 是栈的起始位置，栈的结束位置在寄存器的栈顶指针中。</li>
<li>arg_start 和 arg_end 是参数列表的位置， env_start 和 env_end 是环境变量的位置。它们都位于栈中最高地址的地方。</li>
</ul>
<pre><code class="language-plain_text">unsigned long mmap_base;	/* base of mmap area */
unsigned long total_vm;		/* Total pages mapped */
unsigned long locked_vm;	/* Pages that have PG_mlocked set */
unsigned long pinned_vm;	/* Refcount permanently increased */
unsigned long data_vm;		/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */
unsigned long exec_vm;		/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */
unsigned long stack_vm;		/* VM_STACK */
unsigned long start_code, end_code, start_data, end_data;
unsigned long start_brk, brk, start_stack;
unsigned long arg_start, arg_end, env_start, env_end;
</code></pre>
<h5><a id="%E5%90%84%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>各区域的属性信息</h5>
<ul>
<li>每一块区域使用vm_area_struct来描述信息</li>
<li>vm_area_struct来描述位置信息</li>
<li>解析ELF</li>
<li>建立内存映射</li>
</ul>
<h6><a id="load-elf-binary" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>load_elf_binary</h6>
<ul>
<li>调用 setup_new_exec，设置内存映射区 mmap_base；</li>
<li>调用 setup_arg_pages，设置栈的 vm_area_struct，这里面设置了 mm-&gt;arg_start 是指向栈底的，current-&gt;mm-&gt;start_stack 就是栈底；</li>
<li>elf_map 会将 ELF 文件中的代码部分映射到内存中来；</li>
<li>set_brk 设置了堆的 vm_area_struct，这里面设置了 current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，也即堆里面还是空的；</li>
<li>load_elf_interp 将依赖的 so 映射到内存中的内存映射区域。</li>
<li>内存映射图<br />
<img src="media/15583995782246/7af58012466c7d006511a7e16143314c.jpeg" alt="7af58012466c7d006511a7e16143314" /></li>
</ul>
<h5><a id="%E4%BF%AE%E6%94%B9%E6%98%A0%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改映射</h5>
<ul>
<li>函数的调用</li>
<li>malloc申请堆内的空间 brk 或者 mmap</li>
</ul>
<h4><a id="%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>堆内存分配</h4>
<ul>
<li>sys_brk的新堆顶地址和旧的堆顶地址进行合并</li>
<li>考虑需要不需要分配页的问题</li>
<li>如果是释放，直接释放</li>
<li>如果是分配堆内存 当前的堆顶和下一个 vm_area_struct 之间还能不能分配一个完整的页</li>
<li>do_brk 进一步分配堆空间，从旧堆顶开始，分配计算出的新旧堆顶之间的页数。</li>
</ul>
<h4><a id="%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E9%A1%B5%E7%9A%84%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>伙伴系统页的分配</h4>
<ul>
<li>把所有的空闲页分组为 11 个页块链表，每个块链表分别包含很多个大小的页块，有 1、2、4、8、16、32、64、128、256、512 和 1024 个连续页的页块</li>
<li>在一个循环中先看当前节点的 zone。如果找不到空闲页，则再看备用节点的 zone</li>
<li>先去free_area找与当前2^order匹配的队列</li>
<li>找不到去更大的2^order队列中找，然后把多余的页面放入其他页面链表</li>
</ul>
<h4><a id="%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>物理内存的总结</h4>
<ul>
<li><img src="media/15583995782246/3fa8123990e5ae2c86859f70a8351f4f.jpeg" alt="3fa8123990e5ae2c86859f70a8351f4f" /></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-20T07:29:21+08:00" itemprop="datePublished">2019/05/20 07:29 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15583085610757.html" itemprop="url">
		物理内存分配</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%BB%8F%E5%85%B8%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>经典内存使用方式</h4>
<ul>
<li><img src="media/15583085610757/fa6c2b6166d02ac37637d7da4e4b579b.jpeg" alt="fa6c2b6166d02ac37637d7da4e4b579b" /></li>
</ul>
<h4><a id="smp%E5%92%8Cnuma%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SMP和NUMA模式</h4>
<ul>
<li><img src="media/15583085610757/8f158f58dda94ec04b26200073e15449.jpeg" alt="8f158f58dda94ec04b26200073e15449" /></li>
</ul>
<h4><a id="numa%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NUMA模型</h4>
<ul>
<li>内存被分成了多个节点，每个节点再被分成一个一个的页面。由于页需要全局唯一定位，页还是需要有全局唯一的页号的。但是由于物理内存不是连起来的了，页号也就不再连续了。于是内存模型就变成了非连续内存模型</li>
<li>CPU访问内存不用过总线</li>
</ul>
<h4><a id="%E8%8A%82%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>节点</h4>
<ul>
<li>pglist_data</li>
<li>每一个节点都有自己的 ID：node_id；</li>
<li>node_mem_map 就是这个节点的 struct page 数组，用于描述这个节点里面的所有的页；</li>
<li>node_start_pfn 是这个节点的起始页号；</li>
<li>node_spanned_pages 是这个节点中包含不连续的物理内存地址的页面数；</li>
<li>node_present_pages 是真正可用的物理页面的数目。</li>
</ul>
<h4><a id="dma%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DMA机制</h4>
<ul>
<li>DMA 是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过 CPU 控制完成，但是这会占用 CPU，影响 CPU 处理其他事情，所以有了 DMA 模式。CPU 只需向 DMA 控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，这样就可以解放 CPU。</li>
</ul>
<h4><a id="%E5%8C%BA%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>区域</h4>
<ul>
<li>spanned_pages = zone_end_pfn - zone_start_pfn，也即 spanned_pages 指的是不管中间有没有物理内存空洞，反正就是最后的页号减去起始的页号。</li>
<li>present_pages = spanned_pages - absent_pages(pages in holes)，也即 present_pages 是这个 zone 在物理内存中真实存在的所有 page 数目。</li>
<li>managed_pages = present_pages - reserved_pages，也即 managed_pages 是这个 zone 被伙伴系统管理的所有的 page 数目，</li>
<li>per_cpu_pageset</li>
</ul>
<h4><a id="%E9%A1%B5%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>页面</h4>
<ul>
<li>匿名页  一整页的内存，或者直接和虚拟地址空间建立映射关系，我们把这种称为匿名页（Anonymous Page）</li>
<li>文件页 关联一个文件，然后再和虚拟地址空间建立映射关系，这样的文件，我们称为内存映射文件（Memory-mapped File）。</li>
</ul>
<h4><a id="%E5%8C%BF%E5%90%8D%E9%A1%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>匿名页</h4>
<ul>
<li>struct address_space *mapping 就是用于内存映射，如果是匿名页，最低位为 1；如果是映射文件，最低位为 0；</li>
<li>pgoff_t index 是在映射区的偏移量；</li>
<li>atomic_t _mapcount，每个进程都有自己的页表，这里指有多少个页表项指向了这个页；</li>
<li>struct list_head lru 表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中；</li>
<li>compound 相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页</li>
</ul>
<h4><a id="%E6%96%87%E4%BB%B6%E9%A1%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件页</h4>
<ul>
<li>分配小块内存，存储进程描述结构的对象</li>
<li>slub allocator</li>
</ul>
<h4><a id="%E9%A1%B5%E7%9A%84%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>页的分配</h4>
<ul>
<li>分配大内存使用伙伴系统</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-15T07:35:47+08:00" itemprop="datePublished">2019/05/15 07:35 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15578769474390.html" itemprop="url">
		内存管理</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%AE%A1%E7%90%86%E8%A7%92%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>管理角度</h4>
<ul>
<li>
<p>第一，物理内存的管理，相当于会议室管理员管理会议室。</p>
</li>
<li>
<p>第二，虚拟地址的管理，也即在项目组的视角，会议室的虚拟地址应该如何组织。</p>
</li>
<li>
<p>第三，虚拟地址和物理地址如何映射，也即会议室管理员如果管理映射表</p>
</li>
</ul>
<h4><a id="%E5%86%85%E5%AD%98%E6%A0%88%E7%A9%BA%E9%97%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存栈空间</h4>
<ul>
<li>Text Segment</li>
<li>Data Segment</li>
<li>BSS Segment</li>
</ul>
<h4><a id="%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存分段机制</h4>
<p><img src="media/15578769474390/9697ae17b9f561e78514890f9d58d4eb.jpg" alt="9697ae17b9f561e78514890f9d58d4eb" /></p>
<h4><a id="%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存分页机制</h4>
<ul>
<li>32位系统</li>
<li><img src="media/15578769474390/b6960eb0a7eea008d33f8e0c4facc8b8.jpg" alt="b6960eb0a7eea008d33f8e0c4facc8b8" /></li>
<li>64位系统<br />
<img src="media/15578769474390/42eff3e7574ac8ce2501210e25cd2c0b.jpg" alt="42eff3e7574ac8ce2501210e25cd2c0b" /></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-11T10:03:05+08:00" itemprop="datePublished">2019/05/11 10:03 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15575401859226.html" itemprop="url">
		系统调用</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%88%91%E4%BB%AC%E7%BC%96%E5%86%99%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B9%B6%E4%B8%8D%E5%90%8C%E5%B1%9E%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%B8%A4%E8%BE%B9%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%83%BD%E6%98%AF%E7%8B%AC%E7%AB%8B%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>操作系统与我们编写的软件并不同属一个进程，两边的内存地址空间都是独立的，如何实现系统调用</h4>
<ul>
<li>从虚拟内存机制的视角，操作系统内核和所有进程都在同一个地址空间，也就是，操作系统内核，它是所有进程共享的内存<br />
<img src="media/15575401859226/2b0adde3eca6262ae674a97f478c15b3.png" alt="2b0adde3eca6262ae674a97f478c15b3" /></li>
<li>中断向量表的地址，以及操作系统内核的地址空间是一个契约。有了中断向量表的地址约定，用户态函数就可以发起一次系统调用（软中断）</li>
</ul>
<h4><a id="%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编程接口</h4>
<p><img src="media/15575401859226/b2393a109f849bd91c991b1e750cb3e0.png" alt="b2393a109f849bd91c991b1e750cb3e0" /><br />
*</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-10T19:54:53+08:00" itemprop="datePublished">2019/05/10 19:54 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15574892932253.html" itemprop="url">
		线程的创建</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原理</h4>
<ul>
<li>由内核态和用户态合作完成的</li>
<li>用户态维护线程的结构 pthread</li>
</ul>
<h4><a id="%E7%BA%BF%E7%A8%8B%E6%A0%88%E7%9A%84%E5%88%9B%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程栈的创建</h4>
<ul>
<li>设置栈的大小，需要你把设置的值拿出来；</li>
<li>为了防止栈的访问越界，在栈的末尾设置guardsize，一旦访问到这里就错误了；</li>
<li>get_cached_stack 从缓存中获取已经存在的线程</li>
<li>__mmap创建新的线程内存区域</li>
<li>计算出 guard 内存的位置</li>
<li>设置pthread 这个结构里面的成员变量 stackblock、stackblock_size、guardsize、specific。这里的 specific 是用于存放 Thread Specific Data 的，也即属于线程的全局变量；</li>
<li>将这个线程栈放到 stack_used 链表中，其实管理线程栈总共有两个链表，一个是 stack_used，也就是这个栈正被使用；另一个是 stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。</li>
</ul>
<h4><a id="%E5%86%85%E6%A0%B8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内核态创建任务</h4>
<ul>
<li>start_routine</li>
<li>__nptl_nthreads 线程数加1</li>
<li>create_thread 创建线程</li>
<li>--clone--&gt;do_fork</li>
</ul>
<h5><a id="%E6%A0%87%E5%BF%97%E4%BD%8D%E8%AE%BE%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标志位设定</h5>
<ul>
<li>CLONE_FS copy_fs</li>
<li>CLONE_SIGHAND copy_sighand</li>
<li>CLONE_VM copy_mm</li>
</ul>
<h5><a id="%E4%BA%B2%E7%BC%98%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>亲缘关系</h5>
<ul>
<li>CLONE_THREAD</li>
</ul>
<h5><a id="%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>信号处理</h5>
<ul>
<li>kill 进程</li>
<li>pthread_kill 线程</li>
<li>初始化 struct sigpending pending</li>
<li>返回用户态</li>
</ul>
<h4><a id="%E7%94%A8%E6%88%B7%E6%80%81%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户态执行线程</h4>
<ul>
<li>start_thread 统一入口</li>
<li>调用完毕线程数目减1</li>
</ul>
<h4><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h4>
<p><img src="media/15574892932253/14635b1613d04df9f217c3508ae8524b.jpeg" alt="14635b1613d04df9f217c3508ae8524b" /></p>
<ul>
<li>查看进程和线程栈的使用情况</li>
<li>pstack</li>
<li>pstree</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-07T08:01:27+08:00" itemprop="datePublished">2019/05/07 08:01 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15571872879168.html" itemprop="url">
		抢占式调度</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>####时间片</p>
<ul>
<li>计算机隔一段时间触发时钟中断</li>
<li>计算进程分配的实际运行时间</li>
<li>进程总共执行的实际时间 - 上次被调度时总的的运行时间 = 本次实际运行时间</li>
<li>被调度条件</li>
<li>本次实际运行时间 &gt; 计算进程分配的实际运行时间</li>
<li>当前进程的 vruntime 大于红黑树中最小的进程的 vruntime</li>
<li>差值大于 ideal_runtime</li>
</ul>
<h4><a id="%E8%B0%83%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度</h4>
<ul>
<li>打上TIF_NEED_RESCHED标签</li>
</ul>
<h4><a id="%E8%BF%9B%E7%A8%8B%E8%A2%AB%E5%94%A4%E9%86%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程被唤醒</h4>
<ul>
<li>当被唤醒的进程优先级高于 CPU 上的当前进程，就会触发抢占</li>
<li>这个唤醒的任务添加到队列当中</li>
<li>激活任务</li>
<li>标记被抢占</li>
</ul>
<h4><a id="%E7%94%A8%E6%88%B7%E6%80%81%E6%8A%A2%E5%8D%A0%E6%97%B6%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户态抢占时机</h4>
<ul>
<li>用户态抢占时机 系统调用中返回的那个时刻，是一个被抢占的时机</li>
<li>中断中返回的那个时刻</li>
</ul>
<h4><a id="%E5%86%85%E6%A0%B8%E6%80%81%E6%8A%A2%E5%8D%A0%E6%97%B6%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内核态抢占时机</h4>
<ul>
<li>preempt_disable()--&gt;preempt_enable()</li>
<li>内核态中断返回</li>
</ul>
<h4><a id="%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程调度总结</h4>
<p><img src="media/15571872879168/93588d71abd7f007397979f0ba7def7f.png" alt="93588d71abd7f007397979f0ba7def7f" /></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-01T10:20:20+08:00" itemprop="datePublished">2019/05/01 10:20 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15566772208348.html" itemprop="url">
		进程调度</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%92%8C%E8%B0%83%E5%BA%A6%E7%A7%8D%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度策略和调度种类</h4>
<ul>
<li>实时进程</li>
<li>普通进程</li>
</ul>
<h4><a id="%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度策略和优先级</h4>
<ul>
<li>实时进程，优先级的范围是 0～99</li>
<li>普通进程，优先级的范围是 100～139</li>
</ul>
<h4><a id="%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实时调度策略</h4>
<ul>
<li>SCHED_FIFO 高优先级的进程可以抢占低优先级的进程，相同优先级的进程，我们遵循先来先得</li>
<li>SCHED_RR 采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务</li>
<li>SCHED_DEADLINE 当产生一个调度点的时候，DL 调度器总是选择其 deadline 距离当前时间点最近的那个任务，并调度它执行</li>
</ul>
<h4><a id="%E6%99%AE%E9%80%9A%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>普通调度策略</h4>
<ul>
<li>SCHED_NORMAL 普通进程</li>
<li>SCHED_BATCH 后台进程</li>
<li>SCHED_IDLE 空闲进程</li>
</ul>
<h4><a id="%E8%B0%83%E5%BA%A6%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度变量</h4>
<ul>
<li>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li>
<li>dl_sched_class 就对应上面的 deadline 调度策略；</li>
<li>rt_sched_class 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；</li>
<li>fair_sched_class 就是普通进程的调度策略；</li>
<li>idle_sched_class 就是空闲进程的调度策略。</li>
</ul>
<h4><a id="%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>完全公平调度算法</h4>
<ul>
<li>CFS 会为每一个进程安排一个虚拟运行时间 vruntime。如果一个进程在运行，随着时间的增长，也就是一个个 tick 的到来，进程的 vruntime 将不断增大。没有得到执行的进程 vruntime 不变</li>
<li>虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD/ 权重</li>
</ul>
<h4><a id="%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E5%92%8C%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BD%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度队列和调度实体</h4>
<ul>
<li>实时调度实体 sched_rt_entity</li>
<li>Deadline 调度实体 sched_dl_entity  deadline</li>
<li>完全公平算法调度实体 sched_entity real time</li>
</ul>
<h4><a id="cpu%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CPU进程调度</h4>
<p><img src="media/15566772208348/10381dbafe0f78d80beb87560a9506af.jpeg" alt="10381dbafe0f78d80beb87560a9506af" /><br />
*</p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="操作系统原理_1.html">Prev</a>  
	 <a class="next" href="操作系统原理_3.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>