<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	C++基础与提高 -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-25T19:45:10+08:00" itemprop="datePublished">2019/09/25 19:45 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15694119108197.html" itemprop="url">
		多线程补充知识</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li>补充</li>
</ul>
<h4><a id="%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚假唤醒</h4>
<ul>
<li>wait中需要有第二个参数</li>
<li>这个lambda要正确判断要处理的公共数据是否存在</li>
</ul>
<pre><code class="language-plain_text">cond.wait(s1, [this]{
                  if (!msgRecvQueue.empty())
                     return true;
                  return false;
                });
</code></pre>
<h4><a id="atomic" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>atomic</h4>
<ul>
<li>线程数目控制在200个，尽量不要超过500</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-28T18:32:17+08:00" itemprop="datePublished">2019/09/28 18:32 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15696667375372.html" itemprop="url">
		引用折叠&转发&完美转发&forward</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引用折叠</h4>
<pre><code class="language-C++">template&lt;typename T&gt;
void func(T &amp;&amp;tmp)

int main(){
  int i = 18;
  func(i); //i左值 T int&amp; tmp int&amp;
  func(100);//i 右值  T int tmp int&amp;&amp;
  void func(int&amp; &amp;&amp;tmp) {} 
  void func(int&amp; tmp) {} //编译器展现出来的
}
</code></pre>
<ul>
<li>引用折叠</li>
<li>左值引用&amp;, 右值引用&amp;&amp;</li>
<li>T是第一组左值引用， &amp;&amp;tmp第二组右值引用</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center">第一组</th>
<th style="text-align: center">第二组</th>
<th style="text-align: center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">&amp;左值引用</td>
<td style="text-align: center">&amp;左值引用</td>
<td style="text-align: center">&amp;左值引用</td>
</tr>
<tr>
<td style="text-align: center">&amp;左值引用</td>
<td style="text-align: center">&amp;&amp;右值引用</td>
<td style="text-align: center">&amp;左值引用</td>
</tr>
<tr>
<td style="text-align: center">&amp;&amp;右值引用</td>
<td style="text-align: center">&amp;左值引用</td>
<td style="text-align: center">&amp;左值引用</td>
</tr>
<tr>
<td style="text-align: center">&amp;&amp;右值引用</td>
<td style="text-align: center">&amp;&amp;右值引用</td>
<td style="text-align: center">&amp;&amp;右值引用</td>
</tr>
</tbody>
</table>
<ul>
<li>折叠规则，只要有任意一个引用为左值引用，结果就是左值引用，否则就是右值引用</li>
</ul>
<h4><a id="%E5%BC%95%E7%94%A8%E7%9A%84%E5%BC%95%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引用的引用</h4>
<pre><code class="language-C++">int b = 500;
int &amp;rb = b;
int &amp; &amp;rrb = b; //引用的引用，两个&amp;之间有空格
</code></pre>
<ul>
<li>引用的引用是非法的</li>
<li>编译器内部推断</li>
</ul>
<h4><a id="%E8%BD%AC%E5%8F%91%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>转发和完美转发</h4>
<ul>
<li>函数模版把收到的参数以及这些参数的类型转发给其他函数</li>
</ul>
<pre><code class="language-C++">void func2(int t1, int&amp; t2) {
  cout &lt;&lt; &quot; t1 + t2 &quot; &lt;&lt; t1 + t2 &lt;&lt; endl;
  t2++;
}
template&lt;typename F, typename T1, typename T2&gt;
void func(F f, T1 t1, T2&amp;&amp; t2) {
  f(t1, t2)
}
</code></pre>
<ul>
<li>要保持t2的引用属性，T2改成万能引用T2&amp;&amp;，可以推导所有的实参类型</li>
<li>T2改成T2&amp;不能保留左值或者右值属性</li>
</ul>
<pre><code class="language-C++"> int&amp;&amp; rval = 80;//右值引用必须要绑定右值, &amp;&amp;rval是右值引用,但是rval本身是个左值
  func3(rval, j);//err
  func3(80, j);//right
</code></pre>
<h4><a id="%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>完美转发</h4>
<pre><code class="language-C++">void func3(int&amp;&amp; t1, int&amp; t2) {
  cout &lt;&lt; &quot; t1 + t2 &quot; &lt;&lt; t1 + t2 &lt;&lt; endl;
  t2++;
}

template&lt;typename F, typename T1, typename T2&gt;
void func(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) { //t1是左值, 形参都是左值
   f(forward&lt;T1&gt;(t1), forward&lt;T2&gt;(t2));
}

int main() {
  int i = 20, j = 30;
  func(func2, i, j);
  func3(70, j);
  cout &lt;&lt; &quot; j &quot; &lt;&lt; j &lt;&lt; endl;

  int&amp;&amp; rval = 80;//右值引用必须要绑定右值, &amp;&amp;rval是右值引用,但是rval本身是个左值
  //func3(rval, j);
  func(func3, 80, j);
}
</code></pre>
<ul>
<li>接受任意实参的函数模板</li>
<li>目标函数会接收到与转发函数所收到的完全相同</li>
<li>std::forward</li>
<li>发挥作用的条件</li>
<li>调用模板函数，模板函数参数是万能引用类型，模版函数负责转发</li>
<li>std::forward的能力就是按照参数本来的类型转发</li>
<li>实参如果原来是左值，forward还是按照原来的类型处理</li>
<li>实参如果原来是右值，形参变成了左值，forward会把左值信息还原为右值</li>
<li>万能引用会保存实参的左值右值的信息，</li>
</ul>
<pre><code class="language-C++">void func4(int &amp;t) {
  cout&lt;&lt; &quot;left  value &quot; &lt;&lt; endl;
}

void func4(int &amp;&amp;t) {
  cout&lt;&lt; &quot;right  value &quot; &lt;&lt; endl;
}

template &lt;typename T&gt;
void testF(T&amp;&amp; t) {
  func4(t);
  func4(forward&lt;T&gt;(t));
  func4(move(t));//move是左值转右值。
}
</code></pre>
<ul>
<li>forward是有条件的转发，左值转右值</li>
<li>move无条件强制类型转换成右值</li>
</ul>
<h4><a id="%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>万能引用</h4>
<ul>
<li>可以合并代码，达到简化代码的效果</li>
</ul>
<pre><code class="language-C++">class shape {};
class circle : public shape {};
void foo(const shape&amp;)
{
    puts(&quot;foo(const shape&amp;)&quot;);
}

void foo(shape&amp;&amp;)
{
    puts(&quot;foo(shape&amp;&amp;)&quot;);
}

//void bar(const shape&amp; s)
//{
//    puts(&quot;bar(const shape&amp;)&quot;);
//    foo(s);
//}
//
//void bar(shape&amp;&amp; s)
//{
//    puts(&quot;bar(shape&amp;&amp;)&quot;);
//    foo(move(s));
//}


template &lt;typename T&gt;
void bar(T&amp;&amp; s)
{
    foo(std::forward&lt;T&gt;(s));
}

int main()
{
    circle temp;
    bar(temp);
    bar(circle());
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2020-02-15T18:04:44+08:00" itemprop="datePublished">2020/02/15 18:04 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15817610843879.html" itemprop="url">
		编译期</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="fmap%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>fmap实现</h4>
<ul>
<li>用 decltype 来获得用 f 来调用 inputs 元素的类型（参考第 8 讲）；</li>
<li>用 decay_t 来把获得的类型变成一个普通的值类型；</li>
<li>缺省使用 vector 作为返回值的容器，但可以通过模板参数改为其他容器；</li>
<li>使用基于范围的 for 循环来遍历 inputs，对其类型不作其他要求（参考第 7 讲）；</li>
<li>存放结果的容器需要支持 push_back 成员函数（参考第 4 讲）。</li>
</ul>
<pre><code class="language-C++">template &lt;template &lt;typename, typename&gt;
class OutContainer = vector, typename F, class R&gt;
auto fmap(F&amp;&amp; f, R&amp;&amp; inputs) {
    typedef decay_t&lt;decltype(f(*inputs.begin()))&gt; result_type;
    OutContainer&lt;result_type, allocator&lt;result_type&gt;&gt; result;

    for (auto&amp;&amp; item : inputs) {
        result.push_back(f(item));
    }
    return result;
}

int add_1(int x)
{
    return x + 1;
}

int main()
{
    vector&lt;int&gt; v{1, 2, 3, 4, 5};
    auto result = fmap(add_1, v);
    for (auto it : result) {
        cout &lt;&lt; it &lt;&lt; '\n';
    }
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-07T18:21:04+08:00" itemprop="datePublished">2019/08/07 18:21 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15651732645009.html" itemprop="url">
		C++11</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A0%87%E5%87%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标准</h4>
<ul>
<li>C++标准库</li>
<li>新功能，新写法，取代C语言的功能和写法，积极学习新写法</li>
<li>语法和标准程序库的学习</li>
</ul>
<h4><a id="%E5%BC%95%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引用</h4>
<ul>
<li>引用和原变量占用同一块内存</li>
<li>引用必须绑定到变量</li>
</ul>
<h4><a id="%E5%B8%B8%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常量</h4>
<ul>
<li>const可以修改</li>
<li>constexpr编译的时候求值提升性能</li>
<li>const 变量的初始化可以延迟到运行时，而 constexpr 变量必须在编译时进行初始化</li>
</ul>
<h4><a id="%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存分配问题</h4>
<ul>
<li>new</li>
<li>delete</li>
</ul>
<h4><a id="nullptr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>nullptr</h4>
<ul>
<li>C++11新关键字</li>
<li>nullptr避免指针和整数的混淆</li>
<li>NULL是0</li>
</ul>
<h4><a id="%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最大最小</h4>
<ul>
<li>std::min_element</li>
<li>std::max_element</li>
</ul>
<h4><a id="c-11%E6%96%B0%E7%89%B9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>C++11新特性</h4>
<ul>
<li><a href="http://www.stroustrup.com/C++11FAQ.html#">http://www.stroustrup.com/C++11FAQ.html#</a></li>
</ul>
<h4><a id="%E9%9A%90%E5%BC%8F%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐式拷贝函数</h4>
<ul>
<li>拷贝函数 + 析构函数 自动生成拷贝赋值运算符</li>
<li>赋值运算符 + 析构函数</li>
</ul>
<h4><a id="auto-ptr%E8%A2%ABunique-ptr%E4%BB%A3%E6%9B%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>auto_ptr被unique_ptr代替</h4>
<ul>
<li>auto_ptr发生所有权转移</li>
<li>unique_ptr不会</li>
</ul>
<h4><a id="bind%E6%9B%BF%E6%8D%A2bind1st-bind2nd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>bind替换bind1st,bind2nd</h4>
<h4><a id="%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数适配器</h4>
<ul>
<li>bind</li>
<li>not1</li>
<li>not2</li>
<li>ref</li>
<li>cref</li>
<li>mem_fun()</li>
</ul>
<h4><a id="%E5%8A%A8%E6%80%81%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态异常声明</h4>
<ul>
<li>throw 被 noexcept</li>
</ul>
<h4><a id="nullptr-nullptr-t" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>nullptr&amp;nullptr_t</h4>
<ul>
<li>能够隐式的转换任何类型的指针</li>
</ul>
<h4><a id="constexpr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>constexpr</h4>
<ul>
<li>编译期间把它当成一个常量</li>
<li>可以用于函数，数据声明， 以及类的构造函数</li>
<li>常量表达式函数</li>
<li>常量构造函数也有约束</li>
</ul>
<h4><a id="auto" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>auto</h4>
<ul>
<li>静态的成员编译的时候必须初始化</li>
</ul>
<h4><a id="decltype" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>decltype</h4>
<pre><code class="language-plain_text">template&lt;typename T1, typename T2&gt;
decltype(a + b) add(T1 a, T2b) {
  auto s = a + b;
  return s;
}
</code></pre>
<p>1）	如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译时错误；<br />
2）	否则，假设e的类型是T，如果e是一个将亡值(xvalue)，那么decltype(e)为T&amp;&amp;；<br />
3）	否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T&amp;；<br />
4）	否则，假设e的类型是T，则decltype(e)为T。</p>
<h4><a id="%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>左值和右值</h4>
<ul>
<li>分配了内存的就是左值，可以取地址</li>
<li>右值和将亡值</li>
<li>T&amp;&amp;右值引用</li>
<li>所有的右值引用叠加到右值引用还是右值引用</li>
<li>所有的其他引用类型迭代都会变成左值引用</li>
</ul>
<h4><a id="std-move-std-forward" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>std::move&amp;&amp;std::forward</h4>
<ul>
<li>move左值转成右值引用</li>
<li>forward关闭引用折叠</li>
</ul>
<h4><a id="final-override" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>final&amp;&amp;override</h4>
<ul>
<li>final表示虚函数不可以重写</li>
<li>override必须重写</li>
</ul>
<h4><a id="delete-default" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>delete&amp;&amp;default</h4>
<ul>
<li>default显式声明使用编译器生成的默认构造函数</li>
<li>delete 阻止编译器生成赋值拷贝构造函数</li>
</ul>
<h4><a id="%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>移动语义</h4>
<ul>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-13T17:59:55+08:00" itemprop="datePublished">2019/08/13 17:59 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15656903952504.html" itemprop="url">
		迭代器</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="const%E8%BF%AD%E4%BB%A3%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>const迭代器</h4>
<ul>
<li>const_iterator</li>
<li>指向的值不能改变，迭代器本身可以改变</li>
</ul>
<h4><a id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>迭代器失效</h4>
<ul>
<li>改变容器容量的操作中，会引起迭代器的失效</li>
<li>容器中增加或者删除元素，可能引起指向容器元素的指针，引用，迭代器失效</li>
<li>插入数据就break</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-21T18:18:03+08:00" itemprop="datePublished">2019/08/21 18:18 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15663826839072.html" itemprop="url">
		RTTI dynamic_cat typeid 虚函数表</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="rtti" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RTTI</h4>
<ul>
<li>运行时类型识别</li>
<li>dynamic_cast 能够将基类的指针转为派生类的指针或者引用</li>
<li>typeid 返回指针或者引用指向的实际类型</li>
<li>想让RTTI正常工作，基类中必须有虚函数，只有虚函数存在才会使用动态类型</li>
<li>对于引用会抛出std::bad_cast</li>
</ul>
<h4><a id="typeid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>typeid</h4>
<ul>
<li>拿到对象类型信息，typeid返回常量对象的引用，对象类型是const std::typeinfo&amp;</li>
<li>主要是为了比较两个指针指向的类型是否相同</li>
<li>指针定义的类型相同。不管new的是啥, typeid都相等</li>
</ul>
<pre><code class="language-plain_text">Human* h1 = new Men;
Human* h2 = new Women;
typeid(h1) == typeid(h2)
</code></pre>
<ul>
<li>指针指向的类型是否相同</li>
</ul>
<pre><code class="language-plain_text">Men* h1 = new Men;
Woman* h2 = new Men;
typeid(*h1) == typeid(*h2)
</code></pre>
<ul>
<li>只有基类有虚函数的时候，编译器才会对表达式求值得</li>
</ul>
<h4><a id="typeinfo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>typeinfo</h4>
<ul>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-10-05T17:58:03+08:00" itemprop="datePublished">2019/10/05 17:58 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15702694837901.html" itemprop="url">
		lamda陷阱</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>捕获异常</h4>
<ul>
<li>捕获列表中的：捕获外部作用域中所有变量，并作为引用在lambda 表达式中使用, 按照引用这种捕获方式，会导致 1 abda 表达式包含绑定到局部变量的引用</li>
</ul>
<pre><code class="language-C++">vector&lt;function&lt;bool(int)&gt;&gt; gv;

void func() {
  srand((int)time(NULL));

  int tmp = rand() % 6;

  gv.push_back([&amp;](int v) {
                if (v % tmp == 0) {
                  return true;
                }
                return false;
               });
}

int main() {
  func();

  cout &lt;&lt; gv[0](10) &lt;&lt; endl;
}
</code></pre>
<ul>
<li>引用捕获超过范围的情形也叫引用悬空</li>
<li>采用按值捕获可以解决引用悬空</li>
</ul>
<h4><a id="%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员变量</h4>
<ul>
<li>=是按值捕获的意思我们会认为这个[=]是按值捕获，使用我们能够访问成员变量tmp,所以我们顺理成量的认为，这里这个1ambda 表达式是所使用的tmp是按值捕获的</li>
<li>lamda表达式的行正确与否，取決于pat対象是否存在,只有PAT对存在，这个lamda表达式行オ正确</li>
<li>this指向对象本身，所以这里[=]捕获的是this指针值</li>
</ul>
<pre><code class="language-C++">vector&lt;function&lt;bool(int)&gt;&gt; gv;
class AT {
 public:
  vector&lt;function&lt;bool(int)&gt;&gt; gv;

  int tmp = 5;
  void addItem() {
    gv.push_back([=](auto v) {
                 if (v % tmp == 0) {
                 return true;
                 }
                 return false;
                 });
  };
};

int main() {
  func();


  AT* pat = new AT();
  pat-&gt;addItem();
  delete pat;
  cout &lt;&lt; gv[0](10) &lt;&lt; endl;
}
</code></pre>
<ul>
<li>使用临时变量来捕获</li>
</ul>
<pre><code class="language-C++">vector&lt;function&lt;bool(int)&gt;&gt; gv;
class AT {
 public:
  vector&lt;function&lt;bool(int)&gt;&gt; gv;

  int tmp = 5;
  void addItem() {
    auto t_tmp = tmp;
    gv.push_back([t_tmp](auto v) {
                 if (v % t_tmp == 0) {
                 return true;
                 }
                 return false;
                 });
  };
};
</code></pre>
<h4><a id="%E5%B9%BF%E4%B9%89%E6%8D%95%E8%8E%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>广义捕获</h4>
<pre><code class="language-C++">class AT {
 public:
  vector&lt;function&lt;bool(int)&gt;&gt; gv;

  int tmp = 5;
  void addItem() {
    gv.push_back([t_tmp = tmp](auto v) {
                 if (v % t_tmp == 0) {
                 return true;
                 }
                 return false;
                 });
  };
};
</code></pre>
<h4><a id="%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态局部变量</h4>
<ul>
<li>捕获不包括静态局部变量，但是可以使用</li>
<li>静态变量使用类似按引用捕获效果</li>
</ul>
<pre><code class="language-C++">vector&lt;function&lt;bool(int)&gt;&gt; gv;

void func() {
  srand((int)time(NULL));

  static int tmp = 5;

  gv.push_back([](auto v) {
                cout &lt;&lt; &quot; static val &quot; &lt;&lt; tmp &lt;&lt; endl;
                if (v % tmp == 0) {
                  return true;
                }
                return false;
               });
  tmp++;
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-10-05T18:47:28+08:00" itemprop="datePublished">2019/10/05 18:47 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15702724482478.html" itemprop="url">
		可变参数函数&&initializer_list</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可变参数函数</h4>
<ul>
<li>这种能够接收非固定个数数的数就是可变参数还数</li>
<li>initialiser_1ist 标准库类型，该类型能够使用的前提条件是所有的实多类型相同</li>
<li>参数类型一致，但是个数不可预知</li>
</ul>
<h4><a id="%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拷贝和赋值</h4>
<ul>
<li>不会拷贝列表中元素，原来对象拷贝</li>
</ul>
<h4><a id="%E7%9C%81%E7%95%A5%E5%8F%B7%E5%BD%A2%E5%8F%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>省略号形参</h4>
<ul>
<li>这种省略形参式的可变参数函数虽然参数数量不固定，但是函数的所有参数是存储在线性连续的空间中的</li>
<li>可变参数只能是字符串类型和int类型</li>
</ul>
<pre><code class="language-C++">double sum(int num, ...) {
  va_list valist;
  double sum = 0;
  va_start(valist, num);
  for (int i = 0; i &lt; num; i++) {
    sum = sum + va_arg(valist, int);
  }
  va_end(valist);
  return sum;
}

void funcTest(const char* msg...) {
  va_list  valist;
  int cnt = atoi(msg);
  va_start(valist, msg);
  int args = 0;
  while (args &lt; cnt) {
    char* p = va_arg(valist, char*);
    printf(&quot;args %d %s \n&quot;, cnt, p);
    args++;
  }
  va_end(valist);
}
</code></pre>
<h4><a id="initialiser-1ist" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>initialiser_1ist</h4>
<pre><code class="language-c++">class FooVec
{
public:
	std::vector&lt;int&gt; m_vec;
 
	FooVec(std::initializer_list&lt;int&gt; list)
	{
		for (auto it = list.begin(); it != list.end(); it++)
			m_vec.push_back(*it);
	}
};
 
int main()
{
	FooVec foo1 { 1, 2, 3, 4, 5, 6 };
	FooVec foo2 { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	return 0;
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-04T18:06:09+08:00" itemprop="datePublished">2019/09/04 18:06 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15675915694548.html" itemprop="url">
		Weak_ptr</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概念</h4>
<ul>
<li>weak_ptr弱 强 shared_ptr</li>
<li>智能指针，指向由shared_ptr管理的对象</li>
<li>不控制对象的生命周期，不会改变引用计数</li>
<li>构造和析构不会增加引用计数</li>
<li>shared_ptr要释放对象的时候照常释放，不管是否有weak_ptr</li>
<li>weak_ptr 监视shared_ptr的生命周期，是shared_ptr的扩充</li>
<li>不是独立的智能指针。不能用来操作所指向的资源，监视对象是否存在</li>
</ul>
<h4><a id="%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常规操作</h4>
<ul>
<li>weak_ptr不能直接来访问对象</li>
<li>需要lock来访问，如果存在，lock就返回一个对象的shared_ptr指针</li>
<li>如果不存在，就返回一个空的shared_ptr</li>
<li>weak_ptr能够判断对象是否存在</li>
</ul>
<h4><a id="%E5%B8%B8%E7%94%A8%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用指针</h4>
<ul>
<li>use_count 获取对象强引用的数量</li>
<li>expired 是否过期，如果use_count=0,对象不存在，观测对象的资源是否被释放</li>
<li>reset 将弱引用指针设置为空，不影响强引用，</li>
</ul>
<h4><a id="%E5%B0%BA%E5%AF%B8%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>尺寸问题</h4>
<ul>
<li>weak_ptr和shared_ptr一样大。裸指针的两倍</li>
<li>第一个指针指向智能指向对象</li>
<li>第二个指针指向shared_ptr生成的控制块</li>
<li><img src="media/15675915694548/15675935853040.jpg" alt="" style="width:898px;" /></li>
<li></li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="C++基础与提高.html">Prev</a>  
	 <a class="next" href="C++基础与提高_2.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>