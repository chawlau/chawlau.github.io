<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	       凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-25T18:24:37+08:00" itemprop="datePublished">2019/08/25 18:24 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15667286771718.html" itemprop="url">
		对象移动，移动构造函数，移动赋值运算符</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对象移动</h4>
<ul>
<li>A移动给B，A对象就不能用了</li>
<li>移动 不是从一块地址移动到另外一个地址，只是所有权变更</li>
<li>移动构造函数Time::Time(const Time&amp;&amp; time)</li>
</ul>
<h4><a id="%E5%AE%8C%E6%88%90%E7%9A%84%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>完成的功能</h4>
<ul>
<li>完成必要的内存移动，斩断原对象和内存的关系</li>
<li>确保移动后源对象即使销毁也没有问题，B&lt;-A 确保不再使用A，而是应该去使用B</li>
<li>noexcept 提高编译器效率</li>
</ul>
<h4><a id="%E5%90%88%E6%88%90%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>合成的移动操作</h4>
<ul>
<li>有自己的拷贝构造函数，拷贝赋值运算符，或者自己的析构，编译器不会为其合成</li>
<li>没有自己的拷贝构造函数，拷贝赋值运算符，或者自己的析构</li>
<li>只有一个类没定义任何自己版本的拷贝构造函数，并且非静态成员都可以移动，</li>
<li>内置类型是可以移动</li>
<li>类类型的成员，这个类必须要有对应的移动操作的函数</li>
</ul>
<h4><a id="%E5%AE%B9%E5%99%A8%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>容器移动构造函数</h4>
<pre><code class="language-C++">//
// Created by eredinliu on 2020-02-06.
//


#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Obj1 {
public:
    Obj1()
    {
        cout &lt;&lt; &quot;Obj1()\n&quot;;
    }
    Obj1(const Obj1&amp;)
    {
        cout &lt;&lt; &quot;Obj1(const Obj1&amp;)\n&quot;;
    }
    Obj1(Obj1&amp;&amp;)
    {
        cout &lt;&lt; &quot;Obj1(Obj1&amp;&amp;)\n&quot;;
    }
};

class Obj2 {
public:
    Obj2()
    {
        cout &lt;&lt; &quot;Obj2()\n&quot;;
    }
    Obj2(const Obj2&amp;)
    {
        cout &lt;&lt; &quot;Obj2(const Obj2&amp;)\n&quot;;
    }
    Obj2(Obj2&amp;&amp;) noexcept
    {
        cout &lt;&lt; &quot;Obj2(Obj2&amp;&amp;)\n&quot;;
    }
};

int main()
{
    vector&lt;Obj1&gt; v1;
    v1.reserve(2);
    v1.emplace_back();
    v1.emplace_back();
    v1.emplace_back();

    cout &lt;&lt; &quot; ==================\n&quot;;
    vector&lt;Obj2&gt; v2;
    v2.reserve(2);
    v2.emplace_back();
    v2.emplace_back();
    v2.emplace_back();
}
</code></pre>
<ul>
<li>vector 通常保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数，vector 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 noexcept，或只在容器中放置对象的智能指针。</li>
<li>emplace_back系列函数是为了提升容器的性能而设计的</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-05T18:19:51+08:00" itemprop="datePublished">2019/09/05 18:19 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15676787915607.html" itemprop="url">
		Shared_ptr使用场景，陷阱和性能分析</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用场景</h4>
<ul>
<li>临时局部变量返回</li>
</ul>
<pre><code class="language-plain_text">shared_ptr&lt;int&gt; create(int val) {
  return make_shared&lt;int&gt;(val);
}

shared_ptr&lt;int&gt;func(int val) {
  shared_ptr&lt;int&gt; ptr = create(5);
  return ptr;
}
ptr返回的引用计数没有增加
</code></pre>
<ul>
<li>不允许隐式转换</li>
<li>裸指针绑定到shared_ptr后，管理权限就交给智能指针了，不能再操作裸指针</li>
</ul>
<h4><a id="%E6%B3%A8%E6%84%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意</h4>
<ul>
<li>不要delete get()返回的指针</li>
<li>不能随便释放get返回的指针</li>
</ul>
<pre><code class="language-plain_text">  shared_ptr&lt;int&gt; p1(p);
  shared_ptr&lt;int&gt; p2(p); //p2p1无关联，导致p1p2内存被释放两次
  shared_ptr&lt;int&gt; p1(new int);
  shared_ptr&lt;int&gt; p2(p1); //这种写法p1p2互通，使用同一个控制块kkk
</code></pre>
<h4><a id="this%E8%BF%94%E5%9B%9E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>this返回</h4>
<ul>
<li>不要把this作为shared_ptr返回</li>
<li>裸指针初始化多个智能指针会导致指向同一内存，但是不是同一控制块</li>
<li>enable_shared_from_this</li>
<li>shared_from_this</li>
<li>enable_shared_from_this中又个weak_ptr监视this，shared_from_this,嗲用了lock方法，让引用计数+1，同时返回shared_ptr</li>
</ul>
<h4><a id="%E6%80%A7%E8%83%BD%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>性能说明</h4>
<ul>
<li>shared_ptr weak_ptr是裸指针的两倍</li>
<li>第一个指针指向智能指针所指向的对象</li>
<li>第二个指针指向的是控制块</li>
<li>1）指向对象的强引用计数shared_ptr</li>
<li>
<ol start="2">
<li>指向对象的弱引用计数weak_ptr</li>
</ol>
</li>
<li>
<ol start="3">
<li>删除器指针 内存分配器</li>
</ol>
</li>
<li>控制块是由第一个指向对象的shared_ptr创建的</li>
</ul>
<h4><a id="%E6%8E%A7%E5%88%B6%E5%9D%97%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>控制块创建时机</h4>
<ul>
<li>make_shared 分配并且初始化一个对象，返回对象的shared_ptr</li>
</ul>
<h4><a id="%E8%A3%B8%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96shared-ptr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>裸指针初始化shared_ptr</h4>
<ul>
<li>int* p = new  int;</li>
<li>shared_ptr<int> p1(p)</li>
<li>shared_ptr<int> p2(p)</li>
<li>不允许，会产生多个控制块，就有多个引用计数，导致析构多次</li>
</ul>
<h4><a id="%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>移动语义</h4>
<ul>
<li>shared_ptr<int> p1(new int(100))</li>
<li>shared_ptr<int> p2(std::move(p1))</li>
<li>移动构造一个新的智能指针对象p2,p1就不再指向该对象，引用计数依旧是一</li>
<li>shared_ptr<int> p3</li>
<li>p3 = std::move(p2)</li>
<li>移动赋值运算符比拷贝构造函数快</li>
</ul>
<h4><a id="%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用建议</h4>
<ul>
<li>分配器解决内存分配</li>
<li>优先使用make_shared</li>
<li>shared_ptr<string> s1(new string(&quot;new&quot;)) 分配两次内存</li>
<li>auto ps2 = make_shared<string>(&quot;new&quot;) 分配一次内存</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-06T19:13:31+08:00" itemprop="datePublished">2019/09/06 19:13 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15677684117226.html" itemprop="url">
		unique_ptr</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概述</h4>
<ul>
<li>独占式的，专属所有权，同一时刻，只能有一个unique_ptr指针指向这块对象</li>
<li>当这个unique_ptr被销毁的时候，它所指向的对象也被销毁</li>
</ul>
<h4><a id="make-unique" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>make_unique</h4>
<ul>
<li>c++14才有</li>
<li>不支持指定的删除器语法</li>
</ul>
<h4><a id="%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不支持的操作</h4>
<ul>
<li>unique_ptr<string> ps1(new string(&quot;I love China&quot;));</li>
<li>unique_ptr<string> ps2(ps1)</li>
<li>拷贝，赋值</li>
</ul>
<h4><a id="%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>移动语义</h4>
<ul>
<li>unique_ptr<int> ps5 = std::move(pi3);</li>
</ul>
<h4><a id="release" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>release()</h4>
<ul>
<li>放弃指针控制权，返回裸指针，将该指针置空</li>
<li>裸指针可以释放，可以delete, 也可以初始化另外的智能指针</li>
<li>直接release会导致内存泄露</li>
<li>int* tmp = p5.release();</li>
<li>delete tmp</li>
</ul>
<h4><a id="reset" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reset</h4>
<ul>
<li>不带参数，释放智能指针所指向的对象，并且将智能指针置为空</li>
<li>带参数 释放智能指针所指向的对象，并且将智能指针指向新对象</li>
<li>pi2.reset(p5.release());</li>
</ul>
<h4><a id="nullptr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>nullptr</h4>
<ul>
<li>释放智能指针指向的对象，并将智能指针置空</li>
</ul>
<h4><a id="%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>指向数组</h4>
<ul>
<li>unique_ptr<A> ptr(new A[10]) A没有析构函数，正常</li>
<li>有析构函数，会导致异常</li>
</ul>
<h4><a id="get" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>get()</h4>
<ul>
<li>有些函数的参数需要内置的裸指针</li>
<li>get的指针千万不要delete</li>
</ul>
<h4><a id="swap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>swap</h4>
<ul>
<li>交换智能指针指向的对象</li>
</ul>
<h4><a id="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>智能指针作为判断条件</h4>
<ul>
<li>if (ptr)</li>
</ul>
<h4><a id="%E8%BD%AC%E6%8D%A2%E4%B8%BAshared-ptr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>转换为shared_ptr</h4>
<ul>
<li>shared_ptr有个显式的构造函数。用于将shared_ptr转换为unique_ptr</li>
<li>临时对象都是右值</li>
<li>unique_ptr没有控制块</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-05T09:16:40+08:00" itemprop="datePublished">2019/09/05 09:16 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15676462008800.html" itemprop="url">
		动态规划</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>记忆化搜索</h4>
<ul>
<li>递归是自上向下</li>
</ul>
<h4><a id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态规划</h4>
<ul>
<li>自下而上的解决问题</li>
<li>将原问题拆解成若干子问题，保存子问题的答案，使得每个子问题都只求解一次</li>
<li>递归问题-&gt;重叠子问题-&gt;</li>
<li>leet_120</li>
<li>leet_64 没有非负整数， 没有限制条件</li>
<li>leet_343 回溯</li>
<li><img src="media/15676462008800/15680798276938.jpg" alt="" style="width:1006px;" /></li>
<li><img src="media/15676462008800/15680799034216.jpg" alt="" style="width:996px;" /></li>
<li>leet_279</li>
<li><img src="media/15676462008800/15680822078106.jpg" alt="" style="width:1149px;" /></li>
<li>leet_79</li>
<li>leet_62</li>
<li>leet_63</li>
</ul>
<h4><a id="leet-198" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>leet_198</h4>
<ul>
<li><img src="media/15676462008800/15676509845611.jpg" alt="" style="width:1066px;" /></li>
<li><img src="media/15676462008800/15676510940203.jpg" alt="" style="width:1166px;" /></li>
<li>状态定义和状态转移一定要搞懂</li>
<li><img src="media/15676462008800/15676523958822.jpg" alt="" style="width:922px;" /></li>
<li>使用新的状态定义</li>
<li>leet_213</li>
<li>leet_337</li>
<li>leet_309</li>
</ul>
<h4><a id="0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0-1背包问题</h4>
<ul>
<li>O(2^n*n)</li>
<li>贪心算法</li>
<li><img src="media/15676462008800/15679064880244.jpg" alt="" style="width:976px;" /></li>
<li>自顶向下 递归</li>
<li>自底向上 动态规划</li>
<li>背包问题优化</li>
<li><img src="media/15676462008800/15679083241737.jpg" alt="" style="width:1001px;" /></li>
</ul>
<h4><a id="%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背包问题</h4>
<ul>
<li>每个物品可以无限使用</li>
<li>多重背包问题</li>
<li>物品之间加入更多约束</li>
</ul>
<h4><a id="leetcode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>leetcode</h4>
<ul>
<li>leet_416</li>
<li><img src="media/15676462008800/15679109143760.jpg" alt="" style="width:1002px;" /></li>
<li>leet_300</li>
<li><img src="media/15676462008800/15679095425409.jpg" alt="" style="width:989px;" /></li>
<li><img src="media/15676462008800/15679098812535.jpg" alt="" style="width:1012px;" /></li>
<li><img src="media/15676462008800/15679103037974.jpg" alt="" style="width:821px;" /></li>
<li>没有递增的特性</li>
<li>LIS问题的O(nlogn)解法</li>
<li>leet_376</li>
<li>leet_322</li>
<li>leet_377</li>
<li>leet_474</li>
<li>leet_139</li>
<li>leet_494</li>
</ul>
<h4><a id="more" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>more</h4>
<ul>
<li>最长公共子序列</li>
<li><img src="media/15676462008800/15679159466365.jpg" alt="" style="width:972px;" /></li>
<li><img src="media/15676462008800/15679161027984.jpg" alt="" style="width:1023px;" /></li>
</ul>
<h4><a id="dijkstra" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>dijkstra</h4>
<ul>
<li>单源最短路径算法</li>
<li><img src="media/15676462008800/15679162036286.jpg" alt="" style="width:815px;" /></li>
</ul>
<h4><a id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%90%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态规划子问题</h4>
<ul>
<li><img src="media/15676462008800/15679164823964.jpg" alt="" style="width:1028px;" /></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-29T06:54:42+08:00" itemprop="datePublished">2019/09/29 06:54 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html'>Mysql性能管理和架构设计</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15697112820357.html" itemprop="url">
		索引性能优化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引类型</h4>
<h4><a id="b-tree%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>B+tree索引</h4>
<ul>
<li>B-tree 过引以 B+树的结构存储数据</li>
<li>Innodb通过主键。Myisam通过物理位置引用物理行</li>
<li>B-tree 索引能够加快数据的查询速度</li>
<li>B-tree 索引更适合进行范围查找</li>
</ul>
<h5><a id="%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>能够使用索引的场景</h5>
<ul>
<li>全值匹配的查询</li>
<li>匹配最左前缀的查询</li>
<li>匹配列前缀查询 orders_sn like '9876%'</li>
<li>匹配范围值的查询</li>
<li>精确匹配左前列并范围匹配另外一列</li>
<li>只访问索引的查询 覆盖索引</li>
</ul>
<h5><a id="%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用限制</h5>
<ul>
<li>如果不是按照索引最左列开始查找，则无法使用索引</li>
<li>使用索引时不能跳过索引中的列</li>
<li>Not in和&lt;&gt;无法使用</li>
<li>如果査询中有某个列的范围查询，则其右边所有列都无法使用索引</li>
</ul>
<h4><a id="hash%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hash索引</h4>
<ul>
<li>只能等值查询</li>
<li>Hash 索引是基于 Hash 表实现的，只有查询条件精确匹配 Hash 索引中的所有列时，才能够使用到 hash 索引。</li>
<li>对于 Hash 索引中的所有列，存储引擎都会为每一行计算一个 Hash 码，Hash 索引中存储的就是 Hash 码。</li>
<li>Hash 索引必须进行二次查找</li>
<li>Hash 索引无法用于排序</li>
<li>Hash 索引不支持部分索引查找也不支持范闺查找</li>
<li>Hash 索引中 Hash 码的计算可能存在 Hash冲突</li>
</ul>
<h4><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么使用索引</h4>
<ul>
<li>索引大大減少了存储引孳需要扫描的数据量</li>
<li>索引可以帮助我们进行排序以避免使用临时表</li>
<li>索引可以把随机I/O変为顺序I/O</li>
</ul>
<h4><a id="%E7%B4%A2%E5%BC%95%E6%98%AF%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引是不是越多越好</h4>
<ul>
<li>索引会增加写操作的成本</li>
<li>太多的索引会增加查询优化器的选择时间</li>
</ul>
<h4><a id="%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引优化策略</h4>
<h5><a id="%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%88%96%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引列上不能使用表达式或函数</h5>
<p><img src="media/15697112820357/15697127274946.jpg" alt="" style="width:1103px;" /></p>
<h5><a id="%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前缀索引和索引列的选择性</h5>
<p><img src="media/15697112820357/15697128097620.jpg" alt="" style="width:952px;" /></p>
<ul>
<li>索引的选择性是不重复的索引值和表的记录数的比值<br />
<img src="media/15697112820357/15697128954405.jpg" alt="" style="width:700px;" /></li>
</ul>
<h5><a id="%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>联合索引</h5>
<ul>
<li>经常会被使用到的列优先</li>
<li>选择高的列优先</li>
<li>宽度小的列优先</li>
</ul>
<h5><a id="%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>覆盖索引</h5>
<ul>
<li>可以优化缓存，减少磁盘IO操作</li>
<li>可以减少随机 IO，変随机 IO 操作变为 O 操作</li>
<li>可以避免对 Innodb 主键索引的二次査询</li>
<li>可以避免MYISAM 表进行系统调用</li>
<li>无法使用的情况</li>
<li>存储引擎不支持覆盖索引</li>
<li>査询中使用了太多的列</li>
<li>使用了双%号的 like 查询</li>
</ul>
<h4><a id="%E9%80%82%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9D%A5%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>适用索引来优化查询</h4>
<h5><a id="%E9%80%9A%E8%BF%87%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通过排序操作</h5>
<ul>
<li>innodb索引顺序和主键顺序是一致的</li>
<li>索引的列顺序和 Order By 子句的顺序完全一致</li>
<li>索引中所有列的方向升序降序和 Order by 子句完全致 Order by 中的字段全部在关联表中的第一张表中<br />
<img src="media/15697112820357/15697147233050.jpg" alt="" style="width:1733px;" /></li>
</ul>
<h5><a id="%E6%8C%89%E7%85%A7%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%89%AB%E6%8F%8F%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>按照索引顺序扫描数据</h5>
<h4><a id="%E6%A8%A1%E6%8B%9Fhash%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模拟hash索引</h4>
<ul>
<li>只能处理键值的全值匹配查找</li>
<li>所使用的 Hash 函数决定着索引键的大小</li>
</ul>
<h4><a id="%E7%B4%A2%E5%BC%95%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引效果</h4>
<ul>
<li>减少锁定的行数</li>
<li>加快锁的释放，增加并发</li>
</ul>
<h4><a id="%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%B4%E6%8A%A4%E5%92%8C%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引的维护和优化</h4>
<ul>
<li>删除重复和冗余的索引</li>
<li>使用工具pt-duplicat-key-checker h = 127.0.0.1</li>
<li>查找未被使用过的索引</li>
</ul>
<pre><code class="language-plain_text">select object_schema,object_name,index_name,b.`TABLE_ROWS` FROM  
performance_schema.table_io_waits_summary_by_index_usage a 
JOIN information_schema.tables b ON
a.`OBJECT_SCHEMA`=b.`TABLE_SCHEMA` AND
a.`OBJECT_NAME`=b.`TABLE_NAME`
WHERE index_name IS NOT NULL
AND count_star = 0
ORDER BY object_schema,object_name;
</code></pre>
<ul>
<li>更新索引统计信息较少索引碎片</li>
<li>analysz table table_name</li>
<li>optimize table table_name</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-07-23T10:30:17+08:00" itemprop="datePublished">2019/07/23 10:30 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15638490173383.html" itemprop="url">
		算法思路</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E9%A2%98%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>题目中的条件</h4>
<ul>
<li>设计O(nlogn)的算法 百万级和千万级</li>
<li>无需考虑额外的空间</li>
<li>数据规模大概是10000</li>
</ul>
<h4><a id="%E6%B2%A1%E6%9C%89%E6%80%9D%E8%B7%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>没有思路</h4>
<ul>
<li>给几个简单的测试用例</li>
<li>不要忽视暴力解法，暴力解法通常是思考的起点</li>
<li>lecode3</li>
<li>遍历常见的算法思路</li>
<li>遍历常见的数据结构</li>
<li>空间和时间的交换(哈希表)</li>
<li>预处理信息</li>
</ul>
<h4><a id="%E6%9E%81%E7%AB%AF%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>极端条件</h4>
<ul>
<li>数组为空</li>
<li>字符串为空</li>
<li>数量为0</li>
<li>指针为NULL</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-02T10:36:11+08:00" itemprop="datePublished">2019/08/02 10:36 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15647133717861.html" itemprop="url">
		查找表</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%B8%A4%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>两类</h4>
<ul>
<li>查找有无</li>
<li>查找对应关系</li>
<li>有序和查找是关联</li>
<li>如果数组有序</li>
<li>leet_349</li>
</ul>
<pre><code class="language-C++">Given two arrays, write a function to compute their intersection.
class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        set&lt;int&gt; s(nums1.begin(), nums1.end()), res;
        for (auto a : nums2) {
            if (s.count(a)) res.insert(a);
        }
        return vector&lt;int&gt;(res.begin(), res.end());
    }
};
</code></pre>
<ul>
<li>leet_350</li>
</ul>
<pre><code class="language-C++">Given two arrays, write a function to compute their intersection.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        unordered_map&lt;int, int&gt; m;
        vector&lt;int&gt; res;
        for (auto a : nums1) ++m[a];
        for (auto a : nums2) {
            if (m[a]-- &gt; 0) res.push_back(a);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_242</li>
</ul>
<pre><code class="language-C++">For example,
s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.
s = &quot;rat&quot;, t = &quot;car&quot;, return false.

class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size()) return false;
        int m[26] = {0};
        for (int i = 0; i &lt; s.size(); ++i) ++m[s[i] - 'a'];
        for (int i = 0; i &lt; t.size(); ++i) {
            if (--m[t[i] - 'a'] &lt; 0) return false;
        }
        return true;
    }
};
</code></pre>
<ul>
<li>leet_202</li>
</ul>
<pre><code class="language-C++">Write an algorithm to determine if a number is &quot;happy&quot;.

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example: 

Input: 19
Output: true
Explanation: 
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
class Solution {
public:
    bool isHappy(int n) {
        while (n != 1 &amp;&amp; n != 4) {
            int sum = 0;
            while (n) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            n = sum;
        }
        return n == 1;
    }
};
</code></pre>
<ul>
<li>leet_290</li>
</ul>
<pre><code class="language-C++">Given a pattern and a string str, find if str follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

Example 1:

Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;
Output: true
Example 2:

Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;
Output: false
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        unordered_map&lt;char, int&gt; m1;
        unordered_map&lt;string, int&gt; m2;
        istringstream in(str);
        int i = 0, n = pattern.size();
        for (string word; in &gt;&gt; word; ++i) {
            if (i == n || m1[pattern[i]] != m2[word]) return false;
            m1[pattern[i]] = m2[word] = i + 1;
        }
        return i == n;
    }
};
</code></pre>
<ul>
<li>leet_205</li>
</ul>
<pre><code class="language-C++">Given two strings  s  and  t , determine if they are isomorphic.

Two strings are isomorphic if the characters in  s  can be replaced to get  t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

Example 1:

Input: _s_ = &quot;egg&quot;, _t =_&quot;add&quot;
Output: true
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int m1[256] = {0}, m2[256] = {0}, n = s.size();
        for (int i = 0; i &lt; n; ++i) {
            if (m1[s[i]] != m2[t[i]]) return false;
            m1[s[i]] = i + 1;
            m2[t[i]] = i + 1;
        }
        return true;
    }
};
</code></pre>
<ul>
<li>leet_451</li>
</ul>
<pre><code class="language-C++">Input:
&quot;tree&quot;

Output:
&quot;eert&quot;

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore &quot;eetr&quot; is also a valid answer.
class Solution {
public:
    string frequencySort(string s) {
        string res;
        vector&lt;string&gt; v(s.size() + 1);
        unordered_map&lt;char, int&gt; m;
        for (char c : s) ++m[c];
        for (auto &amp;a : m) {
            v[a.second].append(a.second, a.first);
        }
        for (int i = s.size(); i &gt; 0; --i) {
            if (!v[i].empty()) res.append(v[i]);
        }
        return res;
    }
};
</code></pre>
<h4><a id="%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>两数求和</h4>
<ul>
<li>leet_1 排序后,双索引对撞</li>
</ul>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.count(target - nums[i])) {
                return {i, m[target - nums[i]]};
            }
            m[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>
<ul>
<li>leet_15</li>
</ul>
<pre><code class="language-C++">Given an array  S  of  n  integers, are there elements  a ,  b ,  c  in  S  such that  a  +  b  +  c  = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

Elements in a triplet ( a , b , c ) must be in non-descending order. (ie,  a  ≤  b  ≤  c )
The solution set must not contain duplicate triplets.
 

    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; res;
        sort(nums.begin(), nums.end());
        if (nums.empty() || nums.back() &lt; 0 || nums.front() &gt; 0) return {};
        for (int k = 0; k &lt; (int)nums.size() - 2; ++k) {
            if (nums[k] &gt; 0) break;
            if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue;
            int target = 0 - nums[k], i = k + 1, j = (int)nums.size() - 1;
            while (i &lt; j) {
                if (nums[i] + nums[j] == target) {
                    res.push_back({nums[k], nums[i], nums[j]});
                    while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) ++i;
                    while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j;
                    ++i; --j;
                } else if (nums[i] + nums[j] &lt; target) ++i;
                else --j;
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_18</li>
</ul>
<pre><code class="language-C++">Given an array S of n integers, are there elements a , b , c , and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

Elements in a quadruplet ( a , b , c , d ) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d )

The solution set must not contain duplicate quadruplets.

For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt; &amp;nums, int target) {
        vector&lt;vector&lt;int&gt;&gt; res;
        int n = nums.size();
        sort(nums.begin(), nums.end());
        for (int i = 0; i &lt; n - 3; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j &lt; n - 2; ++j) {
                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;
                int left = j + 1, right = n - 1;
                while (left &lt; right) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        vector&lt;int&gt; out{nums[i], nums[j], nums[left], nums[right]};
                        res.push_back(out);
                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left;
                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right;
                        ++left; --right;
                    } else if (sum &lt; target) ++left;
                    else --right;
                }
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_16</li>
</ul>
<pre><code class="language-C++">Given array nums = [-1, 2, 1, -4], and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        int closest = nums[0] + nums[1] + nums[2];
        int diff = abs(closest - target);
        sort(nums.begin(), nums.end());
        for (int i = 0; i &lt; nums.size() - 2; ++i) {
            int left = i + 1, right = nums.size() - 1;
            while (left &lt; right) {
                int sum = nums[i] + nums[left] + nums[right];
                int newDiff = abs(sum - target);
                if (diff &gt; newDiff) {
                    diff = newDiff;
                    closest = sum;
                }
                if (sum &lt; target) ++left;
                else --right;
            }
        }
        return closest;
    }
};
</code></pre>
<h4><a id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态规划</h4>
<ul>
<li>leet120 Triangle</li>
</ul>
<pre><code class="language-C++">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {
        vector&lt;int&gt; dp(triangle.back());
        for (int i = (int)triangle.size() - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt;= i; ++j) {
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j];
            }
        }
        return dp[0];
    }
};
</code></pre>
<ul>
<li>leet64 minium path sum</li>
</ul>
<pre><code class="language-C++">Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) {
        int m = grid.size(), n = grid[0].size();
        int dp[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 1; i &lt; m; ++i) dp[i][0] = grid[i][0] + dp[i - 1][0];
        for (int i = 1; i &lt; n; ++i) dp[0][i] = grid[0][i] + dp[0][i - 1];
        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m - 1][n - 1];
    }
};
</code></pre>
<ul>
<li>leet343 integer break</li>
</ul>
<pre><code class="language-C++">Given a positive integer  n , break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

Example 1:

Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
class Solution {
public:
    int integerBreak(int n) {
        vector&lt;int&gt; dp(n + 1, 1);
        for (int i = 3; i &lt;= n; ++i) {
            for (int j = 1; j &lt; i; ++j) {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
</code></pre>
<ul>
<li>leet279 perfect squares</li>
</ul>
<pre><code class="language-C++">Given a positive integer  n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to  n.

Example 1:

Input: _n_ = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: _n_ = 13
Output: 2
Explanation: 13 = 4 + 9.
class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i &lt;= n; ++i) {
            for (int j = 1; i + j * j &lt;= n; ++j) {
                dp[i + j * j] = min(dp[i + j * j], dp[i] + 1);
            }
        }
        return dp.back();
    }
};
</code></pre>
<ul>
<li>leet91 decode ways</li>
</ul>
<pre><code class="language-C++">A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: &quot;12&quot;
Output: 2
Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).
，在遍历的过程中，对每个数字首先判断其是否为0，若是则将 dp[i] 赋为0，若不是，赋上 dp[i-1] 的值，然后看数组前一位是否存在，如果存在且满足前一位是1，或者和当前位一起组成的两位数不大于 26，则当前 dp[i] 值加上 dp[i - 2]。最终返回 dp 数组的最后一个值即可
dp[i] = dp[i-1] + dp[i-2]
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s[0] == '0') return 0;
        vector&lt;int&gt; dp(s.size() + 1, 0);
        dp[0] = 1;
        for (int i = 1; i &lt; dp.size(); ++i) {
            if (s[i - 1] != '0') dp[i] += dp[i - 1];
            if (i &gt;= 2 &amp;&amp; s.substr(i - 2, 2) &lt;= &quot;26&quot; &amp;&amp; s.substr(i - 2, 2) &gt;= &quot;10&quot;) {
                dp[i] += dp[i - 2];
            }
        }
        return dp.back();
    }
};
</code></pre>
<ul>
<li>leet62 unique path</li>
</ul>
<pre><code class="language-C++">A robot is located at the top-left corner of a  m  x  n  grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; dp(n, 1);
        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[j] += dp[j - 1]; 
            }
        }
        return dp[n - 1];
    }
};
</code></pre>
<ul>
<li>leet63 unique path</li>
</ul>
<pre><code class="language-C++">这里还需要初始化 dp 数组的某个值，使得其能正常累加。当起点不是障碍物时，其 dp 值应该为1，即dp[1][1] = 1，由于其是由 dp[0][1] + dp[1][0] 更新而来，所以二者中任意一个初始化为1即可。由于之后 LeetCode 更新了这道题的 test case，使得使用 int 型的 dp 数组会有溢出的错误，所以改为使用 long 型的数组来避免 overflow，代码如下
class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector&lt;vector&lt;long&gt;&gt; dp(m + 1, vector&lt;long&gt;(n + 1, 0));
        dp[0][1] = 1;
        for (int i = 1; i &lt;= m; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                if (obstacleGrid[i - 1][j - 1] != 0) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
};
class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector&lt;long&gt; dp(n, 0);
        dp[0] = 1;
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (obstacleGrid[i][j] == 1) dp[j] = 0;
                else if (j &gt; 0) dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
</code></pre>
<ul>
<li>leet673</li>
</ul>
<h4><a id="%E6%9F%A5%E6%89%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查找</h4>
<ul>
<li>leet_350</li>
<li>leet_49</li>
</ul>
<pre><code class="language-C++">Given an array of strings, group anagrams together.

Example:

Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
Output:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        vector&lt;vector&lt;string&gt;&gt; res;
        unordered_map&lt;string, vector&lt;string&gt;&gt; m;
        for (string str : strs) {
            vector&lt;int&gt; cnt(26, 0);
            string t = &quot;&quot;;
            for (char c : str) ++cnt[c - 'a'];
            for (int d : cnt) t += to_string(d) + &quot;/&quot;;
            m[t].push_back(str);
        }
        for (auto a : m) {
            res.push_back(a.second);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_447</li>
</ul>
<pre><code class="language-C++">Given n points in the plane that are all pairwise distinct, a &quot;boomerang&quot; is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k ( the order of the tuple matters ).

Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).

Example:

**Input:**
[[0,0],[1,0],[2,0]]

**Output:**
2

**Explanation:**
The two boomerangs are **[[1,0],[0,0],[2,0]]** and **[[1,0],[2,0],[0,0]]**
class Solution {
public:
    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {
        int res = 0;
        for (int i = 0; i &lt; points.size(); ++i) {
            unordered_map&lt;int, int&gt; m;
            for (int j = 0; j &lt; points.size(); ++j) {
                int a = points[i].first - points[j].first;
                int b = points[i].second - points[j].second;
                ++m[a * a + b * b];
            }
            for (auto it = m.begin(); it != m.end(); ++it) {
                res += it-&gt;second * (it-&gt;second - 1);
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_149 点坐标的表示 整数 浮点数</li>
</ul>
<pre><code class="language-C++">Given  n  points on a 2D plane, find the maximum number of points that lie on the same straight line.

Example 1:

Input: [[1,1],[2,2],[3,3]]
Output: 3
Explanation:
^
|
|        o
|     o
|  o  
+-------------&gt;
0  1  2  3  4
class Solution {
public:
    int maxPoints(vector&lt;Point&gt;&amp; points) {
        int res = 0;
        for (int i = 0; i &lt; points.size(); ++i) {
            map&lt;pair&lt;int, int&gt;, int&gt; m;
            int duplicate = 1;
            for (int j = i + 1; j &lt; points.size(); ++j) {
                if (points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y) {
                    ++duplicate; continue;
                } 
                int dx = points[j].x - points[i].x;
                int dy = points[j].y - points[i].y;
                int d = gcd(dx, dy);
                ++m[{dx / d, dy / d}];
            }
            res = max(res, duplicate);
            for (auto it = m.begin(); it != m.end(); ++it) {
                res = max(res, it-&gt;second + duplicate);
            }
        }
        return res;
    }
    int gcd(int a, int b) {
        return (b == 0) ? a : gcd(b, a % b);
    }
};
</code></pre>
<h4><a id="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%9F%A5%E6%89%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>滑动窗口和查找</h4>
<ul>
<li>leet_217</li>
</ul>
<pre><code class="language-C++">Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.find(nums[i]) != m.end()) return true;
            ++m[nums[i]];
        }
        return false;
    }
};
</code></pre>
<ul>
<li>leet_219</li>
</ul>
<pre><code class="language-C++">Given an array of integers and an integer k, return true if and only if there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. (Old Version)

Given an array of integers and an integer k , find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. (New Version)
class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.find(nums[i]) != m.end() &amp;&amp; i - m[nums[i]] &lt;= k) return true;
            else m[nums[i]] = i;
        }
        return false;
    }
};
</code></pre>
<ul>
<li>leet_220</li>
</ul>
<pre><code class="language-C++">Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) {
      map&lt;long long, int&gt; m;
      int j = 0;
      for (int i = 0; i &lt; nums.size(); i++) {
        if (i - j &gt; k) m.erase(nums[j++]);
        auto a = m.lower_bound((long long)nums[i] - t);
        if (a != m.end() &amp;&amp; abs(a-&gt;first - nums[i]) &lt;= t) return true;
        m[nums[i]] = i;
      }
      return false;
    }
};
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-20T09:30:49+08:00" itemprop="datePublished">2019/08/20 09:30 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15662646498238.html" itemprop="url">
		队列</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>栈</h4>
<ul>
<li>leet_20</li>
</ul>
<pre><code class="language-C++">Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; parentheses;
        for (int i = 0; i &lt; s.size(); ++i) {
            if (s[i] == '(' || s[i] == '[' || s[i] == '{') parentheses.push(s[i]);
            else {
                if (parentheses.empty()) return false;
                if (s[i] == ')' &amp;&amp; parentheses.top() != '(') return false;
                if (s[i] == ']' &amp;&amp; parentheses.top() != '[') return false;
                if (s[i] == '}' &amp;&amp; parentheses.top() != '{') return false;
                parentheses.pop();
            }
        }
        return parentheses.empty();
    }
}; 
</code></pre>
<ul>
<li>leet_150</li>
</ul>
<pre><code class="language-C++">Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
Output: 9
Explanation: ((2 + 1) * 3) = 9
class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        if (tokens.size() == 1) return stoi(tokens[0]);
        stack&lt;int&gt; st;
        for (int i = 0; i &lt; tokens.size(); ++i) {
            if (tokens[i] != &quot;+&quot; &amp;&amp; tokens[i] != &quot;-&quot; &amp;&amp; tokens[i] != &quot;*&quot; &amp;&amp; tokens[i] != &quot;/&quot;) {
                st.push(stoi(tokens[i]));
            } else {
                int num1 = st.top(); st.pop();
                int num2 = st.top(); st.pop();
                if (tokens[i] == &quot;+&quot;) st.push(num2 + num1);
                if (tokens[i] == &quot;-&quot;) st.push(num2 - num1);
                if (tokens[i] == &quot;*&quot;) st.push(num2 * num1);
                if (tokens[i] == &quot;/&quot;) st.push(num2 / num1);
            }
        }
        return st.top();
    }
};

class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        int op = (int)tokens.size() - 1;
        return helper(tokens, op);
    }
    int helper(vector&lt;string&gt;&amp; tokens, int&amp; op) {
        string str = tokens[op];
        if (str != &quot;+&quot; &amp;&amp; str != &quot;-&quot; &amp;&amp; str != &quot;*&quot; &amp;&amp; str != &quot;/&quot;) return stoi(str);
        int num1 = helper(tokens, --op);
        int num2 = helper(tokens, --op);
        if (str == &quot;+&quot;) return num2 + num1;
        if (str == &quot;-&quot;) return num2 - num1;
        if (str == &quot;*&quot;) return num2 * num1;
        return num2 / num1;
    }
};
</code></pre>
<ul>
<li>leet_71</li>
</ul>
<pre><code class="language-C++">For example,
path = &quot;/home/&quot;, =&gt; &quot;/home&quot;
path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot;
class Solution {
public:
    string simplifyPath(string path) {
        vector&lt;string&gt; v;
        int i = 0;
        while (i &lt; path.size()) {
            while (path[i] == '/' &amp;&amp; i &lt; path.size()) ++i;
            if (i == path.size()) break;
            int start = i;
            while (path[i] != '/' &amp;&amp; i &lt; path.size()) ++i;
            int end = i - 1;
            string s = path.substr(start, end - start + 1);
            if (s == &quot;..&quot;) {
                if (!v.empty()) v.pop_back(); 
            } else if (s != &quot;.&quot;) {
                v.push_back(s);
            }
        }
        if (v.empty()) return &quot;/&quot;;
        string res;
        for (int i = 0; i &lt; v.size(); ++i) {
            res += '/' + v[i];
        }
        return res;
    }
};
</code></pre>
<h4><a id="%E6%A0%88%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E7%B4%A7%E5%AF%86%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>栈和递归的紧密关系</h4>
<ul>
<li>leet_144</li>
</ul>
<pre><code class="language-C++">For example:
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3
 
return [1,2,3].
class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (!s.empty() || p) {
            if (p) {
                s.push(p);
                res.push_back(p-&gt;val);
                p = p-&gt;left;
            } else {
                TreeNode *t = s.top(); s.pop();
                p = t-&gt;right;
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_94 middle</li>
</ul>
<pre><code class="language-C++">Given a binary tree, return the  inorder  traversal of its nodes' values.
Example:
Input: [1,null,2,3]
   1
    \
     2
    /
   3
Output: [1,3,2]

class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (!s.empty() || p) {
            if (p) {
                s.push(p);
                p = p-&gt;left;
            } else {
               TreeNode* t = s.top(); s.pop();
                res.push_back(t-&gt;val);
                p = t-&gt;right;
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_145</li>
</ul>
<pre><code class="language-C++">Given a binary tree, return the postorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [3,2,1].

class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (!s.empty() || p) {
            if (p) {
                s.push(p);
                res.insert(res.begin(), p-&gt;val);
                p = p-&gt;right;
            } else {
                TreeNode *t = s.top(); s.pop();
                p = t-&gt;left;
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_341</li>
</ul>
<pre><code class="language-C++">class NestedIterator {
public:
    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) {
        for (int i = nestedList.size() - 1; i &gt;= 0; --i) {
            s.push(nestedList[i]);
        }
    }

    int next() {
        NestedInteger t = s.top(); s.pop();
        return t.getInteger();
    }

    bool hasNext() {
        while (!s.empty()) {
            NestedInteger t = s.top(); 
            if (t.isInteger()) return true;
            s.pop();
            for (int i = t.getList().size() - 1; i &gt;= 0; --i) {
                s.push(t.getList()[i]);
            }
        }
        return false;
    }  

private:
    stack&lt;NestedInteger&gt; s;
};
</code></pre>
<h4><a id="%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>队列</h4>
<ul>
<li>广度优先遍历</li>
<li>树 层序遍历</li>
<li>图 无权图的最短路径</li>
<li>leet_102</li>
</ul>
<pre><code class="language-plain_text">Given a binary tree, return the  level order  traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        if (!root) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; q{{root}};
        while (!q.empty()) {
            vector&lt;int&gt; oneLevel;
            for (int i = q.size(); i &gt; 0; --i) {
                TreeNode *t = q.front(); q.pop();
                oneLevel.push_back(t-&gt;val);
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            res.push_back(oneLevel);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_107</li>
</ul>
<pre><code class="language-C++">For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7 
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode* root) {
        if (!root) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; q{{root}};
        while (!q.empty()) {
            vector&lt;int&gt; oneLevel;
            for (int i = q.size(); i &gt; 0; --i) {
                TreeNode *t = q.front(); q.pop();
                oneLevel.push_back(t-&gt;val);
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            res.insert(res.begin(), oneLevel);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_103</li>
</ul>
<pre><code class="language-C++">For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
        if (!root) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; q{{root}};
        bool leftToRight = true;
        while (!q.empty()) {
            int size = q.size();
            vector&lt;int&gt; oneLevel(size);
            for (int i = 0; i &lt; size; ++i) {
                TreeNode *t = q.front(); q.pop();
                int idx = leftToRight ? i : (size - 1 - i);
                oneLevel[idx] = t-&gt;val;
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            leftToRight = !leftToRight;
            res.push_back(oneLevel);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_199</li>
</ul>
<pre><code class="language-C++">Given a binary tree, imagine yourself standing on the  right  side of it, return the values of the nodes you can see ordered from top to bottom.

For example:
Given the following binary tree,

   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---

class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode *root) {
        vector&lt;int&gt; res;
        if (!root) return res;
        queue&lt;TreeNode*&gt; q{{root}};
        while (!q.empty()) {
            res.push_back(q.back()-&gt;val);
            int size = q.size();
            for (int i = 0; i &lt; size; ++i) {
                TreeNode *node = q.front();
                q.pop();
                if (node-&gt;left) q.push(node-&gt;left);
                if (node-&gt;right) q.push(node-&gt;right);
            }
        }
        return res;
    }
};
</code></pre>
<h4><a id="bfs" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>BFS</h4>
<ul>
<li>leet_279</li>
</ul>
<pre><code class="language-C++">Given a positive integer  n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to  n.

Example 1:

Input: _n_ = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.

class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i &lt;= n; ++i) {
            for (int j = 1; i + j * j &lt;= n; ++j) {
                dp[i + j * j] = min(dp[i + j * j], dp[i] + 1);
            }
        }
        return dp.back();
    }
};

class Solution {
public:
    int numSquares(int n) {
        
      int ret;
      assert(n &gt; 0);
      vector&lt;bool&gt; visited(n+1, false);
      visited[n] = true;
      queue&lt;pair&lt;int, int&gt;&gt; q;

      q.push(make_pair(n, 0));

      while (!q.empty()) {
        int num = q.front().first;
        int step = q.front().second;
        q.pop();

        for (int i = 1; ; i++) {
          int a = num - i * i;

          if (a &lt; 0) break;

          if (a == 0) return ret = step + 1;

          if (!visited[a]) {
            visited[a] = true;
            q.push(make_pair(a, step + 1));
          }
        }
      }
      return ret;
    }
};

</code></pre>
<ul>
<li>leet_127</li>
</ul>
<pre><code class="language-C++">Input:
beginWord = &quot;hit&quot;,
endWord = &quot;cog&quot;,
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]

Output: 5

Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,
return its length 5.
class Solution {
  public:
  int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {
    unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());
    if (!wordSet.count(endWord)) return 0;
    queue&lt;string&gt; q{{beginWord}};
    int res = 0;
    while (!q.empty()) {
      for (int k = q.size(); k &gt; 0; --k) {
        string word = q.front(); q.pop();
        if (word == endWord) return res + 1;
        for (int i = 0; i &lt; word.size(); ++i) {
          string newWord = word;
          for (char ch = 'a'; ch &lt;= 'z'; ++ch) {
            newWord[i] = ch;
            if (wordSet.count(newWord) &amp;&amp; newWord != word) {
              q.push(newWord);
              wordSet.erase(newWord);
            }   
          }
        }
      }
      ++res;
    }
    return 0;
  }
};
</code></pre>
<ul>
<li>leet_126</li>
</ul>
<h4><a id="%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优先级队列</h4>
<ul>
<li>底层实现,堆</li>
<li>堆的底层实现, 白板编程</li>
<li>priority_queue</li>
<li>leet_347 O(nlog(n-k)) O(nlog(n-k))</li>
</ul>
<pre><code class="language-C++">Given a non-empty array of integers, return the  k  most frequent elements.

Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
class Solution {
public:
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; m;
        priority_queue&lt;pair&lt;int, int&gt;&gt; q;
        vector&lt;int&gt; res;
        for (auto a : nums) ++m[a];
        for (auto it : m) q.push({it.second, it.first});
        for (int i = 0; i &lt; k; ++i) {
            res.push_back(q.top().second); q.pop();
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_23</li>
</ul>
<pre><code class="language-C++">Merge  k  sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
class Solution {
  public:
  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode node(0), *p = &amp;node;

    while (l1 &amp;&amp; l2) {
      if (l1-&gt;val &lt; l2-&gt;val) {
        p-&gt;next = l1;
        l1 = l1-&gt;next;
      } else {
        p-&gt;next = l2;
        l2 = l2-&gt;next;
      }
      p = p-&gt;next;
    }

    p-&gt;next = l1 ? l1 : l2;
    return node.next;
  }
  
  ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {

    if (lists.empty()) return nullptr;
    
    while (lists.size() &gt; 1) {
      lists.push_back(mergeTwoLists(lists[0], lists[1]));
      lists.erase(lists.begin());
      lists.erase(lists.begin());
    }
    
    return lists[0];
  }
};
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-07-23T08:04:46+08:00" itemprop="datePublished">2019/07/23 08:04 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15638402863944.html" itemprop="url">
		算法面试本质</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%9C%AC%E8%B4%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>本质</h4>
<ul>
<li>不代表能够“正确”回答每一个算法问题，但是合理的思考方向其实更重要</li>
<li>正确完成算法面试问题的前提算法面试优秀不意味着技术面试优秀</li>
<li>技术面试优秀不意味着能够拿到Offer</li>
</ul>
<h4><a id="%E7%BB%99%E5%87%BA%E5%90%88%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>给出合理的思考路径</h4>
<ul>
<li>展示出思考问题的方式</li>
<li>和面试官一起探讨一个问题的解决方案</li>
<li>问题的细节和应用环境</li>
<li>沟通本身很重要，暗示思考问题的方式</li>
</ul>
<h4><a id="%E5%AF%B9%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对一组数据进行排序</h4>
<ul>
<li>这组数据的具体的特征</li>
<li>是否包含大量重复的元素</li>
<li>三路快排是更好的选择</li>
<li>是否大部分数据距离离他正确的位置很近？是否近乎排序
<ul>
<li>插入排序</li>
</ul>
</li>
<li>取值范围非常有限，比如对学生成绩排序
<ul>
<li>计数排序</li>
</ul>
</li>
<li>额外排序</li>
<li>稳定排序</li>
<li>归并排序</li>
<li>数据的存储状况是怎样的
<ul>
<li>链标存储</li>
<li>是否可以装载在内存中</li>
</ul>
</li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_8.html">Prev</a>  
	 <a class="next" href="all_10.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>