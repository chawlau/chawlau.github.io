<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Redis核心技术与实战 -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2021-02-01T08:32:49+08:00" itemprop="datePublished">2021/02/01 08:32 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16121395690770.html" itemprop="url">
		脑裂现象处理</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置参数</h4>
<ul>
<li>min-slaves-to-write</li>
<li>min-slaves-max-lag</li>
</ul>
<h4><a id="%E8%84%91%E8%A3%82%E7%8E%B0%E8%B1%A1%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脑裂现象原因</h4>
<ul>
<li>主库自身遇到了阻塞的情况，阻塞恢复后，又能正常处理请求了</li>
<li>和主库部署在同一台服务器上的其他程序临时占用了大量资源</li>
</ul>
<h4><a id="%E9%98%B2%E6%AD%A2%E8%84%91%E8%A3%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>防止脑裂</h4>
<ul>
<li>如果有一半以上的从库和主库进行的 ACK 消息延迟超过十几秒，我们就禁止主库接收客户端写请求</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2020-12-21T09:28:53+08:00" itemprop="datePublished">2020/12/21 09:28 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16085141335147.html" itemprop="url">
		Redis常见慢操作</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>底层数据结构</h4>
<ul>
<li><img src="media/16085141335147/16085967314381.jpg" alt="" /></li>
<li>简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</li>
</ul>
<h4><a id="%E9%94%AE%E5%80%BC%E5%AF%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>键值对</h4>
<ul>
<li>通过哈希表来保存</li>
<li><img src="media/16085141335147/16085968041600.jpg" alt="" /></li>
<li>哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值</li>
</ul>
<h4><a id="%E5%93%88%E5%B8%8C%E8%A1%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>哈希表冲突问题</h4>
<ul>
<li>链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接</li>
</ul>
<h4><a id="rehash%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>rehash问题</h4>
<ul>
<li>哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间，元素逐渐增多的时候</li>
<li>给哈希表2分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>
<li>释放哈希表 1 的空间。</li>
<li>渐进式 rehash</li>
<li>拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中</li>
<li>分摊拷贝开销</li>
<li><img src="media/16085141335147/16085972010739.jpg" alt="" /></li>
</ul>
<h4><a id="%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>压缩列表</h4>
<ul>
<li>压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束</li>
<li><img src="media/16085141335147/16085970788054.jpg" alt="" /></li>
<li>第一个和最后一个元素都是O(1), 其他元素复杂度就是O(N)</li>
</ul>
<h4><a id="%E8%B7%B3%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>跳表</h4>
<ul>
<li>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</li>
<li><img src="media/16085141335147/16085971797722.jpg" alt="" /></li>
</ul>
<h4><a id="%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>问题</h4>
<ul>
<li>整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？</li>
<li>内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率</li>
<li>数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2020-12-22T08:46:07+08:00" itemprop="datePublished">2020/12/22 08:46 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16085979678275.html" itemprop="url">
		高性能IO模型</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="redisio%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RedisIO模型</h4>
<ul>
<li><img src="media/16085979678275/16085981742683.jpg" alt="" /></li>
</ul>
<h4><a id="%E6%BD%9C%E5%9C%A8%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>潜在性能瓶颈</h4>
<p>1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：<br />
a、操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；<br />
b、使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；<br />
c、大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；<br />
d、淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；<br />
e、AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；<br />
f、主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；<br />
2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2021-01-26T09:16:19+08:00" itemprop="datePublished">2021/01/26 09:16 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16116237791062.html" itemprop="url">
		无锁的原子操作</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原子操作</h4>
<ul>
<li>INCR/DECR命令</li>
<li>lua脚本EVAL</li>
<li>redis-cli  --eval lua.script  keys , args</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2021-01-26T08:48:02+08:00" itemprop="datePublished">2021/01/26 08:48 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16116220823492.html" itemprop="url">
		Pika</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%A4%A7%E5%86%85%E5%AD%98redis%E5%AE%9E%E4%BE%8B%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>大内存 Redis 实例问题</h4>
<ul>
<li>内存快照 RDB 生成和恢复效率低</li>
<li>主从节点全量同步时长增加、缓冲区易溢出</li>
</ul>
<h4><a id="%E6%8F%90%E5%8D%87%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E8%83%BD%E5%8A%9B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>提升并发读写能力</h4>
<ul>
<li>利用 Pika 的多线程模型，增加线程数量，提升 Pika 的并发请求处理能力</li>
<li>为 Pika 配置高配的 SSD，提升 SSD 自身的访问性能</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2021-01-22T08:43:20+08:00" itemprop="datePublished">2021/01/22 08:43 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16112762009155.html" itemprop="url">
		缓存淘汰策略</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E9%95%BF%E5%B0%BE%E6%95%88%E5%BA%94%E5%92%8C%E9%87%8D%E5%B0%BE%E6%95%88%E5%BA%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>长尾效应和重尾效应</h4>
<ul>
<li>这80%的数据在访问量上就形成了一条长长的尾巴，我们也称为“长尾效应”</li>
<li>20%的数据可能贡献不了80%的访问，而剩余的 80% 数据反而贡献了更多的访问量，我们称之为重尾效应。</li>
</ul>
<h4><a id="%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>淘汰策略</h4>
<ul>
<li>在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis  4.0 后新增）四种</li>
<li>在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）三种</li>
<li><img src="media/16112762009155/16112764776353.jpg" alt="" /></li>
</ul>
<h4><a id="%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>淘汰算法</h4>
<ul>
<li>volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru 会使用 LRU 算法筛选设置了过期时间的键值对。</li>
<li>volatile-lfu 会使用 LFU 算法选择设置了过期时间的键值对</li>
<li>allkeys-random 策略，从所有键值对中随机选择并删除数据；</li>
<li>allkeys-lru 策略，使用 LRU 算法在所有数据中进行筛选。</li>
<li>allkeys-lfu 策略，使用 LFU 算法在所有数据中进行筛选</li>
</ul>
<h4><a id="lru%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LRU算法</h4>
<ul>
<li>Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录</li>
<li>第一次会随机选出 N 个数据，把它们作为一个候选集合</li>
<li>Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去</li>
<li>CONFIG SET maxmemory-samples 100</li>
<li>Redis 需要挑选数据进入第一次淘汰时创建的候选集合</li>
<li>如果候选数据集中的数据个数达到了 maxmemory-samples，Redis 就把候选数据集中 lru 字段值最小的数据淘汰出去</li>
</ul>
<h4><a id="%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>推荐使用</h4>
<ul>
<li>优先使用 allkeys-lru 策略</li>
<li>如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行</li>
<li>如果你的业务中有置顶的需求，volatile-lru，不设置过期时间</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2021-01-22T09:09:21+08:00" itemprop="datePublished">2021/01/22 09:09 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16112777615683.html" itemprop="url">
		缓存和数据库数据不一致问题</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重试机制</h4>
<ul>
<li>可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新</li>
</ul>
<h4><a id="%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>先删除缓存，再更新数据库</h4>
<ul>
<li>延迟双删</li>
</ul>
<pre><code class="language-plain_text">redis.delKey(X)
db.update(X)
Thread.sleep(N)
redis.delKey(X)
</code></pre>
<h4><a id="%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%80%BC%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>先更新数据库值，再删除缓存值</h4>
<ul>
<li>删除缓存值或更新数据库失败而导致数据不一致，你可以使用重试机制确保删除或更新操作成功</li>
</ul>
<h4><a id="%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缓存异常三个问题</h4>
<ul>
<li>缓存雪崩、缓存击穿和缓存穿透</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2021-01-18T09:38:07+08:00" itemprop="datePublished">2021/01/18 09:38 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16109338878979.html" itemprop="url">
		redis变慢</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原因</h4>
<ul>
<li>慢查询</li>
<li>是否对过期 key 设置了相同的过期时间</li>
<li>是否存在 bigkey</li>
<li>Redis AOF 配置级别是什么  避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加</li>
<li>Redis 实例的内存使用是否过大？发生 swap 了吗</li>
<li>在 Redis 实例的运行环境中，是否启用了透明大页机制</li>
<li>是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上</li>
<li>是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2021-01-11T08:39:36+08:00" itemprop="datePublished">2021/01/11 08:39 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98.html'>Redis核心技术与实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16103255763973.html" itemprop="url">
		异步机制</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E9%98%BB%E5%A1%9E%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>阻塞点</h4>
<ul>
<li>客户端：网络 IO，键值对增删改查操作，数据库操作；</li>
<li>磁盘：生成 RDB 快照，记录 AOF 日志，AOF 日志重写；</li>
<li>主从节点：主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件；</li>
<li>切片集群实例：向其他实例传输哈希槽信息，数据迁移<br />
<img src="media/16103255763973/16103257557946.jpg" alt="" /></li>
</ul>
<h4><a id="%E5%AE%A2%E6%88%B7%E7%AB%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>客户端</h4>
<ul>
<li>集合全量查询和聚合操作</li>
<li>bigkey 删除操作就是 Redis 的第二个阻塞点</li>
<li>清空数据库 flushdb&amp;flushall</li>
</ul>
<h4><a id="%E5%92%8C%E7%A3%81%E7%9B%98%E4%BA%A4%E4%BA%92%E6%97%B6%E7%9A%84%E9%98%BB%E5%A1%9E%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>和磁盘交互时的阻塞点</h4>
<ul>
<li>AOF日志同步写</li>
<li>加载 RDB 文件</li>
</ul>
<h4><a id="%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E5%AE%9E%E4%BE%8B%E4%BA%A4%E4%BA%92%E6%97%B6%E7%9A%84%E9%98%BB%E5%A1%9E%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>切片集群实例交互时的阻塞点</h4>
<ul>
<li>使用了 Redis Cluster 方案，而且同时正好迁移的是 bigkey 的话，就会造成主线程的阻塞，因为 Redis Cluster 使用了同步迁移</li>
</ul>
<h4><a id="%E5%88%A0%E9%99%A4%E5%92%8C%E6%B8%85%E7%A9%BA%E6%96%B0%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删除和清空新命令</h4>
<ul>
<li>UNLINK</li>
<li>FLUSHDB ASYNC</li>
<li>FLUSHALL ASYNC</li>
<li></li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="Redis核心技术与实战.html">Prev</a>  
	 <a class="next" href="Redis核心技术与实战_2.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>