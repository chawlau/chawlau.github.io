<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	       凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-10-03T18:35:06+08:00" itemprop="datePublished">2019/10/03 18:35 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15700989065972.html" itemprop="url">
		lambda</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>特点</h4>
<ul>
<li>是个匿名函数, 可调用的代码单元</li>
<li>返回类型可以自动推导，可以省略</li>
<li>没有参数的时候()可以省略·</li>
</ul>
<pre><code class="language-C++">auto f = [](int a)-&gt;int {
    return a + 1;
  };

  auto f1 = [](int a) {
    return a + 1;
  };

  auto f2 = [] {return  2;};
</code></pre>
<h4><a id="%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>捕获列表</h4>
<ul>
<li>捕获一定范围内的变量</li>
<li>lambda可以捕获局部静态变量</li>
</ul>
<pre><code class="language-C++">  static int i = 9;
  auto f3 = [] {
    return i;
  };

</code></pre>
<ul>
<li>[&amp;] 捕获所有外部变量</li>
</ul>
<pre><code class="language-C++">  int j = 9;
  auto f4 = [&amp;] {
    j = 10;
  };
  f4();
</code></pre>
<ul>
<li>[=] 值使用，只能用，不能修改</li>
</ul>
<pre><code class="language-C++">auto f5 = [=] {
    cout &lt;&lt; &quot;j &quot; &lt;&lt; j &lt;&lt; endl;
  };
  f5();

</code></pre>
<ul>
<li>[this] 用于类中，拥有和成员函数一样的权限</li>
<li>[变量名] 表示按值捕获，同时不捕获其他变量，按值分隔</li>
</ul>
<pre><code class="language-C++">class CT {
 public:
  int m_i = 5;
  void func(int x, int y) {
    //auto ld = [this] {
    //auto ld = [this, x, y] {
    auto ld = [this, &amp;x, &amp;y] {
      x = 5;
      y = 2;
      return m_i;
    };
  }
};
</code></pre>
<ul>
<li>[=,&amp;变量名] 按值捕获所有变量, 但按引用捕获&amp;中所指的变量，第一个都是默认捕获，隐式捕获方式，其他的是显式捕获，后面的引用方式是相反的[&amp;,x]</li>
</ul>
<pre><code class="language-C++"> int x = 2, y = 3;
  auto f6 = [=, &amp;x, &amp;y] {
    cout &lt;&lt; &quot;j &quot; &lt;&lt; j &lt;&lt; endl;
  };
  f6();

  auto f7 = [&amp;, x, y] {
    cout &lt;&lt; &quot;j &quot; &lt;&lt; j &lt;&lt; endl;
  };
  f6();
</code></pre>
<h4><a id="lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8%E6%98%93%E5%87%BA%E9%94%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lambda表达式延迟调用易出错</h4>
<pre><code class="language-C++">  int x1 = 5;
  auto f8 = [=] {
    return x1;
  };
  x1 = 10;
  cout &lt;&lt; f8() &lt;&lt; endl;//5
</code></pre>
<ul>
<li>lamda表达式引用外部变量的那一刻，复制了一份存储在表达式中</li>
<li>如果采用引用，就不会出错</li>
</ul>
<pre><code class="language-C++"> int x1 = 5;
  auto f8 = [&amp;] {
    return x1;
  };
  x1 = 10;
  cout &lt;&lt; f8() &lt;&lt; endl;//5
</code></pre>
<h4><a id="mutable" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mutable</h4>
<pre><code class="language-C++">  int x2 = 5;
  auto f9 = [=]() mutable {
    x2 = 7;
    return x2;
  };
  cout &lt;&lt; f9() &lt;&lt; endl;
</code></pre>
<ul>
<li>可以修改按值捕获的变量</li>
</ul>
<h4><a id="%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%98%E5%82%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>表达式类型和存储</h4>
<ul>
<li>Closure Type</li>
<li>闭包 函数内的函数，本质就是lambda表达式创建时运行时间对象</li>
<li>闭包类的类型的对象，可以认为是带有operator()的类型的对象</li>
</ul>
<pre><code class="language-C++">int x = 5;
auto f = [&amp;] {
  return x;
}

function&lt;int(int)&gt; fc1 = [](int t) {return  t;};
  cout &lt;&lt; fc1(15) &lt;&lt; endl;
function&lt;int(int)&gt; fc2 = bind(
      [](int t) {
      return t;
      },
      16
      );
</code></pre>
<h4><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h4>
<pre><code class="language-C++">  vector&lt;int&gt; vec = {10,20,30,40,50};
  int sum = 0;
  for_each (vec.begin(), vec.end(), [&amp;sum](int val) {
            sum += val;
            cout &lt;&lt; val &lt;&lt; endl;
            });
  cout &lt;&lt; &quot; sum &quot; &lt;&lt; sum &lt;&lt; endl;

  find_if (vec.begin(), vec.end(), [](int val) {
           cout &lt;&lt; val &lt;&lt; endl;
           if (val &gt; 15)
              return true;
           return false;
           });
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2020-02-11T08:32:53+08:00" itemprop="datePublished">2020/02/11 08:32 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15813811739408.html" itemprop="url">
		tuple 使用</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%B1%BB%E6%A8%A1%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类模板</h4>
<ul>
<li>类模板 std::tuple 是固定大小的异类值汇集。它是 std::pair 的推广。</li>
</ul>
<h4><a id="%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用</h4>
<pre><code class="language-C++">#include &lt;tuple&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
 
std::tuple&lt;double, char, std::string&gt; get_student(int id)
{
    if (id == 0) return std::make_tuple(3.8, 'A', &quot;Lisa Simpson&quot;);
    if (id == 1) return std::make_tuple(2.9, 'C', &quot;Milhouse Van Houten&quot;);
    if (id == 2) return std::make_tuple(1.7, 'D', &quot;Ralph Wiggum&quot;);
    throw std::invalid_argument(&quot;id&quot;);
}
 
int main()
{
    auto student0 = get_student(0);
    std::cout &lt;&lt; &quot;ID: 0, &quot;
              &lt;&lt; &quot;GPA: &quot; &lt;&lt; std::get&lt;0&gt;(student0) &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;grade: &quot; &lt;&lt; std::get&lt;1&gt;(student0) &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;name: &quot; &lt;&lt; std::get&lt;2&gt;(student0) &lt;&lt; '\n';
 
    double gpa1;
    char grade1;
    std::string name1;
    std::tie(gpa1, grade1, name1) = get_student(1);
    std::cout &lt;&lt; &quot;ID: 1, &quot;
              &lt;&lt; &quot;GPA: &quot; &lt;&lt; gpa1 &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;grade: &quot; &lt;&lt; grade1 &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;name: &quot; &lt;&lt; name1 &lt;&lt; '\n';
 
    // C++17 结构化绑定：
    auto [ gpa2, grade2, name2 ] = get_student(2);
    std::cout &lt;&lt; &quot;ID: 2, &quot;
              &lt;&lt; &quot;GPA: &quot; &lt;&lt; gpa2 &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;grade: &quot; &lt;&lt; grade2 &lt;&lt; &quot;, &quot;
              &lt;&lt; &quot;name: &quot; &lt;&lt; name2 &lt;&lt; '\n';
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-06-09T10:20:05+08:00" itemprop="datePublished">2019/06/09 10:20 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html'>程序员的自我修养</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15600468057572.html" itemprop="url">
		可执行文件的装载和进程</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BB%BA%E7%AB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程的建立</h4>
<ul>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li>
<li>将cpu的指令寄存器的设置成可执行的文件的入口地址, ELF文件头的入口地址</li>
</ul>
<h4><a id="%E9%A1%B5%E9%94%99%E8%AF%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>页错误</h4>
<ul>
<li><img src="media/15600468057572/15600478741302.jpg" alt="" style="width:534px;" /></li>
</ul>
<h4><a id="elf%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5%E8%A7%86%E5%9B%BE%E5%92%8C%E6%89%A7%E8%A1%8C%E8%A7%86%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ELF文件链接视图和执行视图</h4>
<ul>
<li>Section是从链接视图划分ELF</li>
<li>Segment是从执行视图划分ELF</li>
<li>相同属性的Section会被归类到一个segment，映射到同一个VMA</li>
</ul>
<h4><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h4>
<ul>
<li>操作系统通过给进程空间划分为一个一个VMA来管理进程虚拟空间，依据原则是相同权限属性和相同映像文件映射成一个VMA</li>
</ul>
<h4><a id="%E8%A3%85%E8%BD%BD%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>装载过程</h4>
<ul>
<li>load_elf_binary</li>
<li>load_script</li>
</ul>
<h4><a id="%E8%A3%85%E8%BD%BD%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>装载过程</h4>
<ul>
<li>检查ELF可执行文件格式的有效性，比如魔数、程序头表中段<br />
(Segment)的数量。</li>
<li>寻找动态链技的.interp段，设置动态链接器路径(与动态链接有关，具体<br />
只读数据。</li>
<li>根据ELF文件的程序表头的描述，对ELF文件进行映射，代码，数据，只读数据</li>
<li>初始化ELF文件进程环境</li>
<li>将系统调用的返回地址修改成对于静态链接的ELF可执行文件的入口点，对于动态链接的<br />
ELF可执行文件，这个程序入口就是动态连接器</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-16T18:05:43+08:00" itemprop="datePublished">2019/08/16 18:05 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15659499432841.html" itemprop="url">
		inline const mutable this staic</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%B3%A8%E6%84%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意</h4>
<ul>
<li>成员函数可以访问成员变量，不管成员是否私有</li>
</ul>
<h4><a id="inline" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>inline</h4>
<ul>
<li>类中直接实现的成员函数，会被当成inline来处理，是否会处理成功取决于编译器自身</li>
</ul>
<h4><a id="const" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>const</h4>
<ul>
<li>成员函数后面增加const,声明和定义都需要加const</li>
<li>不会修改对象里任何成员变量的值</li>
<li>常量成员函数</li>
<li>const只能给成员函数使用</li>
</ul>
<h4><a id="mutable" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mutable</h4>
<ul>
<li>不稳定，易改变</li>
<li>为了突破const的限制</li>
<li>mutable表示成员变量永远处于被修改状态</li>
</ul>
<h4><a id="%E8%BF%94%E5%9B%9E%E8%87%AA%E8%BA%AB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>返回自身对象的引用</h4>
<ul>
<li>this Time const* this</li>
</ul>
<h4><a id="%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态变量</h4>
<ul>
<li>局部静态变量</li>
<li>static保证只能在本文件中使用</li>
<li>静态成员变量属于类本身</li>
<li>静态成员变量，一般在一个.cpp源文件开头来定义这个成员变量</li>
</ul>
<h4><a id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>析构函数</h4>
<ul>
<li>函数体是销毁new出来的东西</li>
<li>函数体之后系统接管和销毁</li>
</ul>
<h4><a id="%E5%87%BD%E6%95%B0%E5%B1%8F%E8%94%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数屏蔽</h4>
<ul>
<li>子类中有父类的同名函数，父类同名函数会被屏蔽</li>
<li>访问父类同名函数 using 让父类函数以重载方式执行，所有同名函数都可以见了</li>
</ul>
<h4><a id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>析构函数写成虚函数</h4>
<ul>
<li>父类子针new子类的对象，delete的时候不会调用派生类的析构函数</li>
<li>父类的析构函数写成虚函数，delete base会根据动态类型来执行析构函数</li>
<li>父类对非继承的成员进行操作，需要把基类的函数定义为虚函数，析构函数的定义的虚属性会被继承给子类，这样子类中的析构函数也自然成为虚函数，虽然名字和基类的不同</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-30T18:28:11+08:00" itemprop="datePublished">2019/08/30 18:28 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15671608919349.html" itemprop="url">
		智能指针</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分配</h4>
<ul>
<li>auto ptr =  new auto(obj)</li>
<li>智能指针能够帮助delete</li>
</ul>
<h4><a id="new-delete" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>new&amp;&amp;delete</h4>
<ul>
<li>new 如何记录分配的内存给delete使用，new内部有记录机制</li>
</ul>
<h4><a id="%E7%94%B3%E8%AF%B7%E5%92%8Cdelete%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>申请和delete数组</h4>
<ul>
<li>多出来的4个字节针对数组元素来记录、</li>
<li>内置类型不需要记录</li>
</ul>
<h4><a id="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>智能指针</h4>
<ul>
<li>auto_ptr 被unique_ptr替代</li>
<li>unique_ptr 独占式ptr，同一个时间只有一个指针指向对象，所有权可以移交出去</li>
<li>shared_ptr 共享式指针，多个指针指向同一个对象</li>
<li>weak_ptr 辅助shared_ptr</li>
</ul>
<h4><a id="shared-ptr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shared_ptr</h4>
<ul>
<li>释放对象</li>
<li>shared_ptr被析构的时候</li>
<li>shared_ptr指向其他的对象的时候</li>
<li>不要用裸指针初始化shared_ptr</li>
</ul>
<h4><a id="make-shared%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%AE%89%E5%85%A8%E9%AB%98%E6%95%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>make_shared 函数模型，安全高效</h4>
<ul>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-15T18:26:04+08:00" itemprop="datePublished">2019/09/15 18:26 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15685431648523.html" itemprop="url">
		互斥量用法&死锁</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%BA%92%E6%96%A5%E9%87%8F%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>互斥量使用</h4>
<ul>
<li>lock</li>
<li>unlock</li>
<li>std::lock_guard</li>
<li>std::lock_guard<a href="std::mutex">std::mutex</a> sg(my_mutex);</li>
<li>必须在析构的时候解锁，不够灵活加{}提前析构</li>
</ul>
<h4><a id="%E6%AD%BB%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>死锁</h4>
<ul>
<li>至少两把锁</li>
<li>解决方案</li>
<li>保证互斥量上锁的顺序一致</li>
</ul>
<h4><a id="std-lock%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>std::lock函数模版</h4>
<ul>
<li>一次锁住两或者两个以上的互斥量，至少两个</li>
<li>不存在因为多个线程中，因为锁的顺序问题导致死锁的风险问题</li>
<li>如果互斥量一个没锁住，就等待，只有等所有互斥量都锁住，才能往下走</li>
<li>要么都锁住，要么都没锁住，如果只锁了一个，另外没锁成功，则立即把已经锁住的解锁</li>
<li>建议一个一个锁</li>
</ul>
<pre><code class="language-plain_text">std::lock(mutex1, mutex2);
mutex1.unlock();
mutex2.unlock();
</code></pre>
<h4><a id="std-lock-guard" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>std::lock_guard&amp;</h4>
<pre><code class="language-plain_text">std::lock(mutex1, mutex2);
std::lock_guard&lt;std::mutex&gt; s1(mutex1, std::adopt_lock);
std::lock_guard&lt;std::mutex&gt; s2(mutex2, std::adopt_lock);
</code></pre>
<ul>
<li>std::adopt_lock表示互斥量已经lock过了</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-25T19:45:10+08:00" itemprop="datePublished">2019/09/25 19:45 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15694119108197.html" itemprop="url">
		多线程补充知识</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<ul>
<li>补充</li>
</ul>
<h4><a id="%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>虚假唤醒</h4>
<ul>
<li>wait中需要有第二个参数</li>
<li>这个lambda要正确判断要处理的公共数据是否存在</li>
</ul>
<pre><code class="language-plain_text">cond.wait(s1, [this]{
                  if (!msgRecvQueue.empty())
                     return true;
                  return false;
                });
</code></pre>
<h4><a id="atomic" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>atomic</h4>
<ul>
<li>线程数目控制在200个，尽量不要超过500</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-28T18:32:17+08:00" itemprop="datePublished">2019/09/28 18:32 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html'>C++基础与提高</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15696667375372.html" itemprop="url">
		引用折叠&转发&完美转发&forward</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引用折叠</h4>
<pre><code class="language-C++">template&lt;typename T&gt;
void func(T &amp;&amp;tmp)

int main(){
  int i = 18;
  func(i); //i左值 T int&amp; tmp int&amp;
  func(100);//i 右值  T int tmp int&amp;&amp;
  void func(int&amp; &amp;&amp;tmp) {} 
  void func(int&amp; tmp) {} //编译器展现出来的
}
</code></pre>
<ul>
<li>引用折叠</li>
<li>左值引用&amp;, 右值引用&amp;&amp;</li>
<li>T是第一组左值引用， &amp;&amp;tmp第二组右值引用</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center">第一组</th>
<th style="text-align: center">第二组</th>
<th style="text-align: center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">&amp;左值引用</td>
<td style="text-align: center">&amp;左值引用</td>
<td style="text-align: center">&amp;左值引用</td>
</tr>
<tr>
<td style="text-align: center">&amp;左值引用</td>
<td style="text-align: center">&amp;&amp;右值引用</td>
<td style="text-align: center">&amp;左值引用</td>
</tr>
<tr>
<td style="text-align: center">&amp;&amp;右值引用</td>
<td style="text-align: center">&amp;左值引用</td>
<td style="text-align: center">&amp;左值引用</td>
</tr>
<tr>
<td style="text-align: center">&amp;&amp;右值引用</td>
<td style="text-align: center">&amp;&amp;右值引用</td>
<td style="text-align: center">&amp;&amp;右值引用</td>
</tr>
</tbody>
</table>
<ul>
<li>折叠规则，只要有任意一个引用为左值引用，结果就是左值引用，否则就是右值引用</li>
</ul>
<h4><a id="%E5%BC%95%E7%94%A8%E7%9A%84%E5%BC%95%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引用的引用</h4>
<pre><code class="language-C++">int b = 500;
int &amp;rb = b;
int &amp; &amp;rrb = b; //引用的引用，两个&amp;之间有空格
</code></pre>
<ul>
<li>引用的引用是非法的</li>
<li>编译器内部推断</li>
</ul>
<h4><a id="%E8%BD%AC%E5%8F%91%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>转发和完美转发</h4>
<ul>
<li>函数模版把收到的参数以及这些参数的类型转发给其他函数</li>
</ul>
<pre><code class="language-C++">void func2(int t1, int&amp; t2) {
  cout &lt;&lt; &quot; t1 + t2 &quot; &lt;&lt; t1 + t2 &lt;&lt; endl;
  t2++;
}
template&lt;typename F, typename T1, typename T2&gt;
void func(F f, T1 t1, T2&amp;&amp; t2) {
  f(t1, t2)
}
</code></pre>
<ul>
<li>要保持t2的引用属性，T2改成万能引用T2&amp;&amp;，可以推导所有的实参类型</li>
<li>T2改成T2&amp;不能保留左值或者右值属性</li>
</ul>
<pre><code class="language-C++"> int&amp;&amp; rval = 80;//右值引用必须要绑定右值, &amp;&amp;rval是右值引用,但是rval本身是个左值
  func3(rval, j);//err
  func3(80, j);//right
</code></pre>
<h4><a id="%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>完美转发</h4>
<pre><code class="language-C++">void func3(int&amp;&amp; t1, int&amp; t2) {
  cout &lt;&lt; &quot; t1 + t2 &quot; &lt;&lt; t1 + t2 &lt;&lt; endl;
  t2++;
}

template&lt;typename F, typename T1, typename T2&gt;
void func(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) { //t1是左值, 形参都是左值
   f(forward&lt;T1&gt;(t1), forward&lt;T2&gt;(t2));
}

int main() {
  int i = 20, j = 30;
  func(func2, i, j);
  func3(70, j);
  cout &lt;&lt; &quot; j &quot; &lt;&lt; j &lt;&lt; endl;

  int&amp;&amp; rval = 80;//右值引用必须要绑定右值, &amp;&amp;rval是右值引用,但是rval本身是个左值
  //func3(rval, j);
  func(func3, 80, j);
}
</code></pre>
<ul>
<li>接受任意实参的函数模板</li>
<li>目标函数会接收到与转发函数所收到的完全相同</li>
<li>std::forward</li>
<li>发挥作用的条件</li>
<li>调用模板函数，模板函数参数是万能引用类型，模版函数负责转发</li>
<li>std::forward的能力就是按照参数本来的类型转发</li>
<li>实参如果原来是左值，forward还是按照原来的类型处理</li>
<li>实参如果原来是右值，形参变成了左值，forward会把左值信息还原为右值</li>
<li>万能引用会保存实参的左值右值的信息，</li>
</ul>
<pre><code class="language-C++">void func4(int &amp;t) {
  cout&lt;&lt; &quot;left  value &quot; &lt;&lt; endl;
}

void func4(int &amp;&amp;t) {
  cout&lt;&lt; &quot;right  value &quot; &lt;&lt; endl;
}

template &lt;typename T&gt;
void testF(T&amp;&amp; t) {
  func4(t);
  func4(forward&lt;T&gt;(t));
  func4(move(t));//move是左值转右值。
}
</code></pre>
<ul>
<li>forward是有条件的转发，左值转右值</li>
<li>move无条件强制类型转换成右值</li>
</ul>
<h4><a id="%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>万能引用</h4>
<ul>
<li>可以合并代码，达到简化代码的效果</li>
</ul>
<pre><code class="language-C++">class shape {};
class circle : public shape {};
void foo(const shape&amp;)
{
    puts(&quot;foo(const shape&amp;)&quot;);
}

void foo(shape&amp;&amp;)
{
    puts(&quot;foo(shape&amp;&amp;)&quot;);
}

//void bar(const shape&amp; s)
//{
//    puts(&quot;bar(const shape&amp;)&quot;);
//    foo(s);
//}
//
//void bar(shape&amp;&amp; s)
//{
//    puts(&quot;bar(shape&amp;&amp;)&quot;);
//    foo(move(s));
//}


template &lt;typename T&gt;
void bar(T&amp;&amp; s)
{
    foo(std::forward&lt;T&gt;(s));
}

int main()
{
    circle temp;
    bar(temp);
    bar(circle());
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-12T09:24:24+08:00" itemprop="datePublished">2019/09/12 09:24 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15682514641307.html" itemprop="url">
		贪心算法</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h4>
<ul>
<li>leet_455</li>
<li><img src="media/15682514641307/15682518263627.jpg" alt="" style="width:614px;" /></li>
<li>leet_392</li>
</ul>
<h4><a id="%E8%B4%AA%E5%BF%83%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>贪心和动态规划</h4>
<ul>
<li>leet_435</li>
<li><img src="media/15682514641307/15682540246962.jpg" alt="" style="width:939px;" /></li>
</ul>
<h4><a id="%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>贪心选择性质</h4>
<ul>
<li>如果无法使用贪心算法，举出反例</li>
<li>如何证明贪心算法的正确性</li>
<li></li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_5.html">Prev</a>  
	 <a class="next" href="all_7.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>