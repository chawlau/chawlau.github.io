<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	       凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-12-13T16:30:51+08:00" itemprop="datePublished">2018/12/13 16:30 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15446898518323.html" itemprop="url">
		Mysql表数据删除</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E6%8E%89%E4%B8%80%E5%8D%8A%EF%BC%8C%E8%A1%A8%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%8F%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么表数据删掉一半，表文件大小不变</h4>
<ul>
<li>innodb_file_per_table ON</li>
<li>表数据既可以存在共享表空间里，也可以是单独的文件</li>
<li>innodb_file_per_table off 放在共享表空间中，即使表删掉了空间也是不会回收的</li>
<li>innodb_file_per_table ON 一个表单独存储为一个文件, drop table就可以删除<br />
<img src="media/15446898518323/15576336952657.jpg" alt="" style="width:629px;" /></li>
</ul>
<h4><a id="%E5%A4%8D%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复用</h4>
<ul>
<li>数据页复用和记录的复用</li>
<li>记录复用的条件是插入的新纪录必须满足之前的纪录的主键限制条件</li>
<li>数据页复用则没有条件限制</li>
<li>delete命令只是把纪录的位置或者数据页标记了可复用</li>
<li>没有使用的空间叫空洞<br />
<img src="media/15446898518323/15576337049446.jpg" alt="" style="width:588px;" /></li>
</ul>
<h4><a id="%E6%95%B0%E6%8D%AE%E7%A9%BA%E6%B4%9E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据空洞</h4>
<ul>
<li>不止是删除数据会造成空洞，插入数据也会。</li>
<li>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</li>
</ul>
<h4><a id="%E9%87%8D%E5%BB%BA%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重建表</h4>
<ul>
<li>重建表可以去除数据空洞</li>
<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>
<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；</li>
<li>用临时文件替换表 A 的数据文件。</li>
<li>MDL读锁可以限制DDL修改表结构<br />
<img src="media/15446898518323/15576337131980.jpg" alt="" style="width:538px;" /></li>
</ul>
<h4><a id="online%E5%92%8Cinplace%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Online和inplace本质区别</h4>
<ul>
<li>inplace表示在 innodb引擎完成所有操作,对 server层是透明的。 inplace操作不一定是online的,如MsQL8.0的添加全文索引和空间索引。而 online的一定是 inplace的。</li>
<li>copy 对于不支持online的ddl操作采用copy方式，比如修改列类型，删除主键，修改字符集等，这些操作都会导致记录格式发生变化</li>
</ul>
<h4><a id="online-ddl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Online DDL</h4>
<p><img src="media/15446898518323/15446935517519.jpg" alt="" /><br />
<img src="media/15446898518323/15576343430209.jpg" alt="" style="width:649px;" /></p>
<h4><a id="%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>若干问题</h4>
<ul>
<li>Online Add Index是否支持Unique索引？<br />
确切的答案是：支持，InnoDB支持Online创建Unique索引。<br />
既然支持，就会面临Check Duplicate Key的问题。Row Log中如果存在与索引中相同的键值怎么处理？怎么检测是否存在相同键值？<br />
InnoDB解决此问题的方案也比较简介易懂。其维护了一个row_merge_dup_t的数据结构，存储了在Row log重放过程中遇到的违反唯一性冲突的Row Log。应用完Row Log之后，外部判断是否存在Unique冲突(有多少Unique冲突，均会记录)，Online创建Unique索引失败。</li>
<li>Online与数据一致性如何兼得？<br />
实际上，online ddl并非整个过程都是online，在prepare阶段和commit阶段都会持有MDL-Exclusive锁，禁止读写；而在整个ddl执行阶段，允许读写。由于prepare和commit阶段相对于ddl执行阶段时间特别短，因此基本可以认为是全程online的。Prepare阶段和commit阶段的禁止读写，主要是为了保证数据一致性。Prepare阶段需要生成row_log对象和修改内存的字典；Commit阶段，禁止读写后，重做最后一部分增量，然后提交，保证数据一致。</li>
<li>如何实现server层和innodb层一致性？<br />
在prepare阶段，server层会生成一个临时的frm文件，里面包含了新表的格式；innodb层生成了临时的ibd文件(rebuild方式)；在ddl执行阶段，将数据从原表拷贝到临时ibd文件，并且将row_log增量应用到临时ibd文件；在commit阶段，innodb层修改表的数据字典，然后提交；最后innodb层和mysql层面分别重命名frm和idb文件。</li>
<li>Row Log是什么样的结构，如何组织的？<br />
在Online Add Index过程中，并发DML产生的修改，被记录在Row Log中。首先，Row Log不是InnoDB的Redo Log，而是每个正在被Online创建的索引的独占结构。<br />
Online创建索引，遵循的是先创建索引数据字典，后填充数据的方式。因此，当索引数据字典创建成功之后，新的DML操作就可以读取此索引，尝试进行更新。但是，由于索引结构上的status状态为ONLINE_INDEX_CREATION，因此这些更新不能直接应用到新索引上，而是放入Row Log之中，等待被重放到索引之上。<br />
Row Log中，以Block的方式管理DML操作内容的存放。一个Block的大小为由参数innodb_sort_buffer_size控制，默认大小为1M (1048576)。初始化阶段，Row Log申请两个这样的Block。</li>
</ul>
<h4><a id="%E4%B8%89%E7%A7%8D%E9%87%8D%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三种重建表的方式区别</h4>
<ul>
<li>optimize table（alter table + alter table）</li>
<li>alter table  其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁</li>
<li>alter table 重建表</li>
</ul>
<h4><a id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考资料</h4>
<ul>
<li><a href="https://blog.51cto.com/fengfeng688/1956827">https://blog.51cto.com/fengfeng688/1956827</a></li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-12T09:38:10+08:00" itemprop="datePublished">2019/05/12 09:38 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Linux性能优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15576250906291.html" itemprop="url">
		Swap内存</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%9B%9E%E6%94%B6%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>回收场景</h4>
<ul>
<li>直接内存回收</li>
<li>内核线程回收 kswapd0</li>
</ul>
<h5><a id="%E4%B8%89%E7%A7%8D%E6%B0%B4%E4%BD%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三种水位</h5>
<ul>
<li>页最小阈值（pages_min）</li>
<li>页低阈值（pages_low）</li>
<li>页高阈值（pages_high<br />
<img src="media/15576250906291/c1054f1e71037795c6f290e670b29120.png" alt="c1054f1e71037795c6f290e670b29120" /></li>
</ul>
<h4><a id="numa%E5%92%8Cswap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NUMA和Swap</h4>
<ul>
<li>NUMA 架构下，多个处理器被划分到不同 Node 上，且每个 Node 都拥有自己的本地内存空间。</li>
<li>Node 内部的内存空间，实际上又可以进一步分为不同的内存域（Zone），比如直接内存访问区（DMA）、普通内存区（NORMAL）、伪内存区（MOVABLE）<br />
<img src="media/15576250906291/be6cabdecc2ec98893f67ebd5b9aead9.png" alt="be6cabdecc2ec98893f67ebd5b9aead9" /></li>
</ul>
<h5><a id="%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>回收内存模式</h5>
<ul>
<li>/proc/sys/vm/zone_reclaim_mode</li>
<li>0 可以从其他 Node 寻找空闲内存，也可以从本地回收内存</li>
<li>1、2、4 都表示只回收本地内存，2 表示可以回写脏数据回收内存，4 表示可以用 Swap 方式回收内存</li>
</ul>
<h4><a id="%E6%96%87%E4%BB%B6%E9%A1%B5%E9%9D%A2%E5%92%8C%E5%8C%BF%E5%90%8D%E9%A1%B5%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件页面和匿名页面</h4>
<ul>
<li>对文件页的回收，当然就是直接回收缓存，或者把脏页写回磁盘后再回收。</li>
<li>而对匿名页的回收，其实就是通过 Swap 机制，把它们写入磁盘后再释放内存</li>
</ul>
<h4><a id="%E5%9B%9E%E6%94%B6%E6%AF%94%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>回收比例</h4>
<ul>
<li>/proc/sys/vm/swappiness</li>
</ul>
<h4><a id="swap%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>swap 类型</h4>
<ul>
<li>swap分区</li>
<li>swap文件</li>
<li>kbcommit，表示当前系统负载需要的内存。它实际上是为了保证系统内存不溢出，对需要内存的估计值。%commit，就是这个值相对总内存的百分比。</li>
<li>kbactive，表示活跃内存，也就是最近使用过的内存，一般不会被系统回收。</li>
<li>kbinact，表示非活跃内存，也就是不常访问的内存，有可能会被系统回收。</li>
</ul>
<h4><a id="%E6%B8%85%E7%A9%BAbuffer%E5%92%8Ccache" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>清空buffer和cache</h4>
<ul>
<li>sync; echo 1 &gt; /proc/sys/vm/drop_caches;</li>
<li>echo 2 &gt; /proc/sys/vm/drop_caches;</li>
<li>echo 3 &gt; /proc/sys/vm/drop_caches;</li>
</ul>
<h4><a id="%E8%A7%82%E5%AF%9F%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>观察系统内存变化</h4>
<ul>
<li>watch -d grep -A 15 'Normal' /proc/zoneinfo</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-10-14T17:06:56+08:00" itemprop="datePublished">2018/10/14 17:06 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Golang.html'>Golang</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15395080168106.html" itemprop="url">
		数组和切片</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%88%87%E7%89%87%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>切片重要知识点</h4>
<ul>
<li>append函数返回的是指向原底层数组的新切片，而在需要扩容的时候，append函数返回的是指向新底层数组的新切片</li>
<li>切片大量缩容之后多余的内容没有被垃圾回收，可以使用新建一个数组然后copy的方式</li>
<li>把切片窗口向右扩展到最大的方法 s5 := s4[:cap(s4)]</li>
<li>切片窗口无法向左扩展</li>
</ul>
<h4><a id="%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩容策略</h4>
<ul>
<li>如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。</li>
</ul>
<h4><a id="%E5%88%87%E7%89%87%E6%8B%B7%E8%B4%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>切片拷贝</h4>
<pre><code class="language-plain_text">  n := copy(slice, array)
</code></pre>
<h4><a id="%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>切片扩容</h4>
<ul>
<li>两个切片公用一个数组，如果一个切片扩容超过数组的长度，就会使用新的数组，这个时候，二者的数据不一致了</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-11T10:03:05+08:00" itemprop="datePublished">2019/05/11 10:03 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15575401859226.html" itemprop="url">
		系统调用</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%88%91%E4%BB%AC%E7%BC%96%E5%86%99%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B9%B6%E4%B8%8D%E5%90%8C%E5%B1%9E%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%B8%A4%E8%BE%B9%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%83%BD%E6%98%AF%E7%8B%AC%E7%AB%8B%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>操作系统与我们编写的软件并不同属一个进程，两边的内存地址空间都是独立的，如何实现系统调用</h4>
<ul>
<li>从虚拟内存机制的视角，操作系统内核和所有进程都在同一个地址空间，也就是，操作系统内核，它是所有进程共享的内存<br />
<img src="media/15575401859226/2b0adde3eca6262ae674a97f478c15b3.png" alt="2b0adde3eca6262ae674a97f478c15b3" /></li>
<li>中断向量表的地址，以及操作系统内核的地址空间是一个契约。有了中断向量表的地址约定，用户态函数就可以发起一次系统调用（软中断）</li>
</ul>
<h4><a id="%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编程接口</h4>
<p><img src="media/15575401859226/b2393a109f849bd91c991b1e750cb3e0.png" alt="b2393a109f849bd91c991b1e750cb3e0" /><br />
*</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-10T19:54:53+08:00" itemprop="datePublished">2019/05/10 19:54 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15574892932253.html" itemprop="url">
		线程的创建</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原理</h4>
<ul>
<li>由内核态和用户态合作完成的</li>
<li>用户态维护线程的结构 pthread</li>
</ul>
<h4><a id="%E7%BA%BF%E7%A8%8B%E6%A0%88%E7%9A%84%E5%88%9B%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程栈的创建</h4>
<ul>
<li>设置栈的大小，需要你把设置的值拿出来；</li>
<li>为了防止栈的访问越界，在栈的末尾设置guardsize，一旦访问到这里就错误了；</li>
<li>get_cached_stack 从缓存中获取已经存在的线程</li>
<li>__mmap创建新的线程内存区域</li>
<li>计算出 guard 内存的位置</li>
<li>设置pthread 这个结构里面的成员变量 stackblock、stackblock_size、guardsize、specific。这里的 specific 是用于存放 Thread Specific Data 的，也即属于线程的全局变量；</li>
<li>将这个线程栈放到 stack_used 链表中，其实管理线程栈总共有两个链表，一个是 stack_used，也就是这个栈正被使用；另一个是 stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。</li>
</ul>
<h4><a id="%E5%86%85%E6%A0%B8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内核态创建任务</h4>
<ul>
<li>start_routine</li>
<li>__nptl_nthreads 线程数加1</li>
<li>create_thread 创建线程</li>
<li>--clone--&gt;do_fork</li>
</ul>
<h5><a id="%E6%A0%87%E5%BF%97%E4%BD%8D%E8%AE%BE%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标志位设定</h5>
<ul>
<li>CLONE_FS copy_fs</li>
<li>CLONE_SIGHAND copy_sighand</li>
<li>CLONE_VM copy_mm</li>
</ul>
<h5><a id="%E4%BA%B2%E7%BC%98%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>亲缘关系</h5>
<ul>
<li>CLONE_THREAD</li>
</ul>
<h5><a id="%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>信号处理</h5>
<ul>
<li>kill 进程</li>
<li>pthread_kill 线程</li>
<li>初始化 struct sigpending pending</li>
<li>返回用户态</li>
</ul>
<h4><a id="%E7%94%A8%E6%88%B7%E6%80%81%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户态执行线程</h4>
<ul>
<li>start_thread 统一入口</li>
<li>调用完毕线程数目减1</li>
</ul>
<h4><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h4>
<p><img src="media/15574892932253/14635b1613d04df9f217c3508ae8524b.jpeg" alt="14635b1613d04df9f217c3508ae8524b" /></p>
<ul>
<li>查看进程和线程栈的使用情况</li>
<li>pstack</li>
<li>pstree</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-08T08:11:52+08:00" itemprop="datePublished">2019/05/08 08:11 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html'>计算机组成原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15572743128254.html" itemprop="url">
		指令跳转</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="cpu%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CPU执行指令原理</h4>
<ul>
<li>一个是PC 寄存器（Program Counter Register），我们也叫指令地址寄存器（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。</li>
<li>第二个是指令寄存器（Instruction Register），用来存放当前正在执行的指令。</li>
<li>第三个是条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。<br />
<img src="media/15572743128254/cdba5c17a04f0dd5ef05b70368b9a96f.jpg" alt="cdba5c17a04f0dd5ef05b70368b9a96f" /></li>
</ul>
<h4><a id="%E7%94%9F%E6%88%90%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生成汇编代码</h4>
<ul>
<li>gcc -g -c test.c</li>
<li>objdump -d -M intel -S test.o</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-07T08:01:27+08:00" itemprop="datePublished">2019/05/07 08:01 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15571872879168.html" itemprop="url">
		抢占式调度</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>####时间片</p>
<ul>
<li>计算机隔一段时间触发时钟中断</li>
<li>计算进程分配的实际运行时间</li>
<li>进程总共执行的实际时间 - 上次被调度时总的的运行时间 = 本次实际运行时间</li>
<li>被调度条件</li>
<li>本次实际运行时间 &gt; 计算进程分配的实际运行时间</li>
<li>当前进程的 vruntime 大于红黑树中最小的进程的 vruntime</li>
<li>差值大于 ideal_runtime</li>
</ul>
<h4><a id="%E8%B0%83%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度</h4>
<ul>
<li>打上TIF_NEED_RESCHED标签</li>
</ul>
<h4><a id="%E8%BF%9B%E7%A8%8B%E8%A2%AB%E5%94%A4%E9%86%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程被唤醒</h4>
<ul>
<li>当被唤醒的进程优先级高于 CPU 上的当前进程，就会触发抢占</li>
<li>这个唤醒的任务添加到队列当中</li>
<li>激活任务</li>
<li>标记被抢占</li>
</ul>
<h4><a id="%E7%94%A8%E6%88%B7%E6%80%81%E6%8A%A2%E5%8D%A0%E6%97%B6%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户态抢占时机</h4>
<ul>
<li>用户态抢占时机 系统调用中返回的那个时刻，是一个被抢占的时机</li>
<li>中断中返回的那个时刻</li>
</ul>
<h4><a id="%E5%86%85%E6%A0%B8%E6%80%81%E6%8A%A2%E5%8D%A0%E6%97%B6%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内核态抢占时机</h4>
<ul>
<li>preempt_disable()--&gt;preempt_enable()</li>
<li>内核态中断返回</li>
</ul>
<h4><a id="%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程调度总结</h4>
<p><img src="media/15571872879168/93588d71abd7f007397979f0ba7def7f.png" alt="93588d71abd7f007397979f0ba7def7f" /></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-01T10:20:20+08:00" itemprop="datePublished">2019/05/01 10:20 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15566772208348.html" itemprop="url">
		进程调度</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%92%8C%E8%B0%83%E5%BA%A6%E7%A7%8D%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度策略和调度种类</h4>
<ul>
<li>实时进程</li>
<li>普通进程</li>
</ul>
<h4><a id="%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度策略和优先级</h4>
<ul>
<li>实时进程，优先级的范围是 0～99</li>
<li>普通进程，优先级的范围是 100～139</li>
</ul>
<h4><a id="%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实时调度策略</h4>
<ul>
<li>SCHED_FIFO 高优先级的进程可以抢占低优先级的进程，相同优先级的进程，我们遵循先来先得</li>
<li>SCHED_RR 采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务</li>
<li>SCHED_DEADLINE 当产生一个调度点的时候，DL 调度器总是选择其 deadline 距离当前时间点最近的那个任务，并调度它执行</li>
</ul>
<h4><a id="%E6%99%AE%E9%80%9A%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>普通调度策略</h4>
<ul>
<li>SCHED_NORMAL 普通进程</li>
<li>SCHED_BATCH 后台进程</li>
<li>SCHED_IDLE 空闲进程</li>
</ul>
<h4><a id="%E8%B0%83%E5%BA%A6%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度变量</h4>
<ul>
<li>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li>
<li>dl_sched_class 就对应上面的 deadline 调度策略；</li>
<li>rt_sched_class 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；</li>
<li>fair_sched_class 就是普通进程的调度策略；</li>
<li>idle_sched_class 就是空闲进程的调度策略。</li>
</ul>
<h4><a id="%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>完全公平调度算法</h4>
<ul>
<li>CFS 会为每一个进程安排一个虚拟运行时间 vruntime。如果一个进程在运行，随着时间的增长，也就是一个个 tick 的到来，进程的 vruntime 将不断增大。没有得到执行的进程 vruntime 不变</li>
<li>虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD/ 权重</li>
</ul>
<h4><a id="%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E5%92%8C%E8%B0%83%E5%BA%A6%E5%AE%9E%E4%BD%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度队列和调度实体</h4>
<ul>
<li>实时调度实体 sched_rt_entity</li>
<li>Deadline 调度实体 sched_dl_entity  deadline</li>
<li>完全公平算法调度实体 sched_entity real time</li>
</ul>
<h4><a id="cpu%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CPU进程调度</h4>
<p><img src="media/15566772208348/10381dbafe0f78d80beb87560a9506af.jpeg" alt="10381dbafe0f78d80beb87560a9506af" /><br />
*</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-04-22T08:21:14+08:00" itemprop="datePublished">2019/04/22 08:21 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15558924748383.html" itemprop="url">
		进程数据结构</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="task-struct" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>task_struct</h4>
<ul>
<li>任务ID</li>
<li>任务展示</li>
</ul>
<h4><a id="%E4%B8%89%E7%A7%8D%E7%9D%A1%E7%9C%A0%E7%8A%B6%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三种睡眠状态</h4>
<ul>
<li>TASK_INTERRUPTIBLE，可中断的睡眠状态</li>
<li>TASK_UNINTERRUPTIBLE，不可中断的睡眠状态</li>
<li>TASK_KILLABLE，可以终止的新睡眠状态 可以响应致命信号</li>
</ul>
<h4><a id="%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程调度</h4>
<ul>
<li>任务状态</li>
<li>信号处理</li>
<li>任务ID</li>
<li>调度相关</li>
</ul>
<h4><a id="%E8%BF%90%E8%A1%8C%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>运行统计信息</h4>
<h4><a id="%E8%BF%9B%E7%A8%8B%E4%BA%B2%E7%BC%98%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程亲缘关系</h4>
<ul>
<li>parent 指向其父进程。当它终止时，必须向它的父进程发送信号。</li>
<li>children 表示链表的头部。链表中的所有元素都是它的子进程。</li>
<li>sibling 用于把当前进程插入到兄弟链表中。<br />
<img src="media/15558924748383/92711107d8dcdf2c19e8fe4ee3965304.jpeg" alt="92711107d8dcdf2c19e8fe4ee3965304" /></li>
</ul>
<h4><a id="%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%9A%84%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户和用户组的信息</h4>
<ul>
<li>uid gid</li>
<li>euid egid</li>
<li>fsuid fsgid</li>
</ul>
<h4><a id="capabilites" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>capabilites</h4>
<ul>
<li>cap_permitted 表示进程能够使用的权限</li>
<li>cap_bset，也就是 capability bounding set，是系统中所有进程允许保留的权限。如果这个集合中不存在某个权限，那么系统中的所有进程都没有这个权限。即使以超级用户权限执行的进程，也是一样的</li>
<li>cap_ambient 是比较新加入内核,执行 exec 的时候，cap_ambient 会被添加到 cap_permitted 中，同时设置到 cap_effective 中</li>
</ul>
<h4><a id="%E8%BF%9B%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程</h4>
<ul>
<li>任务ID</li>
<li>亲缘关系</li>
<li>任务状态</li>
<li>权限</li>
<li>运行统计</li>
<li>调度相关</li>
<li>信号处理</li>
<li>内存管理</li>
<li>文件和文件系统</li>
<li>内核栈<br />
<img src="media/15558924748383/1c91956b52574b62a4418a7c6993d8bc.jpeg" alt="1c91956b52574b62a4418a7c6993d8b" /></li>
</ul>
<h4><a id="%E7%94%A8%E6%88%B7%E6%A0%88%E5%92%8C%E5%86%85%E6%A0%B8%E6%A0%88%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户栈和内核栈的具体实现</h4>
<ul>
<li>用户栈详解：<a href="http://blog.csdn.net/tiankong_/article/details/75676131">http://blog.csdn.net/tiankong_/article/details/75676131</a></li>
<li>内核栈详解：<a href="http://blog.csdn.net/tiankong_/article/details/75647488">http://blog.csdn.net/tiankong_/article/details/75647488</a></li>
</ul>
<h4><a id="%E7%94%A8%E6%88%B7%E6%80%81%E5%87%BD%E6%95%B0%E6%A0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户态函数栈</h4>
<ul>
<li>栈是一个从高地址到低地址，往下增长的结构，也就是上面是栈底，下面是栈顶，入栈和出栈的操作都是从下面的栈顶开始的。<br />
<img src="media/15558924748383/aec865abccf0308155f4138cc905972e.jpg" alt="aec865abccf0308155f4138cc905972e" /></li>
</ul>
<h4><a id="%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%89%A7%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户态和内核态执行</h4>
<ul>
<li>struct thread_info thread_info;</li>
<li>void  *stack;</li>
</ul>
<h4><a id="%E5%86%85%E6%A0%B8%E6%A0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内核栈</h4>
<p><img src="media/15558924748383/31d15bcd2a053235b5590977d12ffa2d.jpeg" alt="31d15bcd2a053235b5590977d12ffa2d" /></p>
<h4><a id="task-struct%E6%89%BE%E5%86%85%E6%A0%B8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>task_struct找内核</h4>
<ul>
<li>task_struct找内核栈是通过stack指针，直接找到内核线程栈，stack指针记录的是内核栈的首地址。</li>
<li>task_struck找内核寄存器是通过 内核栈的首地址（1中的stack指针） + (THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING)定位到pt_regs的最高位地址，再减一得到pt_regs的最低位地址（首地址）</li>
</ul>
<h4><a id="%E5%86%85%E6%A0%B8%E6%89%BEtask-struct" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内核找task_struct</h4>
<ul>
<li>通过内核栈找到 task_struct<br />
  32位 直接由 thread_info 中的指针得到<br />
  64位 每个 CPU 当前运行进程的 task_struct 的指针存放到 Per CPU 变量 current_task 中<br />
 <br />
 ####</li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_60.html">Prev</a>  
	 <a class="next" href="all_62.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>