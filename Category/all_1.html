<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	       凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2022-10-01T09:38:02+08:00" itemprop="datePublished">2022/10/01 09:38 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RocketMQ-1.html'>RocketMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16645882825412.html" itemprop="url">
		优化订单的定时退款扫描问题</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%BB%A5%E5%89%8D%E7%9A%84%E8%AE%A2%E5%8D%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>以前的订单</h4>
<p><img src="media/16645882825412/16645883336357.jpg" alt="" /></p>
<h4><a id="%E4%B8%8D%E8%B6%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不足</h4>
<ul>
<li>一个原因是未支付状态的订单可能是比较多的，然后你需要不停的扫描他们，可能每个未支付状态的订单要被扫描多遍，才会发现他已经超过 30 分钟没支付了。</li>
<li>另外一个是很难去分布式并行扫描你的订单。因为假设你的订单数据量特别的多，然后你要是打算用多台机器部署订单扫描服务，但是每台机器扫描哪些订单？怎么扫描？什么时候扫描？这都是一系列的麻烦问题。</li>
</ul>
<h4><a id="%E6%94%B9%E8%BF%9B%E5%90%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>改进后</h4>
<p><img src="media/16645882825412/16645886753297.jpg" alt="" /></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2022-10-01T09:32:33+08:00" itemprop="datePublished">2022/10/01 09:32 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RocketMQ-1.html'>RocketMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16645879531849.html" itemprop="url">
		过滤机制</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AFtag" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置消息tag</h4>
<ul>
<li>在消费数据的时候根据 tag 和属性进行过滤</li>
<li>接着我们可以在消费的时候根据 tag 和属性进行过滤，比如我们可以通过下面的代码去指定，我们只要 tag= TableA 和 tag= TableB 的数据。</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2022-10-01T08:54:05+08:00" itemprop="datePublished">2022/10/01 08:54 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RocketMQ-1.html'>RocketMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16645856453234.html" itemprop="url">
		消息乱序</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8F%91%E9%80%81%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发送到同一个队列</h4>
<ul>
<li>接着我们将 binlog。发送给 MQ 的时候，必须将一个订单的 binlog 都发送到一个 MessageQueue 里去，而且发送过去的时候，也必须是严格按照顺序来发送的</li>
<li>只有这样，最终才能让一个订单的 binlog：进入同一个 MessageQueue，而且还是有序的，如下图所示：</li>
<li><img src="media/16645856453234/16645873622136.jpg" alt="" /></li>
<li>失败后</li>
<li>所以对于有序消息的方案中，如果你遇到消息处理失败的场景，就必须返回 SUSPEND_ CURRENT_ QUEUE_ A_MOMENT 这个状态，意思是先等一会儿，一会儿再继续处理这批消息，而不能把这批消息放入重试队列去，然后直接处理下一批消息。</li>
<li>MessageListenerOrderly处理问题</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2022-09-26T11:18:07+08:00" itemprop="datePublished">2022/09/26 11:18 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='RocketMQ-1.html'>RocketMQ</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16641622874455.html" itemprop="url">
		0消息丢失方案</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8F%91%E9%80%81half%E6%B6%88%E6%81%AF%E5%88%B0-mq%E5%8E%BB%EF%BC%8C%E8%AF%95%E6%8E%A2%E4%B8%80%E4%B8%8B-mq%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发送 half 消息到 MQ 去，试探一下 MQ 是否正常</h4>
<h4><a id="half%E6%B6%88%E6%81%AF%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%BB%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Half 消息成功之后，订单系统完成自己的任务</h4>
<h4><a id="%E7%A4%BA%E6%84%8F%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示意图</h4>
<p><img src="media/16641622874455/16641624954774.jpg" alt="" /></p>
<ul>
<li><img src="media/16641622874455/16641630017188.jpg" alt="" /></li>
</ul>
<h4><a id="%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现原理</h4>
<p><img src="media/16641622874455/16641795230258.jpg" alt="" /></p>
<ul>
<li>那么在什么情况下订单系统会收到 half 消息成功的响应呢？</li>
<li>必须要 half 消息进入到 RocketMQ 内部的 RMQ_SYS_ TRANS_HALF_ TOPIC 的 ConsumeQueue 文件了，此时就会认为 half 消息写入成功了，然后就会返回响应给订单系统</li>
</ul>
<h4><a id="%E6%B2%A1%E6%9C%89rollback%E5%92%8Ccommit" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>没有rollback和commit</h4>
<p>后台有定时任务，定时任务会去扫描 RMQ_SYS_ TRANS_HALF_ TOPIC 中的 Half 消息，如果你超过一定时间还是 half 消息，他会回调订单系统的接口，让你判断这个 half 消息是要 rollback 还是 commit</p>
<h4><a id="%E5%A6%82%E6%9E%9C%E6%89%A7%E8%A1%8Crollback%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A0%87%E8%AE%B0%E6%B6%88%E6%81%AF%E5%9B%9E%E6%BB%9A%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如果执行 rollback 操作的话，如何标记消息回滚？</h4>
<p><img src="media/16641622874455/16641799077127.jpg" alt="" /></p>
<ul>
<li>RocketMQ 内部有一个 OP_ TOPIC，此时可以写一条 rollback OP 记录到这个 Topic！里，标记某个 half 消息是 rollback 了</li>
</ul>
<h4><a id="commit%E5%90%8E%E5%A6%82%E4%BD%95%E8%AE%A9%E6%B6%88%E6%81%AF%E5%8F%AF%E8%A7%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>commit后如何让消息可见</h4>
<p><img src="media/16641622874455/16641799707247.jpg" alt="" /></p>
<h4><a id="%E6%B6%88%E8%B4%B9%E8%80%85%E7%BA%A2%E5%8C%850%E4%B8%A2%E5%A4%B1%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消费者红包0丢失方案</h4>
<ul>
<li>RocketMQ 的消费者中会注册一个监听器，就是上面小块代码中的 MessageListenerConcurrently：这个东西，当你的消费者获取到一批消息之后，就会回调你的这个监听器函数，让你来处理这一批消息。</li>
<li>然后当你处理完毕之后，你才会返 ConsumeConcurrentlyStatus. CONSUME_ SUCCESS 作为消费成功的示意，告诉 RocketMQ，这批消息我已经处理完毕了。</li>
<li><img src="media/16641622874455/16645079793023.jpg" alt="" /></li>
</ul>
<h4><a id="%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E5%B9%82%E7%AD%89%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>防止消息重复的幂等操作</h4>
<p><img src="media/16641622874455/16645259880171.jpg" alt="" /></p>
<h4><a id="%E9%87%8D%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重试</h4>
<p><img src="media/16641622874455/16645827274059.jpg" alt="" /></p>
<ul>
<li>RESUME——LATER</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-16T10:04:36+08:00" itemprop="datePublished">2019/08/16 10:04 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15659210764719.html" itemprop="url">
		链表</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8F%8D%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>反转</h4>
<ul>
<li>leet_206</li>
</ul>
<pre><code class="language-C++">Reverse a singly linked list.

Example:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
      ListNode* pre = nullptr;
      while (head) {
        ListNode* next = head-&gt;next;
        head-&gt;next= pre;
        pre = head;
        head = next;
      }
      return pre;
    }
};
</code></pre>
<ul>
<li>leet_92</li>
</ul>
<pre><code class="language-C++">Reverse a linked list from position m to n. Do it in one-pass.

Note: 1 ≤ m ≤ n ≤ length of list.

Example:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

static int x = []() {std::ios::sync_with_stdio(false); cin.tie(0); return 0; }();

class Solution 
{
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) 
    {
        if (head == nullptr || head-&gt;next == nullptr ||
            m &gt;= n || m &lt; 0 || n &lt; 0)
        {
            return head;
        }
        ListNode* h = new ListNode(-1);
        h-&gt;next = head;
        ListNode* pre = h;
        ListNode* cur = head;
        int i = 1;
        for (; i &lt; m &amp;&amp; cur != nullptr; ++i)
        {
            pre = cur;
            cur = cur-&gt;next;
        }
        ListNode* t1 = pre;
        ListNode* t2 = cur;
        for (; i &lt;= n &amp;&amp; cur != nullptr; ++i)
        {
            ListNode* lat = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = lat;
        }
        t1-&gt;next = pre;
        t2-&gt;next = cur;
        return h-&gt;next;
    }
};
</code></pre>
<ul>
<li>leet_83</li>
</ul>
<pre><code class="language-C++">Given a sorted linked list, delete all duplicates such that each element appear only  once.

Example 1:

Input: 1-&gt;1-&gt;2
Output: 1-&gt;2
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode *cur = head;
        while (cur &amp;&amp; cur-&gt;next) {
            if (cur-&gt;val == cur-&gt;next-&gt;val) {
                cur-&gt;next = cur-&gt;next-&gt;next;
            } else {
                cur = cur-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
<ul>
<li>leet_86</li>
</ul>
<pre><code class="language-C++">Given a linked list and a value  x , partition it such that all nodes less than  x  come before nodes greater than or equal to  x.

You should preserve the original relative order of the nodes in each of the two partitions.

For example,
Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and  x  = 3,
return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.
就是将所有小于给定值的节点取出组成一个新的链表，此时原链表中剩余的节点的值都大于或等于给定值，只要将原链表直接接在新链表后即可
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
      ListNode node1(0);
      ListNode node2(0);
      ListNode* p1 = &amp;node1;
      ListNode* p2 = &amp;node2;
      while (head) {
        if (head-&gt;val &lt; x) {
          p1-&gt;next = head;
          p1 = p1-&gt;next;
        } else {
          p2-&gt;next = head;
          p2 = p2-&gt;next;
        }
        head = head-&gt;next;
      }
      p2-&gt;next = nullptr;
      p1-&gt;next = node2.next;
      return node1.next;
    }
};
</code></pre>
<ul>
<li>leet_328</li>
</ul>
<pre><code class="language-C++">Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example 1:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL
func oddEvenList(head *ListNode) *ListNode {
	if head == nil {
		return head
	}
	
	odd := head
	evenHead := head.Next
	even := evenHead
	
	for even != nil &amp;&amp; even.Next != nil {
		odd.Next = even.Next
		odd = odd.Next
		even = odd.Next
		even = even.Next
	}
	odd.Next = evenHead
	return head
}
</code></pre>
<ul>
<li>leet_2</li>
</ul>
<pre><code class="language-C++">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
Explanation: 342 + 465 = 807.
class Solution {
public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode node(0), *p = &amp;node;
    int extra = 0;
    while (l1 || l2 || extra) {
      if (l1) extra += l1-&gt;val, l1 = l1-&gt;next;
      if (l2) extra += l2-&gt;val, l2 = l2-&gt;next;
      p-&gt;next = new ListNode(extra % 10);
      extra /= 10;
      p = p-&gt;next;
    }
    return node.next;

  }
};
</code></pre>
<ul>
<li>leet_445</li>
</ul>
<pre><code class="language-C++">Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

Example:

Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 8 -&gt; 0 -&gt; 7
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    stack&lt;int&gt; v1, v2;
    while (l1) v1.push(l1-&gt;val), l1 = l1-&gt;next;
    while (l2) v2.push(l2-&gt;val), l2 = l2-&gt;next;

    int extra = 0;

    ListNode dummy, *pre = nullptr;
    while (!v1.empty() || !v2.empty() || extra) {
        if (!v1.empty()) extra += v1.top(), v1.pop();
        if (!v2.empty()) extra += v2.top(), v2.pop();

        ListNode* p = new ListNode(extra % 10);
        extra /= 10;
        p-&gt;next = pre;
        pre = p;
    }
    return pre;
    }
};
</code></pre>
<h4><a id="%E8%AE%BE%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设立虚拟头节点</h4>
<ul>
<li>leet_203</li>
</ul>
<pre><code class="language-C++">Remove all elements from a linked list of integers that have value val.

Example
Given: 1 -- &gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6
Return: 1 -- &gt; 2 --&gt; 3 --&gt; 4 --&gt; 5
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) 
    {
        ListNode* h = new ListNode(-1);
        h-&gt;next = head;
        ListNode *cur = h;
        while (cur-&gt;next != nullptr)
        {
            ListNode* delNode = cur-&gt;next;
            if (delNode-&gt;val == val)
            {
                cur-&gt;next = delNode-&gt;next;
                delete delNode;
            }
            else
            {
                cur = cur-&gt;next;
            }
        }
        ListNode* retNode = h-&gt;next;
        delete h;
        return retNode;
    }
  };
</code></pre>
<ul>
<li>leet_82</li>
</ul>
<pre><code class="language-C++">class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head || !head-&gt;next) return head;
        ListNode *dummy = new ListNode(-1), *pre = dummy;
        dummy-&gt;next = head;
        while (pre-&gt;next) {
            ListNode *cur = pre-&gt;next;
            while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) {
                cur = cur-&gt;next;
            }
            if (cur != pre-&gt;next) pre-&gt;next = cur-&gt;next;
            else pre = pre-&gt;next;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<ul>
<li>leet_21</li>
</ul>
<pre><code class="language-C++">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
class Solution {
public:
  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

    ListNode node(0), *p = &amp;node;
    while (l1 &amp;&amp; l2) {
      if (l1-&gt;val &lt; l2-&gt;val) {
        p-&gt;next = l1;
        l1 = l1-&gt;next;
      } else {
        p-&gt;next = l2;
        l2 = l2-&gt;next;
      }
      p = p-&gt;next;
    }

    p-&gt;next = l1 ? l1 : l2;
    return node.next;
  }
};
</code></pre>
<ul>
<li>leet_25</li>
</ul>
<pre><code class="language-C++">Example:

Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5

For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5

For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
      ListNode dumy(0), *pre = &amp;dumy, *cur = &amp;dumy;
      dumy.next = head;
      int num = 0;
      while (cur = cur-&gt;next)  num++;
      while (num &gt;= k) {
        cur = pre-&gt;next;
        for (int i = 1; i &lt; k; i++) {
          ListNode* t = cur-&gt;next;
          cur-&gt;next = t-&gt;next;
          t-&gt;next = pre-&gt;next;
          pre-&gt;next = t;
        }
        pre = cur;
        num -= k;
      }
      return dumy.next;
    }
};
</code></pre>
<ul>
<li>leet_147</li>
</ul>
<pre><code class="language-C++">Sort a linked list using insertion sort.
Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode* dummy = new ListNode(0);
        dummy -&gt; next = head;
        ListNode *pre = dummy, *cur = head;
        while (cur) {
            if ((cur -&gt; next) &amp;&amp; (cur -&gt; next -&gt; val &lt; cur -&gt; val)) {
                while ((pre -&gt; next) &amp;&amp; (pre -&gt; next -&gt; val &lt; cur -&gt; next -&gt; val)) {
                    pre = pre -&gt; next;
                }
                ListNode* temp = pre -&gt; next;
                pre -&gt; next = cur -&gt; next;
                cur -&gt; next = cur -&gt; next -&gt; next;
                pre -&gt; next -&gt; next = temp;
                pre = dummy;
            }
            else {
                cur = cur -&gt; next;
            }
        }
        return dummy -&gt; next;
    }
};
</code></pre>
<ul>
<li>leet_148</li>
</ul>
<pre><code class="language-Go">Sort a linked list in  O ( n  log  n ) time using constant space complexity.

Example 1:

Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
Example 2:

Input: -1-&gt;5-&gt;3-&gt;4-&gt;0
Output: -1-&gt;0-&gt;3-&gt;4-&gt;5
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head-&gt;next) return head;
        ListNode *slow = head, *fast = head, *pre = head;
        while (fast &amp;&amp; fast-&gt;next) {
            pre = slow;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        pre-&gt;next = NULL;
        return merge(sortList(head), sortList(slow));
    }
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode *dummy = new ListNode(-1);
        ListNode *cur = dummy;
        while (l1 &amp;&amp; l2) {
            if (l1-&gt;val &lt; l2-&gt;val) {
                cur-&gt;next = l1;
                l1 = l1-&gt;next;
            } else {
                cur-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            cur = cur-&gt;next;
        }
        if (l1) cur-&gt;next = l1;
        if (l2) cur-&gt;next = l2;
        return dummy-&gt;next;
    }
};
</code></pre>
<ul>
<li>leet_237</li>
</ul>
<pre><code class="language-C++">Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        ListNode *tmp = node-&gt;next;
        node-&gt;next = tmp-&gt;next;
        delete tmp;
    }
};
</code></pre>
<h4><a id="%E5%8F%8C%E8%8A%82%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双节点</h4>
<ul>
<li>leet_61</li>
</ul>
<pre><code class="language-C++">Given a list, rotate the list to the right by  k  places, where  k  is non-negative.

For example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and  k  = 2,
return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.
class Solution {
public:
    ListNode *rotateRight(ListNode *head, int k) {
        if (!head) return NULL;
        int n = 0;
        ListNode *cur = head;
        while (cur) {
            ++n;
            cur = cur-&gt;next;
        }
        k %= n;
        ListNode *fast = head, *slow = head;
        for (int i = 0; i &lt; k; ++i) {
            if (fast) fast = fast-&gt;next;
        }
        if (!fast) return head;
        while (fast-&gt;next) {
            fast = fast-&gt;next;
            slow = slow-&gt;next;
        }
        fast-&gt;next = head;
        fast = slow-&gt;next;
        slow-&gt;next = NULL;
        return fast;
    }
};
</code></pre>
<ul>
<li>leet_143</li>
</ul>
<pre><code class="language-Go">Given a singly linked list  L :  L 0→ L 1→…→ L n -1→ L n,
reorder it to:  L 0→ L n → L 1→ L n -1→ L 2→ L n -2→…

You may not modify the values in the list's nodes, only nodes itself may be changed.

Example 1:

Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.
Example 2:

Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.
func middleNode(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast.Next != nil &amp;&amp; fast.Next.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
	}
	return slow
}

func reverse(head *ListNode) *ListNode {
	var pre *ListNode = nil
	for head != nil {
		next := head.Next
		head.Next = pre
		pre = head
		head = next
	}
	return pre
}

func mergeList(l1, l2 *ListNode){
	var p1, p2 *ListNode
	for l1 != nil &amp;&amp; l2 != nil {
		p1 = l1.Next
		p2 = l2.Next

		l1.Next = l2
		l1 = p1
		l2.Next = l1
		l2 = p2
	}
}
func reorderList(head *ListNode) {
	if head == nil {
		return
	}
	mid := middleNode(head)
	l1 := head
	l2 := mid.Next
	mid.Next = nil
	l2 = reverse(l2)
	mergeList(l1, l2)
}
</code></pre>
<ul>
<li>leet_234</li>
</ul>
<pre><code class="language-C++">Given a singly linked list, determine if it is a palindrome.

Example 1:

Input: 1-&gt;2
Output: false
Example 2:

Input: 1-&gt;2-&gt;2-&gt;1
Output: true
class Solution {
  public:
  ListNode* reverse(ListNode* head) {
    ListNode* pre = nullptr, *next = nullptr;

    while (head) {
      next = head-&gt;next;
      head-&gt;next = pre;
      pre = head;
      head = next;
    }

    return pre;
  }

  bool isPalindrome(ListNode* head) {
    if (!head || !head-&gt;next) return true;
    
    ListNode* fast = head, *slow = head;
    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {
      slow = slow-&gt;next;
      fast = fast-&gt;next-&gt;next;
    }

    ListNode* mid = slow-&gt;next;
    ListNode* rhead = reverse(mid);
    while (rhead) {
      if (rhead-&gt;val != head-&gt;val) return false;
      rhead = rhead-&gt;next;
      head = head-&gt;next;
    }
    return true;
  }
};
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2022-09-30T10:20:34+08:00" itemprop="datePublished">2022/09/30 10:20 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='etcd.html'>etcd</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16645044343535.html" itemprop="url">
		etcd常见运维故障</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a></h4>
<p><img src="media/16645044343535/16645051031919.png" alt="" /></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2022-09-30T09:29:09+08:00" itemprop="datePublished">2022/09/30 09:29 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='etcd.html'>etcd</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16645013499602.html" itemprop="url">
		分布式锁</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分布式锁</h4>
<ul>
<li>互斥性、安全性、活性、高可用、高性能</li>
</ul>
<h4><a id="redis%E4%B8%8D%E5%AE%89%E5%85%A8%E5%9B%A0%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>redis不安全因素</h4>
<ul>
<li>主备切换</li>
<li>脑裂</li>
</ul>
<h4><a id="redlock%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RedLock算法</h4>
<ul>
<li>依赖系统时间，当时钟发生跳跃时，也可能会出现安全性问题</li>
</ul>
<h4><a id="etcd%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>etcd分布式锁实现</h4>
<ul>
<li>事务与锁的安全性</li>
<li>Lease 与锁的活性</li>
<li>Watch 与锁的可用性</li>
<li>prefix功能和lease解决死锁问题</li>
<li>revision功能</li>
<li>通过 Revision 的大小就可以知道进行写操作的顺序。在实现分布式锁时，多个客户端同时抢锁，根据 Revision 号大小依次获得锁，可以避免 “羊群效应” （也称 “惊群效应”），实现公平锁</li>
</ul>
<h4><a id="etcd%E8%87%AA%E5%B8%A6concurrency%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>etcd自带concurrency包</h4>
<pre><code class="language-go">// Mutex implements the sync Locker interface with etcd
type Mutex struct {
    s *Session  //上面的Session struct

    pfx   string  //前缀
    myKey string  //key
    myRev int64   //Revision
    hdr   *pb.ResponseHeader
}

func NewMutex(s *Session, pfx string) *Mutex {
	return &amp;Mutex{s, pfx + &quot;/&quot;, &quot;&quot;, -1, nil}
}

// Lock locks the mutex with a cancelable context. If the context is canceled
// while trying to acquire the lock, the mutex tries to clean its stale lock entry.
func (m *Mutex) Lock(ctx context.Context) error {
    s := m.s  //上面的Session struct
    client := m.s.Client()
    
    //m.pfx是前缀，比如&quot;myresource/lock/&quot;
    //s.Lease()是一个64位的整数值，etcd v3引入了lease（租约）的概念，concurrency包基于lease封装了session，
    //每一个客户端都有自己的lease，也就是说每个客户端都有一个唯一的64位整形值
    
    //m.myKey类似于&quot;myresource/lock/12345&quot;
    m.myKey = fmt.Sprintf(&quot;%s%x&quot;, m.pfx, s.Lease())
    
    
    //etcdv3新引入的多键条件事务，替代了v2中Compare-And-put操作。
    //etcdv3的多键条件事务的语意是先做一个比较（compare）操作，
    //如果比较成立则执行一系列操作，如果比较不成立则执行另外一系列操作。
    
    //接下来的这部分实现了如果不存在这个key，则将这个key写入到etcd，如果存在则读取这个key的值这样的功能。
    //下面这一句，是构建了一个compare的条件，比较的是key的createRevision（createRevision是表示这个key创建时被分配的这个序号。
    //当key不存在时，createRevision是0。），如果revision是0，则存入一个key，如果revision不为0，则读取这个key。
    //revision是etcd一个全局的序列号,全局唯一且递增，每一个对etcd存储进行改动都会分配一个这个序号，在v2中叫index
    cmp := v3.Compare(v3.CreateRevision(m.myKey), &quot;=&quot;, 0) //cmp 比较Revision, 当key不存在时，createRevision是0。
    // put self in lock waiters via myKey; oldest waiter holds lock
    put := v3.OpPut(m.myKey, &quot;&quot;, v3.WithLease(s.Lease()))
    // reuse key in case this session already holds the lock
    get := v3.OpGet(m.myKey)
    
    // 如果revision为0，则存入，否则获取
    resp, err := client.Txn(ctx).If(cmp).Then(put).Else(get).Commit()
    if err != nil {
        return err
    }
    // 本次操作的revision
    m.myRev = resp.Header.Revision
    // 操作失败，则获取else返回的值，即已有的revision
    if !resp.Succeeded {
        m.myRev = resp.Responses[0].GetResponseRange().Kvs[0].CreateRevision
    }
    
    ownerKey := resp.Responses[1].GetResponseRange().Kvs
    if len(ownerKey) == 0 || ownerKey[0].CreateRevision == myRev {
        m.hdr = resp.Header
		return nil
        //成功获取锁
    }
    
    //如果上面的code操作成功了，则myRev是当前客户端创建的key的revision值。
    //waitDeletes等待匹配m.pfx （&quot;/myresource/lock/&quot;）这个前缀（可类比在这个目录下的）并且createRivision小于m.myRev-1所有key被删除
    //如果没有比当前客户端创建的key的revision小的key，则当前客户端者获得锁
    //如果有比它小的key则等待，比它小的被删除
    hdr, werr = waitDeletes(ctx, client, m.pfx, m.myRev-1)
    
    // release lock key if wait failed
    if werr != nil {
        m.Unlock(client.Ctx())
    } else {
        m.hdr = hdr
    }
    return werr
}
</code></pre>
<h4><a id="etcd%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>etcd常见故障定位</h4>
<ul>
<li>磁盘 IO 相关的。比如模拟磁盘 IO 延时上升、IO 操作报错。之前遇到的一个底层磁盘硬件异常导致 IO 延时飙升，最终触发了 etcd 死锁的 Bug，我们就是通过模拟磁盘 IO 延时上升后来验证的。</li>
<li>网络相关的。比如模拟网络分区、网络丢包、网络延时、包重复等。</li>
<li>进程相关的。比如模拟进程异常被杀、重启等。之前遇到的一个非常难定位和复现的数据不一致 Bug，我们就是通过注入进程异常重启等故障，最后成功复现。</li>
<li>压力测试相关的。比如模拟 CPU 高负载、内存使用率等</li>
<li>chaos-mesh</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2022-09-28T11:21:57+08:00" itemprop="datePublished">2022/09/28 11:21 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='etcd.html'>etcd</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16643353176456.html" itemprop="url">
		etcd性能优化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="db-quota" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>db quota</h4>
<h4><a id="%E9%99%90%E9%80%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>限速</h4>
<h4><a id="%E5%BF%83%E8%B7%B3%E5%8F%8A%E9%80%89%E4%B8%BE%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>心跳及选举参数优化</h4>
<h4><a id="%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A3%81%E7%9B%98io%E5%BB%B6%E6%97%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>网络和磁盘 IO 延时</h4>
<h4><a id="%E5%BF%AB%E7%85%A7%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快照参数优化</h4>
<h4><a id="%E5%A4%A7value" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>大 value</h4>
<h4><a id="boltdb%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>boltdb 锁</h4>
<h4><a id="grpc-proxy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>grpc_proxy</h4>
<ul>
<li>扩展读，扩展watch，扩展lease</li>
</ul>
<p><img src="media/16643353176456/16643363270396.jpg" alt="" /></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2022-09-26T08:14:41+08:00" itemprop="datePublished">2022/09/26 08:14 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='etcd.html'>etcd</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="16641512816265.html" itemprop="url">
		内存占用过高</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="raftlog" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>raftLog</h4>
<h4><a id="treeindex" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>treeIndex</h4>
<p>一个 key 的索引项内存开销跟你的 key 大小、保存的历史版本数、compact 策略有关。为了避免内存索引项占用过多的内存，key 的长度不应过长，同时你需要配置好合理的压缩策略</p>
<h4><a id="boltdb" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>boltdb</h4>
<h4><a id="watcher" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>watcher</h4>
<h4><a id="expensive-request" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>expensive request</h4>
<ul>
<li>那么 boltdb 遍历、反序列化过程</li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all.html">Prev</a>  
	 <a class="next" href="all_2.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>