<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  查找表 - eredin-blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="eredin-blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; eredin-blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Prometheus.html">Prometheus</a></li>
        
            <li><a href="RocketMQ.html">RocketMQ</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html">网络协议</a></li>
        
            <li><a href="Golang.html">Golang</a></li>
        
            <li><a href="Django.html">Django</a></li>
        
            <li><a href="C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98.html">C++设计模式实战</a></li>
        
            <li><a href="%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes.html">深入剖析Kubernetes</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html">数据结构和算法</a></li>
        
            <li><a href="%E5%BE%AE%E6%9C%8D%E5%8A%A1.html">微服务</a></li>
        
            <li><a href="%E6%9E%B6%E6%9E%84.html">架构</a></li>
        
            <li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">操作系统原理</a></li>
        
            <li><a href="Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Mysql优化实战</a></li>
        
            <li><a href="Kafka.html">Kafka</a></li>
        
            <li><a href="linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html">linux服务器研发</a></li>
        
            <li><a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html">计算机组成原理</a></li>
        
            <li><a href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html">程序员的自我修养</a></li>
        
            <li><a href="C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6.html">C语言进阶</a></li>
        
            <li><a href="http_study.html">http_study</a></li>
        
            <li><a href="%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html">玩转算法</a></li>
        
            <li><a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html">C++对象模型</a></li>
        
            <li><a href="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html">SQL必知必会</a></li>
        
            <li><a href="Zookeeper.html">Zookeeper</a></li>
        
            <li><a href="Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html">Redis从入门到精通</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6.html">数据结构和算法进阶</a></li>
        
            <li><a href="Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">Mysql性能管理和架构设计</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html">网络编程实战</a></li>
        
            <li><a href="Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html">Redis高并发缓存</a></li>
        
            <li><a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html">C++基础与提高</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html">设计模式之美</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
        
            <li><a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html">Linux性能优化实战</a></li>
        
            <li><a href="%E5%80%99%E6%8D%B7STL.html">候捷STL</a></li>
        
            <li><a href="%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE.html">性能工程高手课</a></li>
        
            <li><a href="%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html">性能测试</a></li>
        
            <li><a href="ElasticSearch.html">ElasticSearch</a></li>
        
            <li><a href="RabbitMQ.html">RabbitMQ</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>查找表</h1>
     
        <div class="read-more clearfix">
          <span class="date">2019/08/02 10:36 上午</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <h4>两类</h4>

<ul>
<li>查找有无</li>
<li>查找对应关系</li>
<li>有序和查找是关联</li>
<li>如果数组有序</li>
<li>leet_349</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given two arrays, write a function to compute their intersection.
class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        set&lt;int&gt; s(nums1.begin(), nums1.end()), res;
        for (auto a : nums2) {
            if (s.count(a)) res.insert(a);
        }
        return vector&lt;int&gt;(res.begin(), res.end());
    }
};
</code></pre>

<ul>
<li>leet_350</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given two arrays, write a function to compute their intersection.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        unordered_map&lt;int, int&gt; m;
        vector&lt;int&gt; res;
        for (auto a : nums1) ++m[a];
        for (auto a : nums2) {
            if (m[a]-- &gt; 0) res.push_back(a);
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_242</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">For example,
s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.
s = &quot;rat&quot;, t = &quot;car&quot;, return false.

class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size()) return false;
        int m[26] = {0};
        for (int i = 0; i &lt; s.size(); ++i) ++m[s[i] - &#39;a&#39;];
        for (int i = 0; i &lt; t.size(); ++i) {
            if (--m[t[i] - &#39;a&#39;] &lt; 0) return false;
        }
        return true;
    }
};
</code></pre>

<ul>
<li>leet_202</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Write an algorithm to determine if a number is &quot;happy&quot;.

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example: 

Input: 19
Output: true
Explanation: 
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
class Solution {
public:
    bool isHappy(int n) {
        while (n != 1 &amp;&amp; n != 4) {
            int sum = 0;
            while (n) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            n = sum;
        }
        return n == 1;
    }
};
</code></pre>

<ul>
<li>leet_290</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a pattern and a string str, find if str follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

Example 1:

Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;
Output: true
Example 2:

Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;
Output: false
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        unordered_map&lt;char, int&gt; m1;
        unordered_map&lt;string, int&gt; m2;
        istringstream in(str);
        int i = 0, n = pattern.size();
        for (string word; in &gt;&gt; word; ++i) {
            if (i == n || m1[pattern[i]] != m2[word]) return false;
            m1[pattern[i]] = m2[word] = i + 1;
        }
        return i == n;
    }
};
</code></pre>

<ul>
<li>leet_205</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given two strings  s  and  t , determine if they are isomorphic.

Two strings are isomorphic if the characters in  s  can be replaced to get  t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

Example 1:

Input: _s_ = &quot;egg&quot;, _t =_&quot;add&quot;
Output: true
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int m1[256] = {0}, m2[256] = {0}, n = s.size();
        for (int i = 0; i &lt; n; ++i) {
            if (m1[s[i]] != m2[t[i]]) return false;
            m1[s[i]] = i + 1;
            m2[t[i]] = i + 1;
        }
        return true;
    }
};
</code></pre>

<ul>
<li>leet_451</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Input:
&quot;tree&quot;

Output:
&quot;eert&quot;

Explanation:
&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.
So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.
class Solution {
public:
    string frequencySort(string s) {
        string res;
        vector&lt;string&gt; v(s.size() + 1);
        unordered_map&lt;char, int&gt; m;
        for (char c : s) ++m[c];
        for (auto &amp;a : m) {
            v[a.second].append(a.second, a.first);
        }
        for (int i = s.size(); i &gt; 0; --i) {
            if (!v[i].empty()) res.append(v[i]);
        }
        return res;
    }
};
</code></pre>

<h4>两数求和</h4>

<ul>
<li>leet_1 排序后,双索引对撞</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.count(target - nums[i])) {
                return {i, m[target - nums[i]]};
            }
            m[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>

<ul>
<li>leet_15</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array  S  of  n  integers, are there elements  a ,  b ,  c  in  S  such that  a  +  b  +  c  = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

Elements in a triplet ( a , b , c ) must be in non-descending order. (ie,  a  ≤  b  ≤  c )
The solution set must not contain duplicate triplets.
 

    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; res;
        sort(nums.begin(), nums.end());
        if (nums.empty() || nums.back() &lt; 0 || nums.front() &gt; 0) return {};
        for (int k = 0; k &lt; (int)nums.size() - 2; ++k) {
            if (nums[k] &gt; 0) break;
            if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue;
            int target = 0 - nums[k], i = k + 1, j = (int)nums.size() - 1;
            while (i &lt; j) {
                if (nums[i] + nums[j] == target) {
                    res.push_back({nums[k], nums[i], nums[j]});
                    while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) ++i;
                    while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j;
                    ++i; --j;
                } else if (nums[i] + nums[j] &lt; target) ++i;
                else --j;
            }
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_18</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array S of n integers, are there elements a , b , c , and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

Elements in a quadruplet ( a , b , c , d ) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d )

The solution set must not contain duplicate quadruplets.

For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt; &amp;nums, int target) {
        vector&lt;vector&lt;int&gt;&gt; res;
        int n = nums.size();
        sort(nums.begin(), nums.end());
        for (int i = 0; i &lt; n - 3; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j &lt; n - 2; ++j) {
                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;
                int left = j + 1, right = n - 1;
                while (left &lt; right) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        vector&lt;int&gt; out{nums[i], nums[j], nums[left], nums[right]};
                        res.push_back(out);
                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left;
                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right;
                        ++left; --right;
                    } else if (sum &lt; target) ++left;
                    else --right;
                }
            }
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_16</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given array nums = [-1, 2, 1, -4], and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        int closest = nums[0] + nums[1] + nums[2];
        int diff = abs(closest - target);
        sort(nums.begin(), nums.end());
        for (int i = 0; i &lt; nums.size() - 2; ++i) {
            int left = i + 1, right = nums.size() - 1;
            while (left &lt; right) {
                int sum = nums[i] + nums[left] + nums[right];
                int newDiff = abs(sum - target);
                if (diff &gt; newDiff) {
                    diff = newDiff;
                    closest = sum;
                }
                if (sum &lt; target) ++left;
                else --right;
            }
        }
        return closest;
    }
};
</code></pre>

<h4>动态规划</h4>

<ul>
<li>leet120 Triangle</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {
        vector&lt;int&gt; dp(triangle.back());
        for (int i = (int)triangle.size() - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt;= i; ++j) {
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j];
            }
        }
        return dp[0];
    }
};
</code></pre>

<ul>
<li>leet64 minium path sum</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) {
        int m = grid.size(), n = grid[0].size();
        int dp[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 1; i &lt; m; ++i) dp[i][0] = grid[i][0] + dp[i - 1][0];
        for (int i = 1; i &lt; n; ++i) dp[0][i] = grid[0][i] + dp[0][i - 1];
        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m - 1][n - 1];
    }
};
</code></pre>

<ul>
<li>leet343 integer break</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a positive integer  n , break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

Example 1:

Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
class Solution {
public:
    int integerBreak(int n) {
        vector&lt;int&gt; dp(n + 1, 1);
        for (int i = 3; i &lt;= n; ++i) {
            for (int j = 1; j &lt; i; ++j) {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
</code></pre>

<ul>
<li>leet279 perfect squares</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given a positive integer  n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to  n.

Example 1:

Input: _n_ = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: _n_ = 13
Output: 2
Explanation: 13 = 4 + 9.
class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i &lt;= n; ++i) {
            for (int j = 1; i + j * j &lt;= n; ++j) {
                dp[i + j * j] = min(dp[i + j * j], dp[i] + 1);
            }
        }
        return dp.back();
    }
};
</code></pre>

<ul>
<li>leet91 decode ways</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">A message containing letters from A-Z is being encoded to numbers using the following mapping:

&#39;A&#39; -&gt; 1
&#39;B&#39; -&gt; 2
...
&#39;Z&#39; -&gt; 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: &quot;12&quot;
Output: 2
Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).
，在遍历的过程中，对每个数字首先判断其是否为0，若是则将 dp[i] 赋为0，若不是，赋上 dp[i-1] 的值，然后看数组前一位是否存在，如果存在且满足前一位是1，或者和当前位一起组成的两位数不大于 26，则当前 dp[i] 值加上 dp[i - 2]。最终返回 dp 数组的最后一个值即可
dp[i] = dp[i-1] + dp[i-2]
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s[0] == &#39;0&#39;) return 0;
        vector&lt;int&gt; dp(s.size() + 1, 0);
        dp[0] = 1;
        for (int i = 1; i &lt; dp.size(); ++i) {
            if (s[i - 1] != &#39;0&#39;) dp[i] += dp[i - 1];
            if (i &gt;= 2 &amp;&amp; s.substr(i - 2, 2) &lt;= &quot;26&quot; &amp;&amp; s.substr(i - 2, 2) &gt;= &quot;10&quot;) {
                dp[i] += dp[i - 2];
            }
        }
        return dp.back();
    }
};
</code></pre>

<ul>
<li>leet62 unique path</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">A robot is located at the top-left corner of a  m  x  n  grid (marked &#39;Start&#39; in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).

How many possible unique paths are there?
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; dp(n, 1);
        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[j] += dp[j - 1]; 
            }
        }
        return dp[n - 1];
    }
};
````
* leet63 unique path

```C++
这里还需要初始化 dp 数组的某个值，使得其能正常累加。当起点不是障碍物时，其 dp 值应该为1，即dp[1][1] = 1，由于其是由 dp[0][1] + dp[1][0] 更新而来，所以二者中任意一个初始化为1即可。由于之后 LeetCode 更新了这道题的 test case，使得使用 int 型的 dp 数组会有溢出的错误，所以改为使用 long 型的数组来避免 overflow，代码如下
class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector&lt;vector&lt;long&gt;&gt; dp(m + 1, vector&lt;long&gt;(n + 1, 0));
        dp[0][1] = 1;
        for (int i = 1; i &lt;= m; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                if (obstacleGrid[i - 1][j - 1] != 0) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
};
class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector&lt;long&gt; dp(n, 0);
        dp[0] = 1;
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (obstacleGrid[i][j] == 1) dp[j] = 0;
                else if (j &gt; 0) dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
</code></pre>

<ul>
<li>leet673</li>
</ul>

<h4>查找</h4>

<ul>
<li>leet_350</li>
<li>leet_49</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array of strings, group anagrams together.

Example:

Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
Output:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        vector&lt;vector&lt;string&gt;&gt; res;
        unordered_map&lt;string, vector&lt;string&gt;&gt; m;
        for (string str : strs) {
            vector&lt;int&gt; cnt(26, 0);
            string t = &quot;&quot;;
            for (char c : str) ++cnt[c - &#39;a&#39;];
            for (int d : cnt) t += to_string(d) + &quot;/&quot;;
            m[t].push_back(str);
        }
        for (auto a : m) {
            res.push_back(a.second);
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_447 </li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given n points in the plane that are all pairwise distinct, a &quot;boomerang&quot; is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k ( the order of the tuple matters ).

Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).

Example:

**Input:**
[[0,0],[1,0],[2,0]]

**Output:**
2

**Explanation:**
The two boomerangs are **[[1,0],[0,0],[2,0]]** and **[[1,0],[2,0],[0,0]]**
class Solution {
public:
    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {
        int res = 0;
        for (int i = 0; i &lt; points.size(); ++i) {
            unordered_map&lt;int, int&gt; m;
            for (int j = 0; j &lt; points.size(); ++j) {
                int a = points[i].first - points[j].first;
                int b = points[i].second - points[j].second;
                ++m[a * a + b * b];
            }
            for (auto it = m.begin(); it != m.end(); ++it) {
                res += it-&gt;second * (it-&gt;second - 1);
            }
        }
        return res;
    }
};
</code></pre>

<ul>
<li>leet_149 点坐标的表示 整数 浮点数 </li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given  n  points on a 2D plane, find the maximum number of points that lie on the same straight line.

Example 1:

Input: [[1,1],[2,2],[3,3]]
Output: 3
Explanation:
^
|
|        o
|     o
|  o  
+-------------&gt;
0  1  2  3  4
class Solution {
public:
    int maxPoints(vector&lt;Point&gt;&amp; points) {
        int res = 0;
        for (int i = 0; i &lt; points.size(); ++i) {
            map&lt;pair&lt;int, int&gt;, int&gt; m;
            int duplicate = 1;
            for (int j = i + 1; j &lt; points.size(); ++j) {
                if (points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y) {
                    ++duplicate; continue;
                } 
                int dx = points[j].x - points[i].x;
                int dy = points[j].y - points[i].y;
                int d = gcd(dx, dy);
                ++m[{dx / d, dy / d}];
            }
            res = max(res, duplicate);
            for (auto it = m.begin(); it != m.end(); ++it) {
                res = max(res, it-&gt;second + duplicate);
            }
        }
        return res;
    }
    int gcd(int a, int b) {
        return (b == 0) ? a : gcd(b, a % b);
    }
};
</code></pre>

<h4>滑动窗口和查找</h4>

<ul>
<li>leet_217</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.find(nums[i]) != m.end()) return true;
            ++m[nums[i]];
        }
        return false;
    }
};
</code></pre>

<ul>
<li>leet_219</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array of integers and an integer k, return true if and only if there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. (Old Version)

Given an array of integers and an integer k , find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. (New Version)
class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.find(nums[i]) != m.end() &amp;&amp; i - m[nums[i]] &lt;= k) return true;
            else m[nums[i]] = i;
        }
        return false;
    }
};
</code></pre>

<ul>
<li>leet_220</li>
</ul>

<pre class="line-numbers"><code class="language-cpp">Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) {
      map&lt;long long, int&gt; m;
      int j = 0;
      for (int i = 0; i &lt; nums.size(); i++) {
        if (i - j &gt; k) m.erase(nums[j++]);
        auto a = m.lower_bound((long long)nums[i] - t);
        if (a != m.end() &amp;&amp; abs(a-&gt;first - nums[i]) &lt;= t) return true;
        m[nums[i]] = i;
      }
      return false;
    }
};
</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15649249729413.html" 
          title="Previous Post: 消费者组重平衡">&laquo; 消费者组重平衡</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15647094297065.html" 
          title="Next Post: 分治思想">分治思想 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>eredin-blog</h1>
                <div class="site-des">生命的意义是成为你自己！</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Prometheus.html"><strong>Prometheus</strong></a>
        
            <a href="RocketMQ.html"><strong>RocketMQ</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html"><strong>网络协议</strong></a>
        
            <a href="Golang.html"><strong>Golang</strong></a>
        
            <a href="Django.html"><strong>Django</strong></a>
        
            <a href="C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98.html"><strong>C++设计模式实战</strong></a>
        
            <a href="%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes.html"><strong>深入剖析Kubernetes</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html"><strong>数据结构和算法</strong></a>
        
            <a href="%E5%BE%AE%E6%9C%8D%E5%8A%A1.html"><strong>微服务</strong></a>
        
            <a href="%E6%9E%B6%E6%9E%84.html"><strong>架构</strong></a>
        
            <a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html"><strong>操作系统原理</strong></a>
        
            <a href="Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Mysql优化实战</strong></a>
        
            <a href="Kafka.html"><strong>Kafka</strong></a>
        
            <a href="linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A0%94%E5%8F%91.html"><strong>linux服务器研发</strong></a>
        
            <a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html"><strong>计算机组成原理</strong></a>
        
            <a href="%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB.html"><strong>程序员的自我修养</strong></a>
        
            <a href="C%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6.html"><strong>C语言进阶</strong></a>
        
            <a href="http_study.html"><strong>http_study</strong></a>
        
            <a href="%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html"><strong>玩转算法</strong></a>
        
            <a href="C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html"><strong>C++对象模型</strong></a>
        
            <a href="SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.html"><strong>SQL必知必会</strong></a>
        
            <a href="Zookeeper.html"><strong>Zookeeper</strong></a>
        
            <a href="Redis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html"><strong>Redis从入门到精通</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6.html"><strong>数据结构和算法进阶</strong></a>
        
            <a href="Mysql%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html"><strong>Mysql性能管理和架构设计</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html"><strong>网络编程实战</strong></a>
        
            <a href="Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98.html"><strong>Redis高并发缓存</strong></a>
        
            <a href="C++%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98.html"><strong>C++基础与提高</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html"><strong>设计模式之美</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
        
            <a href="Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html"><strong>Linux性能优化实战</strong></a>
        
            <a href="%E5%80%99%E6%8D%B7STL.html"><strong>候捷STL</strong></a>
        
            <a href="%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE.html"><strong>性能工程高手课</strong></a>
        
            <a href="%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html"><strong>性能测试</strong></a>
        
            <a href="ElasticSearch.html"><strong>ElasticSearch</strong></a>
        
            <a href="RabbitMQ.html"><strong>RabbitMQ</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15817610843879.html">编译期</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814649492497.html">Simple Factory</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814189410719.html">代码的可测试性</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15814188057978.html">重构</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813811739408.html">tuple 使用</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
