<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	玩转算法 -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-16T10:04:36+08:00" itemprop="datePublished">2019/08/16 10:04 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15659210764719.html" itemprop="url">
		链表</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8F%8D%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>反转</h4>
<ul>
<li>leet_206</li>
</ul>
<pre><code class="language-C++">Reverse a singly linked list.

Example:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
      ListNode* pre = nullptr;
      while (head) {
        ListNode* next = head-&gt;next;
        head-&gt;next= pre;
        pre = head;
        head = next;
      }
      return pre;
    }
};
</code></pre>
<ul>
<li>leet_92</li>
</ul>
<pre><code class="language-C++">Reverse a linked list from position m to n. Do it in one-pass.

Note: 1 ≤ m ≤ n ≤ length of list.

Example:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

static int x = []() {std::ios::sync_with_stdio(false); cin.tie(0); return 0; }();

class Solution 
{
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) 
    {
        if (head == nullptr || head-&gt;next == nullptr ||
            m &gt;= n || m &lt; 0 || n &lt; 0)
        {
            return head;
        }
        ListNode* h = new ListNode(-1);
        h-&gt;next = head;
        ListNode* pre = h;
        ListNode* cur = head;
        int i = 1;
        for (; i &lt; m &amp;&amp; cur != nullptr; ++i)
        {
            pre = cur;
            cur = cur-&gt;next;
        }
        ListNode* t1 = pre;
        ListNode* t2 = cur;
        for (; i &lt;= n &amp;&amp; cur != nullptr; ++i)
        {
            ListNode* lat = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = lat;
        }
        t1-&gt;next = pre;
        t2-&gt;next = cur;
        return h-&gt;next;
    }
};
</code></pre>
<ul>
<li>leet_83</li>
</ul>
<pre><code class="language-C++">Given a sorted linked list, delete all duplicates such that each element appear only  once.

Example 1:

Input: 1-&gt;1-&gt;2
Output: 1-&gt;2
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode *cur = head;
        while (cur &amp;&amp; cur-&gt;next) {
            if (cur-&gt;val == cur-&gt;next-&gt;val) {
                cur-&gt;next = cur-&gt;next-&gt;next;
            } else {
                cur = cur-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
<ul>
<li>leet_86</li>
</ul>
<pre><code class="language-C++">Given a linked list and a value  x , partition it such that all nodes less than  x  come before nodes greater than or equal to  x.

You should preserve the original relative order of the nodes in each of the two partitions.

For example,
Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and  x  = 3,
return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.
就是将所有小于给定值的节点取出组成一个新的链表，此时原链表中剩余的节点的值都大于或等于给定值，只要将原链表直接接在新链表后即可
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
      ListNode node1(0);
      ListNode node2(0);
      ListNode* p1 = &amp;node1;
      ListNode* p2 = &amp;node2;
      while (head) {
        if (head-&gt;val &lt; x) {
          p1-&gt;next = head;
          p1 = p1-&gt;next;
        } else {
          p2-&gt;next = head;
          p2 = p2-&gt;next;
        }
        head = head-&gt;next;
      }
      p2-&gt;next = nullptr;
      p1-&gt;next = node2.next;
      return node1.next;
    }
};
</code></pre>
<ul>
<li>leet_328</li>
</ul>
<pre><code class="language-C++">Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example 1:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL
func oddEvenList(head *ListNode) *ListNode {
	if head == nil {
		return head
	}
	
	odd := head
	evenHead := head.Next
	even := evenHead
	
	for even != nil &amp;&amp; even.Next != nil {
		odd.Next = even.Next
		odd = odd.Next
		even = odd.Next
		even = even.Next
	}
	odd.Next = evenHead
	return head
}
</code></pre>
<ul>
<li>leet_2</li>
</ul>
<pre><code class="language-C++">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
Explanation: 342 + 465 = 807.
class Solution {
public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode node(0), *p = &amp;node;
    int extra = 0;
    while (l1 || l2 || extra) {
      if (l1) extra += l1-&gt;val, l1 = l1-&gt;next;
      if (l2) extra += l2-&gt;val, l2 = l2-&gt;next;
      p-&gt;next = new ListNode(extra % 10);
      extra /= 10;
      p = p-&gt;next;
    }
    return node.next;

  }
};
</code></pre>
<ul>
<li>leet_445</li>
</ul>
<pre><code class="language-C++">Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

Example:

Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 8 -&gt; 0 -&gt; 7
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    stack&lt;int&gt; v1, v2;
    while (l1) v1.push(l1-&gt;val), l1 = l1-&gt;next;
    while (l2) v2.push(l2-&gt;val), l2 = l2-&gt;next;

    int extra = 0;

    ListNode dummy, *pre = nullptr;
    while (!v1.empty() || !v2.empty() || extra) {
        if (!v1.empty()) extra += v1.top(), v1.pop();
        if (!v2.empty()) extra += v2.top(), v2.pop();

        ListNode* p = new ListNode(extra % 10);
        extra /= 10;
        p-&gt;next = pre;
        pre = p;
    }
    return pre;
    }
};
</code></pre>
<h4><a id="%E8%AE%BE%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设立虚拟头节点</h4>
<ul>
<li>leet_203</li>
</ul>
<pre><code class="language-C++">Remove all elements from a linked list of integers that have value val.

Example
Given: 1 -- &gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6
Return: 1 -- &gt; 2 --&gt; 3 --&gt; 4 --&gt; 5
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) 
    {
        ListNode* h = new ListNode(-1);
        h-&gt;next = head;
        ListNode *cur = h;
        while (cur-&gt;next != nullptr)
        {
            ListNode* delNode = cur-&gt;next;
            if (delNode-&gt;val == val)
            {
                cur-&gt;next = delNode-&gt;next;
                delete delNode;
            }
            else
            {
                cur = cur-&gt;next;
            }
        }
        ListNode* retNode = h-&gt;next;
        delete h;
        return retNode;
    }
  };
</code></pre>
<ul>
<li>leet_82</li>
</ul>
<pre><code class="language-C++">class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head || !head-&gt;next) return head;
        ListNode *dummy = new ListNode(-1), *pre = dummy;
        dummy-&gt;next = head;
        while (pre-&gt;next) {
            ListNode *cur = pre-&gt;next;
            while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) {
                cur = cur-&gt;next;
            }
            if (cur != pre-&gt;next) pre-&gt;next = cur-&gt;next;
            else pre = pre-&gt;next;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<ul>
<li>leet_21</li>
</ul>
<pre><code class="language-C++">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
class Solution {
public:
  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

    ListNode node(0), *p = &amp;node;
    while (l1 &amp;&amp; l2) {
      if (l1-&gt;val &lt; l2-&gt;val) {
        p-&gt;next = l1;
        l1 = l1-&gt;next;
      } else {
        p-&gt;next = l2;
        l2 = l2-&gt;next;
      }
      p = p-&gt;next;
    }

    p-&gt;next = l1 ? l1 : l2;
    return node.next;
  }
};
</code></pre>
<ul>
<li>leet_25</li>
</ul>
<pre><code class="language-C++">Example:

Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5

For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5

For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
      ListNode dumy(0), *pre = &amp;dumy, *cur = &amp;dumy;
      dumy.next = head;
      int num = 0;
      while (cur = cur-&gt;next)  num++;
      while (num &gt;= k) {
        cur = pre-&gt;next;
        for (int i = 1; i &lt; k; i++) {
          ListNode* t = cur-&gt;next;
          cur-&gt;next = t-&gt;next;
          t-&gt;next = pre-&gt;next;
          pre-&gt;next = t;
        }
        pre = cur;
        num -= k;
      }
      return dumy.next;
    }
};
</code></pre>
<ul>
<li>leet_147</li>
</ul>
<pre><code class="language-C++">Sort a linked list using insertion sort.
Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode* dummy = new ListNode(0);
        dummy -&gt; next = head;
        ListNode *pre = dummy, *cur = head;
        while (cur) {
            if ((cur -&gt; next) &amp;&amp; (cur -&gt; next -&gt; val &lt; cur -&gt; val)) {
                while ((pre -&gt; next) &amp;&amp; (pre -&gt; next -&gt; val &lt; cur -&gt; next -&gt; val)) {
                    pre = pre -&gt; next;
                }
                ListNode* temp = pre -&gt; next;
                pre -&gt; next = cur -&gt; next;
                cur -&gt; next = cur -&gt; next -&gt; next;
                pre -&gt; next -&gt; next = temp;
                pre = dummy;
            }
            else {
                cur = cur -&gt; next;
            }
        }
        return dummy -&gt; next;
    }
};
</code></pre>
<ul>
<li>leet_148</li>
</ul>
<pre><code class="language-Go">Sort a linked list in  O ( n  log  n ) time using constant space complexity.

Example 1:

Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
Example 2:

Input: -1-&gt;5-&gt;3-&gt;4-&gt;0
Output: -1-&gt;0-&gt;3-&gt;4-&gt;5
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head-&gt;next) return head;
        ListNode *slow = head, *fast = head, *pre = head;
        while (fast &amp;&amp; fast-&gt;next) {
            pre = slow;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        pre-&gt;next = NULL;
        return merge(sortList(head), sortList(slow));
    }
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode *dummy = new ListNode(-1);
        ListNode *cur = dummy;
        while (l1 &amp;&amp; l2) {
            if (l1-&gt;val &lt; l2-&gt;val) {
                cur-&gt;next = l1;
                l1 = l1-&gt;next;
            } else {
                cur-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            cur = cur-&gt;next;
        }
        if (l1) cur-&gt;next = l1;
        if (l2) cur-&gt;next = l2;
        return dummy-&gt;next;
    }
};
</code></pre>
<ul>
<li>leet_237</li>
</ul>
<pre><code class="language-C++">Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        ListNode *tmp = node-&gt;next;
        node-&gt;next = tmp-&gt;next;
        delete tmp;
    }
};
</code></pre>
<h4><a id="%E5%8F%8C%E8%8A%82%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双节点</h4>
<ul>
<li>leet_61</li>
</ul>
<pre><code class="language-C++">Given a list, rotate the list to the right by  k  places, where  k  is non-negative.

For example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and  k  = 2,
return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.
class Solution {
public:
    ListNode *rotateRight(ListNode *head, int k) {
        if (!head) return NULL;
        int n = 0;
        ListNode *cur = head;
        while (cur) {
            ++n;
            cur = cur-&gt;next;
        }
        k %= n;
        ListNode *fast = head, *slow = head;
        for (int i = 0; i &lt; k; ++i) {
            if (fast) fast = fast-&gt;next;
        }
        if (!fast) return head;
        while (fast-&gt;next) {
            fast = fast-&gt;next;
            slow = slow-&gt;next;
        }
        fast-&gt;next = head;
        fast = slow-&gt;next;
        slow-&gt;next = NULL;
        return fast;
    }
};
</code></pre>
<ul>
<li>leet_143</li>
</ul>
<pre><code class="language-Go">Given a singly linked list  L :  L 0→ L 1→…→ L n -1→ L n,
reorder it to:  L 0→ L n → L 1→ L n -1→ L 2→ L n -2→…

You may not modify the values in the list's nodes, only nodes itself may be changed.

Example 1:

Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.
Example 2:

Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.
func middleNode(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast.Next != nil &amp;&amp; fast.Next.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
	}
	return slow
}

func reverse(head *ListNode) *ListNode {
	var pre *ListNode = nil
	for head != nil {
		next := head.Next
		head.Next = pre
		pre = head
		head = next
	}
	return pre
}

func mergeList(l1, l2 *ListNode){
	var p1, p2 *ListNode
	for l1 != nil &amp;&amp; l2 != nil {
		p1 = l1.Next
		p2 = l2.Next

		l1.Next = l2
		l1 = p1
		l2.Next = l1
		l2 = p2
	}
}
func reorderList(head *ListNode) {
	if head == nil {
		return
	}
	mid := middleNode(head)
	l1 := head
	l2 := mid.Next
	mid.Next = nil
	l2 = reverse(l2)
	mergeList(l1, l2)
}
</code></pre>
<ul>
<li>leet_234</li>
</ul>
<pre><code class="language-C++">Given a singly linked list, determine if it is a palindrome.

Example 1:

Input: 1-&gt;2
Output: false
Example 2:

Input: 1-&gt;2-&gt;2-&gt;1
Output: true
class Solution {
  public:
  ListNode* reverse(ListNode* head) {
    ListNode* pre = nullptr, *next = nullptr;

    while (head) {
      next = head-&gt;next;
      head-&gt;next = pre;
      pre = head;
      head = next;
    }

    return pre;
  }

  bool isPalindrome(ListNode* head) {
    if (!head || !head-&gt;next) return true;
    
    ListNode* fast = head, *slow = head;
    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {
      slow = slow-&gt;next;
      fast = fast-&gt;next-&gt;next;
    }

    ListNode* mid = slow-&gt;next;
    ListNode* rhead = reverse(mid);
    while (rhead) {
      if (rhead-&gt;val != head-&gt;val) return false;
      rhead = rhead-&gt;next;
      head = head-&gt;next;
    }
    return true;
  }
};
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-12T09:24:24+08:00" itemprop="datePublished">2019/09/12 09:24 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15682514641307.html" itemprop="url">
		贪心算法</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h4>
<ul>
<li>leet_455</li>
<li><img src="media/15682514641307/15682518263627.jpg" alt="" style="width:614px;" /></li>
<li>leet_392</li>
</ul>
<h4><a id="%E8%B4%AA%E5%BF%83%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>贪心和动态规划</h4>
<ul>
<li>leet_435</li>
<li><img src="media/15682514641307/15682540246962.jpg" alt="" style="width:939px;" /></li>
</ul>
<h4><a id="%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E6%80%A7%E8%B4%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>贪心选择性质</h4>
<ul>
<li>如果无法使用贪心算法，举出反例</li>
<li>如何证明贪心算法的正确性</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-30T10:17:38+08:00" itemprop="datePublished">2019/08/30 10:17 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15671314584110.html" itemprop="url">
		递归和回溯</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A0%91%E5%BD%A2%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>树形问题</h4>
<ul>
<li>leet_17  O(2^n)</li>
</ul>
<pre><code class="language-plain_text">Input: &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
class Solution {
public:
    vector&lt;string&gt; letterCombinations(string digits) {
        if (digits.empty()) return {};
        vector&lt;string&gt; res;
        vector&lt;string&gt; dict{&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
        letterCombinationsDFS(digits, dict, 0, &quot;&quot;, res);
        return res;
    }
    void letterCombinationsDFS(string&amp; digits, vector&lt;string&gt;&amp; dict, int level, string out, vector&lt;string&gt;&amp; res) {
        if (level == digits.size()) {res.push_back(out); return;}
        string str = dict[digits[level] - '0'];
        for (int i = 0; i &lt; str.size(); ++i) {
            letterCombinationsDFS(digits, dict, level + 1, out + str[i], res);
        }
    }
}; 
</code></pre>
<ul>
<li>字符串合法性 空字符串 多个解的顺序</li>
<li>s(d[0..n-1]) = letter(d[0]) + s(d[1...n-1])</li>
<li>leet_93</li>
</ul>
<pre><code class="language-plain_text">Input: &quot;25525511135&quot;
Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]
class Solution {
public:
    vector&lt;string&gt; restoreIpAddresses(string s) {
        vector&lt;string&gt; res;
        restore(s, 4, &quot;&quot;, res);
        return res;
    }
    void restore(string s, int k, string out, vector&lt;string&gt; &amp;res) {
        if (k == 0) {
            if (s.empty()) res.push_back(out);
        }
        else {
            for (int i = 1; i &lt;= 3; ++i) {
                if (s.size() &gt;= i &amp;&amp; isValid(s.substr(0, i))) {
                    if (k == 1) restore(s.substr(i), k - 1, out + s.substr(0, i), res);
                    else restore(s.substr(i), k - 1, out + s.substr(0, i) + &quot;.&quot;, res);
                }
            }
        }
    }
    bool isValid(string s) {
        if (s.empty() || s.size() &gt; 3 || (s.size() &gt; 1 &amp;&amp; s[0] == '0')) return false;
        int res = atoi(s.c_str());
        return res &lt;= 255 &amp;&amp; res &gt;= 0;
    }
};
</code></pre>
<ul>
<li>leet_131</li>
</ul>
<pre><code class="language-plain_text">Input: &quot;aab&quot;
Output:
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]

class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        vector&lt;vector&lt;string&gt;&gt; res;
        vector&lt;string&gt; out;
        helper(s, 0, out, res);
        return res;
    }
    void helper(string s, int start, vector&lt;string&gt;&amp; out, vector&lt;vector&lt;string&gt;&gt;&amp; res) {
        if (start == s.size()) { res.push_back(out); return; }
        for (int i = start; i &lt; s.size(); ++i) {
            if (!isPalindrome(s, start, i)) continue;
            out.push_back(s.substr(start, i - start + 1));
            helper(s, i + 1, out, res);
            out.pop_back();
        }
    }
    bool isPalindrome(string s, int start, int end) {
        while (start &lt; end) {
            if (s[start] != s[end]) return false;
            ++start; --end;
        }
        return true;
    }
};
</code></pre>
<h4><a id="%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>回溯算法</h4>
<ul>
<li>排列leet_46 perm(0...n-1) = num +perm(0...n-1 - 这个数字)</li>
</ul>
<pre><code class="language-plain_text">Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
class Solution {
public:
  vector&lt;vector&lt;int&gt;&gt; res;
  vector&lt;bool&gt; used = {false};

  void generatPermutation(const vector&lt;int&gt;&amp; nums, int index, vector&lt;int&gt;&amp; p) {
    if (index == nums.size()) {
      res.push_back(p);
      return;
    }

    for (int i = 0; i &lt; nums.size(); i++) {
      if (!used[i]) {
        p.push_back(nums[i]);
        used[i] = true;
        generatPermutation(nums, index + 1, p);
        p.pop_back();
        used[i] = false;
      }
    }
    return;
  }

  vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0)
      return res;

    used = vector&lt;bool&gt;(nums.size(), false);
    vector&lt;int&gt; p;
    generatPermutation(nums, 0, p);
    return res;
  } 
};
</code></pre>
<ul>
<li>leet_47</li>
</ul>
<pre><code class="language-plain_text">Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
class Solution {
public:
  
  vector&lt;vector&lt;int&gt;&gt; res;
  vector&lt;bool&gt; used;
  void generatPermutation(const vector&lt;int&gt;&amp; nums, int index, vector&lt;int&gt;&amp; p) {
    if (index == nums.size()) {
      res.push_back(p);
      return;
    }

    for (int i = 0; i &lt; nums.size(); i++) {
      if(i &gt; 0 &amp;&amp; nums[i-1] == nums[i] &amp;&amp; !used[i-1])
        continue;

      if (!used[i]) {
        p.push_back(nums[i]);
        used[i] = true;
        generatPermutation(nums, index + 1, p);
        p.pop_back();
        used[i] = false;
      }
    }
    return;
  }

  vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
    if (nums.size() == 0)
      return res;

    used = vector&lt;bool&gt;(nums.size(), false);
    vector&lt;int&gt; p;
    sort(nums.begin(), nums.end());
    generatPermutation(nums, 0, p);
    return res;
  }
};
</code></pre>
<h4><a id="%E7%BB%84%E5%90%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组合</h4>
<ul>
<li>leet_77</li>
</ul>
<pre><code class="language-plain_text">For example,
If  n  = 4 and  k  = 2, a solution is:

[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; out;
        helper(n, k, 1, out, res);
        return res;
    }
    void helper(int n, int k, int level, vector&lt;int&gt;&amp; out, vector&lt;vector&lt;int&gt;&gt;&amp; res) {
        if (out.size() == k) {res.push_back(out); return;}
        for (int i = level; i &lt;= n; ++i) {
            out.push_back(i);
            helper(n, k, i + 1, out, res);
            out.pop_back();
        }
    }
};
</code></pre>
<ul>
<li>leet_39</li>
</ul>
<pre><code class="language-plain_text">Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
//重复元素i层级不加1
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; out;
        combinationSumDFS(candidates, target, 0, out, res);
        return res;
    }
    void combinationSumDFS(vector&lt;int&gt;&amp; candidates, int target, int start, vector&lt;int&gt;&amp; out, vector&lt;vector&lt;int&gt;&gt;&amp; res) {
        if (target &lt; 0) return;
        if (target == 0) {res.push_back(out); return;}
        for (int i = start; i &lt; candidates.size(); ++i) {
            out.push_back(candidates[i]);
            combinationSumDFS(candidates, target - candidates[i], i, out, res);
            //重复元素i层级不加1
            out.pop_back();
        }
    }
};
</code></pre>
<ul>
<li>leet_40</li>
</ul>
<pre><code class="language-plain_text">For example, given candidate set 10,1,2,7,6,1,5 and target 8, 
A solution set is: 
[1, 7] 
[1, 2, 5] 
[2, 6] 
[1, 1, 6] 

class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) {
        vector&lt;vector&lt;int&gt; &gt; res;
        vector&lt;int&gt; out;
        sort(num.begin(), num.end());
        combinationSum2DFS(num, target, 0, out, res);
        return res;
    }
    void combinationSum2DFS(vector&lt;int&gt; &amp;num, int target, int start, vector&lt;int&gt; &amp;out, vector&lt;vector&lt;int&gt; &gt; &amp;res) {
        if (target &lt; 0) return;
        else if (target == 0) res.push_back(out);
        else {
            for (int i = start; i &lt; num.size(); ++i) {
                //可以去除组合中的重复元素
                if (i &gt; start &amp;&amp; num[i] == num[i - 1]) continue;
                out.push_back(num[i]);
                combinationSum2DFS(num, target - num[i], i + 1, out, res);
                //不重复使用元素，所以层级+1
                out.pop_back();
            }
        }
    }
};
</code></pre>
<ul>
<li>leet_216</li>
</ul>
<pre><code class="language-plain_text">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; combinationSum3(int k, int n) {
        vector&lt;vector&lt;int&gt; &gt; res;
        vector&lt;int&gt; out;
        combinationSum3DFS(k, n, 1, out, res);
        return res;
    }
    void combinationSum3DFS(int k, int n, int level, vector&lt;int&gt; &amp;out, vector&lt;vector&lt;int&gt; &gt; &amp;res) {
        if (n &lt; 0) return;
        if (n == 0 &amp;&amp; out.size() == k) res.push_back(out);
        for (int i = level; i &lt;= 9; ++i) {
            out.push_back(i);
            combinationSum3DFS(k, n - i, i + 1, out, res);
            out.pop_back();
        }
    }
};
</code></pre>
<ul>
<li>leet_78</li>
</ul>
<pre><code class="language-plain_text">If  S  = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) {
        vector&lt;vector&lt;int&gt; &gt; res;
        vector&lt;int&gt; out;
        sort(S.begin(), S.end());
        getSubsets(S, 0, out, res);
        return res;
    }
    void getSubsets(vector&lt;int&gt; &amp;S, int pos, vector&lt;int&gt; &amp;out, vector&lt;vector&lt;int&gt; &gt; &amp;res) {
       //没有条件和外加边界限制
        res.push_back(out);
        for (int i = pos; i &lt; S.size(); ++i) {
            out.push_back(S[i]);
            getSubsets(S, i + 1, out, res);
            out.pop_back();
        }
    }
};

</code></pre>
<ul>
<li>leet_90</li>
</ul>
<pre><code class="language-plain_text">For example,
If  S  = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt; &amp;S) {
        if (S.empty()) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; out;
        sort(S.begin(), S.end());
        getSubsets(S, 0, out, res);
        return res;
    }
    void getSubsets(vector&lt;int&gt; &amp;S, int pos, vector&lt;int&gt; &amp;out, vector&lt;vector&lt;int&gt;&gt; &amp;res) {
        res.push_back(out);
        for (int i = pos; i &lt; S.size(); ++i) {
            if (i &gt; pos &amp;&amp; S[i] == S[i-1]) continue;
            out.push_back(S[i]);
            getSubsets(S, i + 1, out, res);
            out.pop_back();
        }
    }
};
</code></pre>
<ul>
<li>leet_401</li>
</ul>
<pre><code class="language-plain_text">Input: n = 1
Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]

class Solution {
  public:
  vector&lt;string&gt; res;

  void helper(vector&lt;int&gt;&amp; chart,int&amp;num,int curr,int idx,int hour,int min){
    if(hour&gt;11||min&gt;59) return;
    if(curr==num){
      string tmp=to_string(hour)+&quot;:&quot;+((min&lt;10)?&quot;0&quot;:&quot;&quot;)+to_string(min);
      res.push_back(tmp);
      return;
    }
    for(int i=idx;i&lt;chart.size();i++){
      if(i&lt;4)
        helper(chart,num,curr+1,i+1,hour+chart[i],min);
      else
        helper(chart,num,curr+1,i+1,hour,min+chart[i]);
    }
  }

  vector&lt;string&gt; readBinaryWatch(int num) {
    vector&lt;int&gt; chart({1,2,4,8,1,2,4,8,16,32});
    helper(chart,num,0,0,0,0);
    return res;
  }

};
</code></pre>
<h4><a id="%E4%BA%8C%E7%BB%B4%E5%B9%B3%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二维平面</h4>
<ul>
<li>leet_79</li>
</ul>
<pre><code class="language-plain_text">or example,
Given board =
[
  [&quot;ABCE&quot;],
  [&quot;SFCS&quot;],
  [&quot;ADEE&quot;]
]
word = &quot;ABCCED&quot;, -&gt; returns true,
word = &quot;SEE&quot;, -&gt; returns true,
word = &quot;ABCB&quot;, -&gt; returns false.
class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        if (board.empty() || board[0].empty()) return false;
        int m = board.size(), n = board[0].size();
        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n));
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (search(board, word, 0, i, j, visited)) return true;
            }
        }
        return false;
    }
    bool search(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int idx, int i, int j, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) {
        if (idx == word.size()) return true;
        int m = board.size(), n = board[0].size();
        if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n || visited[i][j] || board[i][j] != word[idx]) return false;
        visited[i][j] = true;
        bool res = search(board, word, idx + 1, i - 1, j, visited) 
                 || search(board, word, idx + 1, i + 1, j, visited)
                 || search(board, word, idx + 1, i, j - 1, visited)
                 || search(board, word, idx + 1, i, j + 1, visited);
        visited[i][j] = false;
        return res;
    }
};
</code></pre>
<ul>
<li>leet_200</li>
</ul>
<pre><code class="language-plain_text">class Solution {
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        if (grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size(), res = 0;
        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n));
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == '1' &amp;&amp; !visited[i][j]) 
                helper(grid, visited, i, j);
                ++res;
            }
        }
        return res;
    }
    void helper(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) {
        if (x &lt; 0 || x &gt;= grid.size() || y &lt; 0 || y &gt;= grid[0].size() || grid[x][y] == '0' || visited[x][y]) return;
        visited[x][y] = true;
        helper(grid, visited, x - 1, y);
        helper(grid, visited, x + 1, y);
        helper(grid, visited, x, y - 1);
        helper(grid, visited, x, y + 1);
    }
};
</code></pre>
<ul>
<li>leet_130</li>
</ul>
<pre><code class="language-plain_text">Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X

class Solution {
public:
    void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) {
        for (int i = 0; i &lt; board.size(); ++i) {
            for (int j = 0; j &lt; board[i].size(); ++j) {
                if ((i == 0 || i == board.size() - 1 || j == 0 || j == board[i].size() - 1) &amp;&amp; board[i][j] == 'O')
                    solveDFS(board, i, j);
            }
        }
        for (int i = 0; i &lt; board.size(); ++i) {
            for (int j = 0; j &lt; board[i].size(); ++j) {
                if (board[i][j] == 'O') board[i][j] = 'X';
                if (board[i][j] == '$') board[i][j] = 'O';
            }
        }
    }
    void solveDFS(vector&lt;vector&lt;char&gt; &gt; &amp;board, int i, int j) {
        if (board[i][j] == 'O') {
            board[i][j] = '$';
            if (i &gt; 0 &amp;&amp; board[i - 1][j] == 'O') 
                solveDFS(board, i - 1, j);
            if (j &lt; board[i].size() - 1 &amp;&amp; board[i][j + 1] == 'O') 
                solveDFS(board, i, j + 1);
            if (i &lt; board.size() - 1 &amp;&amp; board[i + 1][j] == 'O') 
                solveDFS(board, i + 1, j);
            if (j &gt; 0 &amp;&amp; board[i][j - 1] == 'O') 
                solveDFS(board, i, j - 1);
        }
    }
};
</code></pre>
<ul>
<li>leet_417</li>
</ul>
<pre><code class="language-plain_text">Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic
class Solution {
public:
    vector&lt;pair&lt;int, int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        if (matrix.empty() || matrix[0].empty()) return {};
        vector&lt;pair&lt;int, int&gt;&gt; res;
        int m = matrix.size(), n = matrix[0].size();
        vector&lt;vector&lt;bool&gt;&gt; pacific(m, vector&lt;bool&gt;(n, false));
        vector&lt;vector&lt;bool&gt;&gt; atlantic(m, vector&lt;bool&gt;(n, false));
        for (int i = 0; i &lt; m; ++i) {
            dfs(matrix, pacific, INT_MIN, i, 0);
            dfs(matrix, atlantic, INT_MIN, i, n - 1);
        }
        for (int i = 0; i &lt; n; ++i) {
            dfs(matrix, pacific, INT_MIN, 0, i);
            dfs(matrix, atlantic, INT_MIN, m - 1, i);
        }
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (pacific[i][j] &amp;&amp; atlantic[i][j]) {
                    res.push_back({i, j});
                }
            }
        }
        return res;
    }
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int pre, int i, int j) {
        int m = matrix.size(), n = matrix[0].size();
        if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || visited[i][j] || matrix[i][j] &lt; pre) return;
        visited[i][j] = true;
        dfs(matrix, visited, matrix[i][j], i + 1, j);
        dfs(matrix, visited, matrix[i][j], i - 1, j);
        dfs(matrix, visited, matrix[i][j], i, j + 1);
        dfs(matrix, visited, matrix[i][j], i, j - 1);
    }
};
</code></pre>
<h4><a id="%E5%9B%9E%E6%BA%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>回溯</h4>
<ul>
<li>是人工智能的基础</li>
<li>leet_51<br />
<img src="media/15671314584110/15700743532592.jpg" alt="" style="width:1021px;" /><br />
<img src="media/15671314584110/15700743705081.jpg" alt="" style="width:1115px;" /></li>
</ul>
<pre><code class="language-plain_text">class Solution {
  public:
  vector&lt;vector&lt;string&gt;&gt; res;
  vector&lt;bool&gt; col, dia1, dia2;

  vector&lt;string&gt; generateBoard(int n, vector&lt;int&gt;&amp; row) {
    assert(row.size() == n);
    vector&lt;string&gt; board(n, string(n, '.'));
    for (int i = 0; i &lt; n; i++)
      board[i][row[i]] = 'Q';
    return board;
  }
  
  void putQueen(int n, int index, vector&lt;int&gt;&amp; row) {

    if (index == n) {
      res.push_back(generateBoard(n, row));
      return;
    }

    for (int i = 0; i &lt; n; i++)
      if (!col[i] &amp;&amp; !dia1[index+i] &amp;&amp; !dia2[index-i+n-1]) {
        row.push_back(i);
        col[i] = dia1[index+i] = dia2[index-i+n-1] = true;
        putQueen(n, index + 1, row);
        col[i] = dia1[index+i] = dia2[index-i+n-1] = false;
        row.pop_back();
      }
  }

  vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
    res.clear();

    col = vector&lt;bool&gt;(n, false);
    dia1 = vector&lt;bool&gt;(2 * n - 1, false);
    dia2 = vector&lt;bool&gt;(2 * n - 1, false);
    vector&lt;int&gt; row;
    putQueen(n, 0, row);
    return res;
  }
};
</code></pre>
<ul>
<li>leet_52</li>
</ul>
<pre><code class="language-plain_text">class Solution {
  public:
  vector&lt;bool&gt; col, dia1, dia2;
  
  int count = 0;
  //n皇后摆放在index行的皇后位置
  void putQueen(int n, int index, vector&lt;int&gt;&amp; row) {

    if (index == n) {
      count ++;
      return;
    }

    for (int i = 0; i &lt; n; i++)
      if (!col[i] &amp;&amp; !dia1[index+i] &amp;&amp; !dia2[index-i+n-1]) {
        row.push_back(i);
        col[i] = dia1[index+i] = dia2[index-i+n-1] = true;
        putQueen(n, index + 1, row);
        col[i] = dia1[index+i] = dia2[index-i+n-1] = false;
        row.pop_back();
      }
  }

  int totalNQueens(int n) {
    col = vector&lt;bool&gt;(n, false);
    dia1 = vector&lt;bool&gt;(2 * n - 1, false);
    dia2 = vector&lt;bool&gt;(2 * n - 1, false);
    vector&lt;int&gt; row;
    putQueen(n, 0, row);
    return count;
  }
};
</code></pre>
<ul>
<li>leet_37</li>
</ul>
<pre><code class="language-plain_text">class Solution {
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        helper(board, 0, 0);
    }
    bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j) {
        if (i == 9) return true;
        if (j &gt;= 9) return helper(board, i + 1, 0);
        if (board[i][j] != '.') return helper(board, i, j + 1);
        for (char c = '1'; c &lt;= '9'; ++c) {
            if (!isValid(board, i , j, c)) continue;
            board[i][j] = c;
            if (helper(board, i, j + 1)) return true;
            board[i][j] = '.';
        }
        return false;
    }
    bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, char val) {
        for (int x = 0; x &lt; 9; ++x) {
            if (board[x][j] == val) return false;
        }
        for (int y = 0; y &lt; 9; ++y) {
            if (board[i][y] == val) return false;
        }
        int row = i - i % 3, col = j - j % 3;
        for (int x = 0; x &lt; 3; ++x) {
            for (int y = 0; y &lt; 3; ++y) {
                if (board[x + row][y + col] == val) return false;
            }
        }
        return true;
    }
};
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-23T10:40:44+08:00" itemprop="datePublished">2019/08/23 10:40 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15665280444092.html" itemprop="url">
		二叉树和递归</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%A4%A9%E7%84%B6%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>天然递归结构</h4>
<ul>
<li>空也是一棵二叉树</li>
<li>是否存在键值</li>
</ul>
<pre><code class="language-C++">bool contain(Node8 node, Key key) {
  if (!node) return false;
  
  if (key == node-&gt;key) return true;
  
  if(contain(node-&gt;left, key) ||
     contain(node-&gt;right, key)) return true;
  return false;
}
</code></pre>
<ul>
<li>leet_104</li>
</ul>
<pre><code class="language-C++">class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));
    }
};
</code></pre>
<ul>
<li>leet_111</li>
</ul>
<pre><code class="language-C++">Given a binary tree, find its minimum depth.
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        if (!root-&gt;left) return 1 + minDepth(root-&gt;right);
        if (!root-&gt;right) return 1 + minDepth(root-&gt;left);
        return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right));
    }
};
</code></pre>
<ul>
<li>leet_226</li>
</ul>
<pre><code class="language-C++">Invert a binary tree.

     4
   /   \
  2     7
 / \   / \
1   3 6   9

to
     4
   /   \
  7     2
 / \   / \
9   6 3   1

// Recursion
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) return NULL;
        TreeNode *tmp = root-&gt;left;
        root-&gt;left = invertTree(root-&gt;right);
        root-&gt;right = invertTree(tmp);
        return root;
    }
};

// Non-Recursion
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) return NULL;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while (!q.empty()) {
            TreeNode *node = q.front(); q.pop();
            TreeNode *tmp = node-&gt;left;
            node-&gt;left = node-&gt;right;
            node-&gt;right = tmp;
            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }
        return root;
    }
};
</code></pre>
<ul>
<li>leet_100</li>
</ul>
<pre><code class="language-C++">判断两棵树是否相同
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if (!p &amp;&amp; !q) return true;
        if ((p &amp;&amp; !q) || (!p &amp;&amp; q) || (p-&gt;val != q-&gt;val)) return false;
        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
    }
};
</code></pre>
<ul>
<li>leet_101</li>
</ul>
<pre><code class="language-C++">Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3

class Solution {
public:
    bool isSymmetric(TreeNode *root) {
        if (!root) return true;
        return isSymmetric(root-&gt;left, root-&gt;right);
    }
    bool isSymmetric(TreeNode *left, TreeNode *right) {
        if (!left &amp;&amp; !right) return true;
        if (left &amp;&amp; !right || !left &amp;&amp; right || left-&gt;val != right-&gt;val) return false;
        return isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left);
    }
    
};
</code></pre>
<ul>
<li>leet_222</li>
</ul>
<pre><code class="language-C++">Given a complete binary tree, count the number of nodes.
Input: 
    1
   / \
  2   3
 / \  /
4  5 6

Output: 6
由 root 根结点往下，分别找最靠左边和最靠右边的路径长度，如果长度相等，则证明二叉树最后一层节点是满的，是满二叉树，直接返回节点个数，如果不相等，则节点个数为左子树的节点个数加上右子树的节点个数再加1(根节点)，

class Solution {
public:
    int countNodes(TreeNode* root) {
        int hLeft = leftHeight(root);
        int hRight = rightHeight(root);
        if (hLeft == hRight) return pow(2, hLeft) - 1;
        return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;
    }
    int leftHeight(TreeNode* root) {
        if (!root) return 0;
        return 1 + leftHeight(root-&gt;left);
    }
    int rightHeight(TreeNode* root) {
        if (!root) return 0;
        return 1 + rightHeight(root-&gt;right);
    }
};

class Solution {
public:
    int countNodes(TreeNode* root) {
        int res = 0, h = getHeight(root);
        if (h &lt; 0) return 0;
        if (getHeight(root-&gt;right) == h - 1) return (1 &lt;&lt; h) + countNodes(root-&gt;right);
        return (1 &lt;&lt; (h - 1)) + countNodes(root-&gt;left);
    }
    int getHeight(TreeNode* node) {
        return node ? (1 + getHeight(node-&gt;left)) : -1;
    }
};
</code></pre>
<ul>
<li>leet_110</li>
</ul>
<pre><code class="language-C++">Given a binary tree, determine if it is height-balanced.
class Solution {
public:    
    bool isBalanced(TreeNode *root) {
        if (checkDepth(root) == -1) return false;
        else return true;
    }
    int checkDepth(TreeNode *root) {
        if (!root) return 0;
        int left = checkDepth(root-&gt;left);
        if (left == -1) return -1;
        int right = checkDepth(root-&gt;right);
        if (right == -1) return -1;
        int diff = abs(left - right);
        if (diff &gt; 1) return -1;
        else return 1 + max(left, right);
    }
};
</code></pre>
<ul>
<li>leet_112</li>
</ul>
<pre><code class="language-C++">Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1

class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (!root) return false;
        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == sum ) return true;
        return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);
    }
};
</code></pre>
<ul>
<li>leet_111</li>
</ul>
<pre><code class="language-C++">Given a binary tree, find its minimum depth.
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        if (!root-&gt;left) return 1 + minDepth(root-&gt;right);
        if (!root-&gt;right) return 1 + minDepth(root-&gt;left);
        return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right));
    }
};
</code></pre>
<ul>
<li>leet_404</li>
</ul>
<pre><code class="language-C++">Find the sum of all left leaves in a given binary tree.
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return 0;
        int res = 0;
        helper(root-&gt;left, true, res);
        helper(root-&gt;right, false, res);
        return res;
    }
    void helper(TreeNode* node, bool left, int&amp; res) {
        if (!node) return;
        if (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; left) res += node-&gt;val;
        helper(node-&gt;left, true, res);
        helper(node-&gt;right, false, res);
    }
};

class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return 0;
        int res = 0;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while (!q.empty()) {
            TreeNode *t = q.front(); q.pop();
            if (t-&gt;left &amp;&amp; !t-&gt;left-&gt;left &amp;&amp; !t-&gt;left-&gt;right) res += t-&gt;left-&gt;val;
            if (t-&gt;left) q.push(t-&gt;left);
            if (t-&gt;right) q.push(t-&gt;right);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_257</li>
</ul>
<pre><code class="language-C++">For example, given the following binary tree:
   1
 /   \
2     3
 \
  5
All root-to-leaf paths are:
[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

class Solution {
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
        vector&lt;string&gt; res;
        if (root) helper(root, &quot;&quot;, res);
        return res;
    }
    void helper(TreeNode* node, string out, vector&lt;string&gt;&amp; res) {
        if (!node-&gt;left &amp;&amp; !node-&gt;right) res.push_back(out + to_string(node-&gt;val));
        if (node-&gt;left) helper(node-&gt;left, out + to_string(node-&gt;val) + &quot;-&gt;&quot;, res);
        if (node-&gt;right) helper(node-&gt;right, out + to_string(node-&gt;val) + &quot;-&gt;&quot;, res);
    }
};
</code></pre>
<ul>
<li>leet_113</li>
</ul>
<pre><code class="language-C++">For example:
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
return
[
   [5,4,11,2],
   [5,8,4,5]
]

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; out;
        helper(root, sum, out, res);
        return res;
    }
    void helper(TreeNode* node, int sum, vector&lt;int&gt;&amp; out, vector&lt;vector&lt;int&gt;&gt;&amp; res) {
        if (!node) return;
        out.push_back(node-&gt;val);
        if (sum == node-&gt;val &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right) {
            res.push_back(out);
        }
        helper(node-&gt;left, sum - node-&gt;val, out, res);
        helper(node-&gt;right, sum - node-&gt;val, out, res);
        out.pop_back();
    }
};
</code></pre>
<ul>
<li>leet_129</li>
</ul>
<pre><code class="language-C++">Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1-&gt;2 represents the number 12.
The root-to-leaf path 1-&gt;3 represents the number 13.
Therefore, sum = 12 + 13 = 25.

class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return sumNumbersDFS(root, 0);
    }
    int sumNumbersDFS(TreeNode* root, int sum) {
        if (!root) return 0;
        sum = sum * 10 + root-&gt;val;
        if (!root-&gt;left &amp;&amp; !root-&gt;right) return sum;
        return sumNumbersDFS(root-&gt;left, sum) + sumNumbersDFS(root-&gt;right, sum);
    }
};
</code></pre>
<h4><a id="%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二分搜索树</h4>
<ul>
<li>leet_235</li>
</ul>
<pre><code class="language-C++">class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root) return NULL;
        if (root-&gt;val &gt; max(p-&gt;val, q-&gt;val)) 
            return lowestCommonAncestor(root-&gt;left, p, q);
        else if (root-&gt;val &lt; min(p-&gt;val, q-&gt;val)) 
            return lowestCommonAncestor(root-&gt;right, p, q);
        else return root;
    }
};
</code></pre>
<ul>
<li>leet_98</li>
</ul>
<pre><code class="language-C++">Given a binary tree, determine if it is a valid binary search tree (BST).

class Solution {
public:
  bool isValidBST(TreeNode* root) {
    return isValidBST(root, nullptr, nullptr);
  }

  bool isValidBST(TreeNode* root, TreeNode* min, TreeNode* max) {
    if (!root) return true;

    if (min &amp;&amp; min-&gt;val &gt;= root-&gt;val || max &amp;&amp; max-&gt;val &lt;= root-&gt;val)
      return false;

    return isValidBST(root-&gt;left, min, root) &amp;&amp; isValidBST(root-&gt;right, root, max);
  } 
};
</code></pre>
<ul>
<li>leet_450</li>
</ul>
<pre><code class="language-C++">root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the following BST.

    5
   / \
  4   6
 /     \
2       7

class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root) return NULL;
        if (root-&gt;val &gt; key) {
            root-&gt;left = deleteNode(root-&gt;left, key);
        } else if (root-&gt;val &lt; key) {
            root-&gt;right = deleteNode(root-&gt;right, key);
        } else {
            if (!root-&gt;left || !root-&gt;right) {
                root = (root-&gt;left) ? root-&gt;left : root-&gt;right;
            } else {
                TreeNode *cur = root-&gt;right;
                while (cur-&gt;left) cur = cur-&gt;left;
                root-&gt;val = cur-&gt;val;
                root-&gt;right = deleteNode(root-&gt;right, cur-&gt;val);
            }
        }
        return root;
    }
};
</code></pre>
<ul>
<li>leet_108</li>
</ul>
<pre><code class="language-C++">Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        return helper(nums, 0 , (int)nums.size() - 1);
    }
    TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right) {
        if (left &gt; right) return NULL;
        int mid = left + (right - left) / 2;
        TreeNode *cur = new TreeNode(nums[mid]);
        cur-&gt;left = helper(nums, left, mid - 1);
        cur-&gt;right = helper(nums, mid + 1, right);
        return cur;
    }
};
</code></pre>
<ul>
<li>leet_230</li>
</ul>
<pre><code class="language-C++">Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int cnt = 0;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (p || !s.empty()) {
            while (p) {
                s.push(p);
                p = p-&gt;left;
            }
            p = s.top(); s.pop();
            ++cnt;
            if (cnt == k) return p-&gt;val;
            p = p-&gt;right;
        }
        return 0;
    }
};
</code></pre>
<ul>
<li>leet_236</li>
</ul>
<pre><code class="language-C++">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
       if (!root || p == root || q == root) return root;
       TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);
       TreeNode *right = lowestCommonAncestor(root-&gt;right, p , q);
       if (left &amp;&amp; right) return root;
       return left ? left : right;
    }
};
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-09-05T09:16:40+08:00" itemprop="datePublished">2019/09/05 09:16 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15676462008800.html" itemprop="url">
		动态规划</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>记忆化搜索</h4>
<ul>
<li>递归是自上向下</li>
</ul>
<h4><a id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态规划</h4>
<ul>
<li>自下而上的解决问题</li>
<li>将原问题拆解成若干子问题，保存子问题的答案，使得每个子问题都只求解一次</li>
<li>递归问题-&gt;重叠子问题-&gt;</li>
<li>leet_120</li>
<li>leet_64 没有非负整数， 没有限制条件</li>
<li>leet_343 回溯</li>
<li><img src="media/15676462008800/15680798276938.jpg" alt="" style="width:1006px;" /></li>
<li><img src="media/15676462008800/15680799034216.jpg" alt="" style="width:996px;" /></li>
<li>leet_279</li>
<li><img src="media/15676462008800/15680822078106.jpg" alt="" style="width:1149px;" /></li>
<li>leet_79</li>
<li>leet_62</li>
<li>leet_63</li>
</ul>
<h4><a id="leet-198" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>leet_198</h4>
<ul>
<li><img src="media/15676462008800/15676509845611.jpg" alt="" style="width:1066px;" /></li>
<li><img src="media/15676462008800/15676510940203.jpg" alt="" style="width:1166px;" /></li>
<li>状态定义和状态转移一定要搞懂</li>
<li><img src="media/15676462008800/15676523958822.jpg" alt="" style="width:922px;" /></li>
<li>使用新的状态定义</li>
<li>leet_213</li>
<li>leet_337</li>
<li>leet_309</li>
</ul>
<h4><a id="0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>0-1背包问题</h4>
<ul>
<li>O(2^n*n)</li>
<li>贪心算法</li>
<li><img src="media/15676462008800/15679064880244.jpg" alt="" style="width:976px;" /></li>
<li>自顶向下 递归</li>
<li>自底向上 动态规划</li>
<li>背包问题优化</li>
<li><img src="media/15676462008800/15679083241737.jpg" alt="" style="width:1001px;" /></li>
</ul>
<h4><a id="%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>背包问题</h4>
<ul>
<li>每个物品可以无限使用</li>
<li>多重背包问题</li>
<li>物品之间加入更多约束</li>
</ul>
<h4><a id="leetcode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>leetcode</h4>
<ul>
<li>leet_416</li>
<li><img src="media/15676462008800/15679109143760.jpg" alt="" style="width:1002px;" /></li>
<li>leet_300</li>
<li><img src="media/15676462008800/15679095425409.jpg" alt="" style="width:989px;" /></li>
<li><img src="media/15676462008800/15679098812535.jpg" alt="" style="width:1012px;" /></li>
<li><img src="media/15676462008800/15679103037974.jpg" alt="" style="width:821px;" /></li>
<li>没有递增的特性</li>
<li>LIS问题的O(nlogn)解法</li>
<li>leet_376</li>
<li>leet_322</li>
<li>leet_377</li>
<li>leet_474</li>
<li>leet_139</li>
<li>leet_494</li>
</ul>
<h4><a id="more" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>more</h4>
<ul>
<li>最长公共子序列</li>
<li><img src="media/15676462008800/15679159466365.jpg" alt="" style="width:972px;" /></li>
<li><img src="media/15676462008800/15679161027984.jpg" alt="" style="width:1023px;" /></li>
</ul>
<h4><a id="dijkstra" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>dijkstra</h4>
<ul>
<li>单源最短路径算法</li>
<li><img src="media/15676462008800/15679162036286.jpg" alt="" style="width:815px;" /></li>
</ul>
<h4><a id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%90%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态规划子问题</h4>
<ul>
<li><img src="media/15676462008800/15679164823964.jpg" alt="" style="width:1028px;" /></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-07-23T10:30:17+08:00" itemprop="datePublished">2019/07/23 10:30 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15638490173383.html" itemprop="url">
		算法思路</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E9%A2%98%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>题目中的条件</h4>
<ul>
<li>设计O(nlogn)的算法 百万级和千万级</li>
<li>无需考虑额外的空间</li>
<li>数据规模大概是10000</li>
</ul>
<h4><a id="%E6%B2%A1%E6%9C%89%E6%80%9D%E8%B7%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>没有思路</h4>
<ul>
<li>给几个简单的测试用例</li>
<li>不要忽视暴力解法，暴力解法通常是思考的起点</li>
<li>lecode3</li>
<li>遍历常见的算法思路</li>
<li>遍历常见的数据结构</li>
<li>空间和时间的交换(哈希表)</li>
<li>预处理信息</li>
</ul>
<h4><a id="%E6%9E%81%E7%AB%AF%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>极端条件</h4>
<ul>
<li>数组为空</li>
<li>字符串为空</li>
<li>数量为0</li>
<li>指针为NULL</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-02T10:36:11+08:00" itemprop="datePublished">2019/08/02 10:36 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15647133717861.html" itemprop="url">
		查找表</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%B8%A4%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>两类</h4>
<ul>
<li>查找有无</li>
<li>查找对应关系</li>
<li>有序和查找是关联</li>
<li>如果数组有序</li>
<li>leet_349</li>
</ul>
<pre><code class="language-C++">Given two arrays, write a function to compute their intersection.
class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        set&lt;int&gt; s(nums1.begin(), nums1.end()), res;
        for (auto a : nums2) {
            if (s.count(a)) res.insert(a);
        }
        return vector&lt;int&gt;(res.begin(), res.end());
    }
};
</code></pre>
<ul>
<li>leet_350</li>
</ul>
<pre><code class="language-C++">Given two arrays, write a function to compute their intersection.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        unordered_map&lt;int, int&gt; m;
        vector&lt;int&gt; res;
        for (auto a : nums1) ++m[a];
        for (auto a : nums2) {
            if (m[a]-- &gt; 0) res.push_back(a);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_242</li>
</ul>
<pre><code class="language-C++">For example,
s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.
s = &quot;rat&quot;, t = &quot;car&quot;, return false.

class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size()) return false;
        int m[26] = {0};
        for (int i = 0; i &lt; s.size(); ++i) ++m[s[i] - 'a'];
        for (int i = 0; i &lt; t.size(); ++i) {
            if (--m[t[i] - 'a'] &lt; 0) return false;
        }
        return true;
    }
};
</code></pre>
<ul>
<li>leet_202</li>
</ul>
<pre><code class="language-C++">Write an algorithm to determine if a number is &quot;happy&quot;.

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example: 

Input: 19
Output: true
Explanation: 
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
class Solution {
public:
    bool isHappy(int n) {
        while (n != 1 &amp;&amp; n != 4) {
            int sum = 0;
            while (n) {
                sum += (n % 10) * (n % 10);
                n /= 10;
            }
            n = sum;
        }
        return n == 1;
    }
};
</code></pre>
<ul>
<li>leet_290</li>
</ul>
<pre><code class="language-C++">Given a pattern and a string str, find if str follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

Example 1:

Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;
Output: true
Example 2:

Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;
Output: false
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        unordered_map&lt;char, int&gt; m1;
        unordered_map&lt;string, int&gt; m2;
        istringstream in(str);
        int i = 0, n = pattern.size();
        for (string word; in &gt;&gt; word; ++i) {
            if (i == n || m1[pattern[i]] != m2[word]) return false;
            m1[pattern[i]] = m2[word] = i + 1;
        }
        return i == n;
    }
};
</code></pre>
<ul>
<li>leet_205</li>
</ul>
<pre><code class="language-C++">Given two strings  s  and  t , determine if they are isomorphic.

Two strings are isomorphic if the characters in  s  can be replaced to get  t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

Example 1:

Input: _s_ = &quot;egg&quot;, _t =_&quot;add&quot;
Output: true
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int m1[256] = {0}, m2[256] = {0}, n = s.size();
        for (int i = 0; i &lt; n; ++i) {
            if (m1[s[i]] != m2[t[i]]) return false;
            m1[s[i]] = i + 1;
            m2[t[i]] = i + 1;
        }
        return true;
    }
};
</code></pre>
<ul>
<li>leet_451</li>
</ul>
<pre><code class="language-C++">Input:
&quot;tree&quot;

Output:
&quot;eert&quot;

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore &quot;eetr&quot; is also a valid answer.
class Solution {
public:
    string frequencySort(string s) {
        string res;
        vector&lt;string&gt; v(s.size() + 1);
        unordered_map&lt;char, int&gt; m;
        for (char c : s) ++m[c];
        for (auto &amp;a : m) {
            v[a.second].append(a.second, a.first);
        }
        for (int i = s.size(); i &gt; 0; --i) {
            if (!v[i].empty()) res.append(v[i]);
        }
        return res;
    }
};
</code></pre>
<h4><a id="%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>两数求和</h4>
<ul>
<li>leet_1 排序后,双索引对撞</li>
</ul>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.count(target - nums[i])) {
                return {i, m[target - nums[i]]};
            }
            m[nums[i]] = i;
        }
        return {};
    }
};
</code></pre>
<ul>
<li>leet_15</li>
</ul>
<pre><code class="language-C++">Given an array  S  of  n  integers, are there elements  a ,  b ,  c  in  S  such that  a  +  b  +  c  = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

Elements in a triplet ( a , b , c ) must be in non-descending order. (ie,  a  ≤  b  ≤  c )
The solution set must not contain duplicate triplets.
 

    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; res;
        sort(nums.begin(), nums.end());
        if (nums.empty() || nums.back() &lt; 0 || nums.front() &gt; 0) return {};
        for (int k = 0; k &lt; (int)nums.size() - 2; ++k) {
            if (nums[k] &gt; 0) break;
            if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue;
            int target = 0 - nums[k], i = k + 1, j = (int)nums.size() - 1;
            while (i &lt; j) {
                if (nums[i] + nums[j] == target) {
                    res.push_back({nums[k], nums[i], nums[j]});
                    while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) ++i;
                    while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) --j;
                    ++i; --j;
                } else if (nums[i] + nums[j] &lt; target) ++i;
                else --j;
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_18</li>
</ul>
<pre><code class="language-C++">Given an array S of n integers, are there elements a , b , c , and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

Elements in a quadruplet ( a , b , c , d ) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d )

The solution set must not contain duplicate quadruplets.

For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt; &amp;nums, int target) {
        vector&lt;vector&lt;int&gt;&gt; res;
        int n = nums.size();
        sort(nums.begin(), nums.end());
        for (int i = 0; i &lt; n - 3; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j &lt; n - 2; ++j) {
                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;
                int left = j + 1, right = n - 1;
                while (left &lt; right) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) {
                        vector&lt;int&gt; out{nums[i], nums[j], nums[left], nums[right]};
                        res.push_back(out);
                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left;
                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right;
                        ++left; --right;
                    } else if (sum &lt; target) ++left;
                    else --right;
                }
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_16</li>
</ul>
<pre><code class="language-C++">Given array nums = [-1, 2, 1, -4], and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        int closest = nums[0] + nums[1] + nums[2];
        int diff = abs(closest - target);
        sort(nums.begin(), nums.end());
        for (int i = 0; i &lt; nums.size() - 2; ++i) {
            int left = i + 1, right = nums.size() - 1;
            while (left &lt; right) {
                int sum = nums[i] + nums[left] + nums[right];
                int newDiff = abs(sum - target);
                if (diff &gt; newDiff) {
                    diff = newDiff;
                    closest = sum;
                }
                if (sum &lt; target) ++left;
                else --right;
            }
        }
        return closest;
    }
};
</code></pre>
<h4><a id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态规划</h4>
<ul>
<li>leet120 Triangle</li>
</ul>
<pre><code class="language-C++">class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {
        vector&lt;int&gt; dp(triangle.back());
        for (int i = (int)triangle.size() - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt;= i; ++j) {
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j];
            }
        }
        return dp[0];
    }
};
</code></pre>
<ul>
<li>leet64 minium path sum</li>
</ul>
<pre><code class="language-C++">Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) {
        int m = grid.size(), n = grid[0].size();
        int dp[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 1; i &lt; m; ++i) dp[i][0] = grid[i][0] + dp[i - 1][0];
        for (int i = 1; i &lt; n; ++i) dp[0][i] = grid[0][i] + dp[0][i - 1];
        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m - 1][n - 1];
    }
};
</code></pre>
<ul>
<li>leet343 integer break</li>
</ul>
<pre><code class="language-C++">Given a positive integer  n , break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.

Example 1:

Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
class Solution {
public:
    int integerBreak(int n) {
        vector&lt;int&gt; dp(n + 1, 1);
        for (int i = 3; i &lt;= n; ++i) {
            for (int j = 1; j &lt; i; ++j) {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
</code></pre>
<ul>
<li>leet279 perfect squares</li>
</ul>
<pre><code class="language-C++">Given a positive integer  n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to  n.

Example 1:

Input: _n_ = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: _n_ = 13
Output: 2
Explanation: 13 = 4 + 9.
class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i &lt;= n; ++i) {
            for (int j = 1; i + j * j &lt;= n; ++j) {
                dp[i + j * j] = min(dp[i + j * j], dp[i] + 1);
            }
        }
        return dp.back();
    }
};
</code></pre>
<ul>
<li>leet91 decode ways</li>
</ul>
<pre><code class="language-C++">A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: &quot;12&quot;
Output: 2
Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).
，在遍历的过程中，对每个数字首先判断其是否为0，若是则将 dp[i] 赋为0，若不是，赋上 dp[i-1] 的值，然后看数组前一位是否存在，如果存在且满足前一位是1，或者和当前位一起组成的两位数不大于 26，则当前 dp[i] 值加上 dp[i - 2]。最终返回 dp 数组的最后一个值即可
dp[i] = dp[i-1] + dp[i-2]
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s[0] == '0') return 0;
        vector&lt;int&gt; dp(s.size() + 1, 0);
        dp[0] = 1;
        for (int i = 1; i &lt; dp.size(); ++i) {
            if (s[i - 1] != '0') dp[i] += dp[i - 1];
            if (i &gt;= 2 &amp;&amp; s.substr(i - 2, 2) &lt;= &quot;26&quot; &amp;&amp; s.substr(i - 2, 2) &gt;= &quot;10&quot;) {
                dp[i] += dp[i - 2];
            }
        }
        return dp.back();
    }
};
</code></pre>
<ul>
<li>leet62 unique path</li>
</ul>
<pre><code class="language-C++">A robot is located at the top-left corner of a  m  x  n  grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;int&gt; dp(n, 1);
        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[j] += dp[j - 1]; 
            }
        }
        return dp[n - 1];
    }
};
</code></pre>
<ul>
<li>leet63 unique path</li>
</ul>
<pre><code class="language-C++">这里还需要初始化 dp 数组的某个值，使得其能正常累加。当起点不是障碍物时，其 dp 值应该为1，即dp[1][1] = 1，由于其是由 dp[0][1] + dp[1][0] 更新而来，所以二者中任意一个初始化为1即可。由于之后 LeetCode 更新了这道题的 test case，使得使用 int 型的 dp 数组会有溢出的错误，所以改为使用 long 型的数组来避免 overflow，代码如下
class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector&lt;vector&lt;long&gt;&gt; dp(m + 1, vector&lt;long&gt;(n + 1, 0));
        dp[0][1] = 1;
        for (int i = 1; i &lt;= m; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                if (obstacleGrid[i - 1][j - 1] != 0) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
};
class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) return 0;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector&lt;long&gt; dp(n, 0);
        dp[0] = 1;
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (obstacleGrid[i][j] == 1) dp[j] = 0;
                else if (j &gt; 0) dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
};
</code></pre>
<ul>
<li>leet673</li>
</ul>
<h4><a id="%E6%9F%A5%E6%89%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查找</h4>
<ul>
<li>leet_350</li>
<li>leet_49</li>
</ul>
<pre><code class="language-C++">Given an array of strings, group anagrams together.

Example:

Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
Output:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        vector&lt;vector&lt;string&gt;&gt; res;
        unordered_map&lt;string, vector&lt;string&gt;&gt; m;
        for (string str : strs) {
            vector&lt;int&gt; cnt(26, 0);
            string t = &quot;&quot;;
            for (char c : str) ++cnt[c - 'a'];
            for (int d : cnt) t += to_string(d) + &quot;/&quot;;
            m[t].push_back(str);
        }
        for (auto a : m) {
            res.push_back(a.second);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_447</li>
</ul>
<pre><code class="language-C++">Given n points in the plane that are all pairwise distinct, a &quot;boomerang&quot; is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k ( the order of the tuple matters ).

Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).

Example:

**Input:**
[[0,0],[1,0],[2,0]]

**Output:**
2

**Explanation:**
The two boomerangs are **[[1,0],[0,0],[2,0]]** and **[[1,0],[2,0],[0,0]]**
class Solution {
public:
    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {
        int res = 0;
        for (int i = 0; i &lt; points.size(); ++i) {
            unordered_map&lt;int, int&gt; m;
            for (int j = 0; j &lt; points.size(); ++j) {
                int a = points[i].first - points[j].first;
                int b = points[i].second - points[j].second;
                ++m[a * a + b * b];
            }
            for (auto it = m.begin(); it != m.end(); ++it) {
                res += it-&gt;second * (it-&gt;second - 1);
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_149 点坐标的表示 整数 浮点数</li>
</ul>
<pre><code class="language-C++">Given  n  points on a 2D plane, find the maximum number of points that lie on the same straight line.

Example 1:

Input: [[1,1],[2,2],[3,3]]
Output: 3
Explanation:
^
|
|        o
|     o
|  o  
+-------------&gt;
0  1  2  3  4
class Solution {
public:
    int maxPoints(vector&lt;Point&gt;&amp; points) {
        int res = 0;
        for (int i = 0; i &lt; points.size(); ++i) {
            map&lt;pair&lt;int, int&gt;, int&gt; m;
            int duplicate = 1;
            for (int j = i + 1; j &lt; points.size(); ++j) {
                if (points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y) {
                    ++duplicate; continue;
                } 
                int dx = points[j].x - points[i].x;
                int dy = points[j].y - points[i].y;
                int d = gcd(dx, dy);
                ++m[{dx / d, dy / d}];
            }
            res = max(res, duplicate);
            for (auto it = m.begin(); it != m.end(); ++it) {
                res = max(res, it-&gt;second + duplicate);
            }
        }
        return res;
    }
    int gcd(int a, int b) {
        return (b == 0) ? a : gcd(b, a % b);
    }
};
</code></pre>
<h4><a id="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%9F%A5%E6%89%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>滑动窗口和查找</h4>
<ul>
<li>leet_217</li>
</ul>
<pre><code class="language-C++">Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.find(nums[i]) != m.end()) return true;
            ++m[nums[i]];
        }
        return false;
    }
};
</code></pre>
<ul>
<li>leet_219</li>
</ul>
<pre><code class="language-C++">Given an array of integers and an integer k, return true if and only if there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. (Old Version)

Given an array of integers and an integer k , find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. (New Version)
class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; m;
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (m.find(nums[i]) != m.end() &amp;&amp; i - m[nums[i]] &lt;= k) return true;
            else m[nums[i]] = i;
        }
        return false;
    }
};
</code></pre>
<ul>
<li>leet_220</li>
</ul>
<pre><code class="language-C++">Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) {
      map&lt;long long, int&gt; m;
      int j = 0;
      for (int i = 0; i &lt; nums.size(); i++) {
        if (i - j &gt; k) m.erase(nums[j++]);
        auto a = m.lower_bound((long long)nums[i] - t);
        if (a != m.end() &amp;&amp; abs(a-&gt;first - nums[i]) &lt;= t) return true;
        m[nums[i]] = i;
      }
      return false;
    }
};
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-20T09:30:49+08:00" itemprop="datePublished">2019/08/20 09:30 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15662646498238.html" itemprop="url">
		队列</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>栈</h4>
<ul>
<li>leet_20</li>
</ul>
<pre><code class="language-C++">Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; parentheses;
        for (int i = 0; i &lt; s.size(); ++i) {
            if (s[i] == '(' || s[i] == '[' || s[i] == '{') parentheses.push(s[i]);
            else {
                if (parentheses.empty()) return false;
                if (s[i] == ')' &amp;&amp; parentheses.top() != '(') return false;
                if (s[i] == ']' &amp;&amp; parentheses.top() != '[') return false;
                if (s[i] == '}' &amp;&amp; parentheses.top() != '{') return false;
                parentheses.pop();
            }
        }
        return parentheses.empty();
    }
}; 
</code></pre>
<ul>
<li>leet_150</li>
</ul>
<pre><code class="language-C++">Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
Output: 9
Explanation: ((2 + 1) * 3) = 9
class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        if (tokens.size() == 1) return stoi(tokens[0]);
        stack&lt;int&gt; st;
        for (int i = 0; i &lt; tokens.size(); ++i) {
            if (tokens[i] != &quot;+&quot; &amp;&amp; tokens[i] != &quot;-&quot; &amp;&amp; tokens[i] != &quot;*&quot; &amp;&amp; tokens[i] != &quot;/&quot;) {
                st.push(stoi(tokens[i]));
            } else {
                int num1 = st.top(); st.pop();
                int num2 = st.top(); st.pop();
                if (tokens[i] == &quot;+&quot;) st.push(num2 + num1);
                if (tokens[i] == &quot;-&quot;) st.push(num2 - num1);
                if (tokens[i] == &quot;*&quot;) st.push(num2 * num1);
                if (tokens[i] == &quot;/&quot;) st.push(num2 / num1);
            }
        }
        return st.top();
    }
};

class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        int op = (int)tokens.size() - 1;
        return helper(tokens, op);
    }
    int helper(vector&lt;string&gt;&amp; tokens, int&amp; op) {
        string str = tokens[op];
        if (str != &quot;+&quot; &amp;&amp; str != &quot;-&quot; &amp;&amp; str != &quot;*&quot; &amp;&amp; str != &quot;/&quot;) return stoi(str);
        int num1 = helper(tokens, --op);
        int num2 = helper(tokens, --op);
        if (str == &quot;+&quot;) return num2 + num1;
        if (str == &quot;-&quot;) return num2 - num1;
        if (str == &quot;*&quot;) return num2 * num1;
        return num2 / num1;
    }
};
</code></pre>
<ul>
<li>leet_71</li>
</ul>
<pre><code class="language-C++">For example,
path = &quot;/home/&quot;, =&gt; &quot;/home&quot;
path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot;
class Solution {
public:
    string simplifyPath(string path) {
        vector&lt;string&gt; v;
        int i = 0;
        while (i &lt; path.size()) {
            while (path[i] == '/' &amp;&amp; i &lt; path.size()) ++i;
            if (i == path.size()) break;
            int start = i;
            while (path[i] != '/' &amp;&amp; i &lt; path.size()) ++i;
            int end = i - 1;
            string s = path.substr(start, end - start + 1);
            if (s == &quot;..&quot;) {
                if (!v.empty()) v.pop_back(); 
            } else if (s != &quot;.&quot;) {
                v.push_back(s);
            }
        }
        if (v.empty()) return &quot;/&quot;;
        string res;
        for (int i = 0; i &lt; v.size(); ++i) {
            res += '/' + v[i];
        }
        return res;
    }
};
</code></pre>
<h4><a id="%E6%A0%88%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E7%B4%A7%E5%AF%86%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>栈和递归的紧密关系</h4>
<ul>
<li>leet_144</li>
</ul>
<pre><code class="language-C++">For example:
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3
 
return [1,2,3].
class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (!s.empty() || p) {
            if (p) {
                s.push(p);
                res.push_back(p-&gt;val);
                p = p-&gt;left;
            } else {
                TreeNode *t = s.top(); s.pop();
                p = t-&gt;right;
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_94 middle</li>
</ul>
<pre><code class="language-C++">Given a binary tree, return the  inorder  traversal of its nodes' values.
Example:
Input: [1,null,2,3]
   1
    \
     2
    /
   3
Output: [1,3,2]

class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (!s.empty() || p) {
            if (p) {
                s.push(p);
                p = p-&gt;left;
            } else {
               TreeNode* t = s.top(); s.pop();
                res.push_back(t-&gt;val);
                p = t-&gt;right;
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_145</li>
</ul>
<pre><code class="language-C++">Given a binary tree, return the postorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [3,2,1].

class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; s;
        TreeNode *p = root;
        while (!s.empty() || p) {
            if (p) {
                s.push(p);
                res.insert(res.begin(), p-&gt;val);
                p = p-&gt;right;
            } else {
                TreeNode *t = s.top(); s.pop();
                p = t-&gt;left;
            }
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_341</li>
</ul>
<pre><code class="language-C++">class NestedIterator {
public:
    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) {
        for (int i = nestedList.size() - 1; i &gt;= 0; --i) {
            s.push(nestedList[i]);
        }
    }

    int next() {
        NestedInteger t = s.top(); s.pop();
        return t.getInteger();
    }

    bool hasNext() {
        while (!s.empty()) {
            NestedInteger t = s.top(); 
            if (t.isInteger()) return true;
            s.pop();
            for (int i = t.getList().size() - 1; i &gt;= 0; --i) {
                s.push(t.getList()[i]);
            }
        }
        return false;
    }  

private:
    stack&lt;NestedInteger&gt; s;
};
</code></pre>
<h4><a id="%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>队列</h4>
<ul>
<li>广度优先遍历</li>
<li>树 层序遍历</li>
<li>图 无权图的最短路径</li>
<li>leet_102</li>
</ul>
<pre><code class="language-plain_text">Given a binary tree, return the  level order  traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        if (!root) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; q{{root}};
        while (!q.empty()) {
            vector&lt;int&gt; oneLevel;
            for (int i = q.size(); i &gt; 0; --i) {
                TreeNode *t = q.front(); q.pop();
                oneLevel.push_back(t-&gt;val);
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            res.push_back(oneLevel);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_107</li>
</ul>
<pre><code class="language-C++">For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7 
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode* root) {
        if (!root) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; q{{root}};
        while (!q.empty()) {
            vector&lt;int&gt; oneLevel;
            for (int i = q.size(); i &gt; 0; --i) {
                TreeNode *t = q.front(); q.pop();
                oneLevel.push_back(t-&gt;val);
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            res.insert(res.begin(), oneLevel);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_103</li>
</ul>
<pre><code class="language-C++">For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
        if (!root) return {};
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; q{{root}};
        bool leftToRight = true;
        while (!q.empty()) {
            int size = q.size();
            vector&lt;int&gt; oneLevel(size);
            for (int i = 0; i &lt; size; ++i) {
                TreeNode *t = q.front(); q.pop();
                int idx = leftToRight ? i : (size - 1 - i);
                oneLevel[idx] = t-&gt;val;
                if (t-&gt;left) q.push(t-&gt;left);
                if (t-&gt;right) q.push(t-&gt;right);
            }
            leftToRight = !leftToRight;
            res.push_back(oneLevel);
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_199</li>
</ul>
<pre><code class="language-C++">Given a binary tree, imagine yourself standing on the  right  side of it, return the values of the nodes you can see ordered from top to bottom.

For example:
Given the following binary tree,

   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---

class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode *root) {
        vector&lt;int&gt; res;
        if (!root) return res;
        queue&lt;TreeNode*&gt; q{{root}};
        while (!q.empty()) {
            res.push_back(q.back()-&gt;val);
            int size = q.size();
            for (int i = 0; i &lt; size; ++i) {
                TreeNode *node = q.front();
                q.pop();
                if (node-&gt;left) q.push(node-&gt;left);
                if (node-&gt;right) q.push(node-&gt;right);
            }
        }
        return res;
    }
};
</code></pre>
<h4><a id="bfs" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>BFS</h4>
<ul>
<li>leet_279</li>
</ul>
<pre><code class="language-C++">Given a positive integer  n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to  n.

Example 1:

Input: _n_ = 12
Output: 3 
Explanation: 12 = 4 + 4 + 4.

class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i &lt;= n; ++i) {
            for (int j = 1; i + j * j &lt;= n; ++j) {
                dp[i + j * j] = min(dp[i + j * j], dp[i] + 1);
            }
        }
        return dp.back();
    }
};

class Solution {
public:
    int numSquares(int n) {
        
      int ret;
      assert(n &gt; 0);
      vector&lt;bool&gt; visited(n+1, false);
      visited[n] = true;
      queue&lt;pair&lt;int, int&gt;&gt; q;

      q.push(make_pair(n, 0));

      while (!q.empty()) {
        int num = q.front().first;
        int step = q.front().second;
        q.pop();

        for (int i = 1; ; i++) {
          int a = num - i * i;

          if (a &lt; 0) break;

          if (a == 0) return ret = step + 1;

          if (!visited[a]) {
            visited[a] = true;
            q.push(make_pair(a, step + 1));
          }
        }
      }
      return ret;
    }
};

</code></pre>
<ul>
<li>leet_127</li>
</ul>
<pre><code class="language-C++">Input:
beginWord = &quot;hit&quot;,
endWord = &quot;cog&quot;,
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]

Output: 5

Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,
return its length 5.
class Solution {
  public:
  int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {
    unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());
    if (!wordSet.count(endWord)) return 0;
    queue&lt;string&gt; q{{beginWord}};
    int res = 0;
    while (!q.empty()) {
      for (int k = q.size(); k &gt; 0; --k) {
        string word = q.front(); q.pop();
        if (word == endWord) return res + 1;
        for (int i = 0; i &lt; word.size(); ++i) {
          string newWord = word;
          for (char ch = 'a'; ch &lt;= 'z'; ++ch) {
            newWord[i] = ch;
            if (wordSet.count(newWord) &amp;&amp; newWord != word) {
              q.push(newWord);
              wordSet.erase(newWord);
            }   
          }
        }
      }
      ++res;
    }
    return 0;
  }
};
</code></pre>
<ul>
<li>leet_126</li>
</ul>
<h4><a id="%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优先级队列</h4>
<ul>
<li>底层实现,堆</li>
<li>堆的底层实现, 白板编程</li>
<li>priority_queue</li>
<li>leet_347 O(nlog(n-k)) O(nlog(n-k))</li>
</ul>
<pre><code class="language-C++">Given a non-empty array of integers, return the  k  most frequent elements.

Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
class Solution {
public:
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; m;
        priority_queue&lt;pair&lt;int, int&gt;&gt; q;
        vector&lt;int&gt; res;
        for (auto a : nums) ++m[a];
        for (auto it : m) q.push({it.second, it.first});
        for (int i = 0; i &lt; k; ++i) {
            res.push_back(q.top().second); q.pop();
        }
        return res;
    }
};
</code></pre>
<ul>
<li>leet_23</li>
</ul>
<pre><code class="language-C++">Merge  k  sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
class Solution {
  public:
  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode node(0), *p = &amp;node;

    while (l1 &amp;&amp; l2) {
      if (l1-&gt;val &lt; l2-&gt;val) {
        p-&gt;next = l1;
        l1 = l1-&gt;next;
      } else {
        p-&gt;next = l2;
        l2 = l2-&gt;next;
      }
      p = p-&gt;next;
    }

    p-&gt;next = l1 ? l1 : l2;
    return node.next;
  }
  
  ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {

    if (lists.empty()) return nullptr;
    
    while (lists.size() &gt; 1) {
      lists.push_back(mergeTwoLists(lists[0], lists[1]));
      lists.erase(lists.begin());
      lists.erase(lists.begin());
    }
    
    return lists[0];
  }
};
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-07-23T08:04:46+08:00" itemprop="datePublished">2019/07/23 08:04 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95.html'>玩转算法</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15638402863944.html" itemprop="url">
		算法面试本质</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%9C%AC%E8%B4%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>本质</h4>
<ul>
<li>不代表能够“正确”回答每一个算法问题，但是合理的思考方向其实更重要</li>
<li>正确完成算法面试问题的前提算法面试优秀不意味着技术面试优秀</li>
<li>技术面试优秀不意味着能够拿到Offer</li>
</ul>
<h4><a id="%E7%BB%99%E5%87%BA%E5%90%88%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>给出合理的思考路径</h4>
<ul>
<li>展示出思考问题的方式</li>
<li>和面试官一起探讨一个问题的解决方案</li>
<li>问题的细节和应用环境</li>
<li>沟通本身很重要，暗示思考问题的方式</li>
</ul>
<h4><a id="%E5%AF%B9%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对一组数据进行排序</h4>
<ul>
<li>这组数据的具体的特征</li>
<li>是否包含大量重复的元素</li>
<li>三路快排是更好的选择</li>
<li>是否大部分数据距离离他正确的位置很近？是否近乎排序
<ul>
<li>插入排序</li>
</ul>
</li>
<li>取值范围非常有限，比如对学生成绩排序
<ul>
<li>计数排序</li>
</ul>
</li>
<li>额外排序</li>
<li>稳定排序</li>
<li>归并排序</li>
<li>数据的存储状况是怎样的
<ul>
<li>链标存储</li>
<li>是否可以装载在内存中</li>
</ul>
</li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	 <a class="next" href="玩转算法_1.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>