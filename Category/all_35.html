<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	       凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-29T16:24:27+08:00" itemprop="datePublished">2019/12/29 16:24 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%80%A7%E8%83%BD%E5%B7%A5%E7%A8%8B%E9%AB%98%E6%89%8B%E8%AF%BE.html'>性能工程高手课</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15776078672199.html" itemprop="url">
		性能工程三定律</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%B8%95%E5%86%85%E6%89%98%E6%B3%95%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>帕内托法则</h4>
<ul>
<li>所有的变量中，比较重要的只有 20%，是所谓的“关键少数”</li>
<li><img src="media/15776078672199/9d99b547cbf2074144203f2ec2806c1d.png" alt="9d99b547cbf2074144203f2ec2806c1d" /></li>
</ul>
<h4><a id="%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>阿姆达尔定律</h4>
<ul>
<li>阿姆达尔定律（Amdahl’s law / Amdahl’s argument）是计算机科学界非常重要的一个定律和法则。它本来用于衡量处理器进行并行处理时总体性能的提升度</li>
</ul>
<h4><a id="" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a></h4>
<h4><a id="%E5%88%A9%E7%89%B9%E5%B0%94%E6%B3%95%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>利特尔法则</h4>
<ul>
<li>在一个稳定的系统中，长期的平均客户人数（N）等于客户抵达速度（X）乘以客户在这个系统中平均处理时间（W），也就是说 N=XW。</li>
</ul>
<h4><a id="%E7%94%A8%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用处</h4>
<ul>
<li>帮助我们设计性能測试的环境。性能测试的内容我们后面会详细讲到，这里简单提下。比如当我们需要模拟一个固定容量的系統，那么性能测试的客户请求流量速度和每个请求的延时都需要仔细考虑。</li>
<li>帮助我们验证测试结果的正确性。有时候，如果性能测试的工作没有仔细地规划，得出的测试结果会出奇得好，或者出奇得差，从而让我们抓脑壳。这时如果采用利特尔法则，就可以很快地发现问题所在之处。</li>
</ul>
<h4><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h4>
<ul>
<li><img src="media/15776078672199/74b119d052157540473f3d75870c64dc.png" alt="74b119d052157540473f3d75870c64d" /></li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-29T08:40:09+08:00" itemprop="datePublished">2019/12/29 08:40 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html'>性能测试</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15775800093186.html" itemprop="url">
		性能需求指标描述</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%80%A7%E8%83%BD%E9%9C%80%E6%B1%82%E6%8C%87%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>性能需求指标</h4>
<ul>
<li>业务指标</li>
<li>技术指标</li>
</ul>
<h4><a id="%E4%B8%9A%E5%8A%A1%E6%8C%87%E6%A0%87%E5%92%8C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>业务指标和性能指标</h4>
<ul>
<li><img src="media/15775800093186/1bb1222c53e8b16414458a8572e786c2.png" alt="1bb1222c53e8b16414458a8572e786" /></li>
</ul>
<h4><a id="tpsqpsrpscps" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TPS/QPS/RPS/CPS</h4>
<ul>
<li>QPS 一开始是用来描述 MySQL 中 SQL 每秒执行数 Query Per Second</li>
<li>TPS 它用来描述每秒事务数。我们也知道 TPS 在不同的行业、不同的业务中定义的粒度都是不同的,需要知道T如何定义</li>
<li>如果是接口层性能测试，T 可以直接定义为接口级；如果业务级性能测试，T 可以直接定义为每个业务步骤和完整的业务流。</li>
<li>HPS 每秒点技数</li>
<li>CPS/CPM：Calls Per Second/ Calls Per Minutes，每秒 / 每分钟调用次数</li>
</ul>
<h4><a id="rt%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RT响应时间</h4>
<ul>
<li>响应时间来说，时间的拆分定位是性能瓶颈定位分析中非常重要的一节</li>
</ul>
<h4><a id="%E5%8E%8B%E5%8A%9B%E5%B7%A5%E5%85%B7%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%92%8C%E7%94%A8%E6%88%B7%E6%95%B0%E5%92%8Ctps" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>压力工具的线程数和用户数和TPS</h4>
<ul>
<li>用户数*并发度=TPS</li>
<li>TPS/RT=并发线程数</li>
</ul>
<h4><a id="%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>响应时间设计</h4>
<ul>
<li>同行业的对比数据。</li>
<li>找到使用系统的样本用户（越多越好），对他们做统计，将结果拿出来，就是最有效的响应时间的制定标准</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-29T08:18:29+08:00" itemprop="datePublished">2019/12/29 08:18 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html'>性能测试</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15775787094210.html" itemprop="url">
		TPS和响应时间</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%80%A7%E8%83%BD%E7%A4%BA%E6%84%8F%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>性能示意图</h4>
<ul>
<li><img src="media/15775787094210/36ee34ee92b75fd17d5314d74453367d.png" alt="36ee34ee92b75fd17d5314d74453367d" /></li>
<li>三条曲线：吞吐量的曲线（紫色）、使用率 / 用户数曲线（绿色）、响应时间曲线（深蓝色）。</li>
<li>三个区域：轻负载区（Light Load）、重负载区（Heavy Load）、塌陷区（Buckle Zone）。</li>
<li>两个点：最优并发用户数（The Optimum Number of Concurrent Users）、最大并发用户数（The Maximum Number of Concurrent Users）。</li>
<li>三个状态描述：资源饱和（Resource Saturated）、吞吐下降（Throughput Falling）、用户受影响（End Users Effected）。</li>
</ul>
<h4><a id="%E7%9B%B4%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>直接关系图</h4>
<ul>
<li><img src="media/15775787094210/c0575730fe2d14842aba066bc8786734.png" alt="c0575730fe2d14842aba066b" /></li>
</ul>
<h4><a id="%E5%9C%BA%E6%99%AF%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>场景定义</h4>
<ul>
<li><img src="media/15775787094210/55168e3443446e5866c85853f0e71ab1.jpg" alt="55168e3443446e5866c85853f0e71ab1" /></li>
</ul>
<h4><a id="%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何看待性能数据</h4>
<ul>
<li>一般有两个核心即趋势和证据链。</li>
<li>分析数据趋势需要对一个时间序列数据的分析，一般采用线性回归分析。</li>
<li>对于证据链查找，需要对不同时间序列数据的分析，一般采用数据的相关性分析</li>
</ul>
<h4><a id="%E6%80%A7%E8%83%BD%E5%9C%BA%E6%99%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9E%E7%BB%AD%E8%80%8C%E4%B8%8D%E6%98%AF%E6%96%AD%E5%BC%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>性能场景为什么要连续而不是断开</h4>
<ul>
<li>递增线程数，记录每次的性能指标，对比分析，画曲线，来观察指标变化的趋势，找出性能瓶颈，或者服务器最大处理能力</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-20T08:32:05+08:00" itemprop="datePublished">2019/12/20 08:32 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15768019255107.html" itemprop="url">
		进程间通讯</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%B8%89%E7%B1%BBqueue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三类queue</h4>
<pre><code class="language-python">from multiprocessing import Process, Queue
from queue import Queue
from multiprocessing import Manager
</code></pre>
<h4><a id="%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程间通讯</h4>
<pre><code class="language-python">import time
from multiprocessing import Process, Queue, Pool, Manager, Pipe


def producer(queue):
    queue.put(&quot;a&quot;)
    time.sleep(2)

def consumer(queue):
    time.sleep(2)
    data = queue.get()
    print(data)

if __name__ == &quot;__main__&quot;:
    queue = Queue(10)
    my_producer = Process(target=producer, args=(queue,))
    my_consumer = Process(target=consumer, args=(queue,))
    my_producer.start()
    my_consumer.start()
    my_producer.join()
    my_consumer.join()
</code></pre>
<h4><a id="%E8%BF%9B%E7%A8%8B%E6%B1%A0%E9%97%B4%E9%80%9A%E8%AE%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程池间通讯</h4>
<pre><code class="language-python">import time
from multiprocessing import Process, Queue, Pool
# from queue import Queue
from multiprocessing import Manager

Manager().Queue()

def producer(queue):
    queue.put('a')
    time.sleep(2)

def consumer(queue):
    time.sleep(2)
    data = queue.get()
    print(data)

if __name__ == '__main__':
    queue = Manager().Queue(10)
    pool = Pool(2)

    pool.apply_async(producer, args=(queue,))
    pool.apply_async(consumer, args=(queue,))

    pool.close()
    pool.join()
</code></pre>
<h4><a id="pipe%E9%80%9A%E8%AE%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pipe通讯</h4>
<pre><code class="language-python">import time
from multiprocessing import Process, Queue, Pool, Manager, Pipe

def producer(pipe):
    pipe.send('bobby')
    pipe.send('ok')
    pipe.send('hello')

def consumer(pipe):
    print(pipe.recv())
    print(pipe.recv())
    print(pipe.recv())

if __name__ == '__main__':
    recv_pipe, send_pipe = Pipe()
    my_pro = Process(target=producer, args=(send_pipe,))
    my_con = Process(target=consumer, args=(recv_pipe,))

    my_pro.start()
    my_con.start()
    my_pro.join()
    my_pro.join()
</code></pre>
<ul>
<li>pipe性能是高于queue</li>
</ul>
<h4><a id="%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>共享内存</h4>
<pre><code class="language-python">import time
from multiprocessing import Process, Queue, Pool, Manager, Pipe

def add_data(p_dict, key, value):
    p_dict[key] = value

if __name__ == '__main__':
    progress_dict = Manager().dict()

    first_pro = Process(target=add_data, args=(progress_dict, &quot;bobby1&quot;, 22))
    second_pro = Process(target=add_data, args=(progress_dict, &quot;bobby2&quot;, 23))
    third_pro = Process(target=add_data, args=(progress_dict, &quot;bobby3&quot;, 24))

    first_pro.start()
    second_pro.start()
    third_pro.start()
    first_pro.join()
    second_pro.join()
    third_pro.join()
    print(progress_dict)
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-20T08:07:19+08:00" itemprop="datePublished">2019/12/20 08:07 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15768004391774.html" itemprop="url">
		多进程同步</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%A4%9A%E8%BF%9B%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多进程</h4>
<pre><code class="language-python">import multiprocessing

import time

def get_html(n):
    time.sleep(n)
    print('sub_progress success')
    return n

if __name__ == '__main__':
    progress = multiprocessing.Process(target=get_html, args=(2,))
    print(progress.pid)
    progress.start()
    print(progress.pid)
    progress.join()
    print('main progress end')
</code></pre>
<h4><a id="%E8%BF%9B%E5%9F%8E%E6%B1%A0%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进城池获取结果</h4>
<pre><code class="language-python">import multiprocessing

import time

def get_html(n):
    time.sleep(n)
    print('sub_progress success')
    return n

if __name__ == '__main__':
    pool = multiprocessing.Pool(multiprocessing.cpu_count())
    result = pool.apply_async(get_html, args=(3,))
    pool.close()
    pool.join() //前面必须有close
    print(result.get())
</code></pre>
<h4><a id="imap-imap-unordered" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>imap&amp;imap_unordered</h4>
<pre><code class="language-python">import multiprocessing
import  time
def get_html(n):
    time.sleep(n)
    print('sub_process sucess')
    return n

if __name__ == '__main__':
    pool = multiprocessing.Pool(multiprocessing.cpu_count())

//不按顺序输出结果，谁先完成，谁先输出
    for result in pool.imap_unordered(get_html, [1,5,3]):
        print('{} sleep success'.format(result))
//按照列表顺序输出结果
    for result in pool.imap(get_html, [1, 5, 3]):
        print('{} sleep success'.format(result))
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-09T08:08:22+08:00" itemprop="datePublished">2019/12/09 08:08 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15758501024510.html" itemprop="url">
		多线程同步</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>死锁情况</h4>
<pre><code class="language-python">#2. 锁会引起死锁
#死锁的情况 A（a，b）
A(a、b)
acquire (a)
acquire (b)

B(a、b)
acquire (a)
acquire (b)
</code></pre>
<h4><a id="%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可重入的锁</h4>
<ul>
<li>同一个线程里面，可以连续调用多次acquire,一定要注意acquire的次数</li>
<li>RLock可重入锁</li>
</ul>
<pre><code class="language-python">from threading import Lock, RLock, Condition

total = 0
lock = RLock()

def add():
    global lock
    global total
    for i in range(10000):
        lock.acquire()
        lock.acquire()
        total += 1
        lock.release()
        lock.release()

def desc():
    global total
    global lock
    for i in range(10000):
        # lock.acquire()
        lock.acquire()
        total -= 1
        lock.release()
        # lock.release()

import threading

thread1 = threading.Thread(target=add)
thread2 = threading.Thread(target=desc)

thread1.start()
thread2.start()
thread2.join()
thread2.join()
print(&quot;total {}&quot;.format(total))
</code></pre>
<h4><a id="%E5%8D%8F%E5%90%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>协同</h4>
<pre><code class="language-python">import threading

class XiaoAi(threading.Thread):
    def __init__(self, lock):
        super().__init__(name=&quot;xiaoai&quot;)
        self.lock = lock

    def run(self):
        self.lock.acquire()
        print(&quot;{}. at &quot;.format(self.name))
        self.lock.release()

        self.lock.acquire()
        print(&quot;{}. ok &quot;.format(self.name))
        self.lock.release()

class TianMao(threading.Thread):
    def __init__(self, lock):
        super().__init__(name=&quot;tiaomao&quot;)
        self.lock = lock

    def run(self):
        self.lock.acquire()
        print(&quot;{} : xiaoai roomate&quot;.format(self.name))
        self.lock.release()

        self.lock.acquire()
        print(&quot;{} : let's talk&quot;.format(self.name))
        self.lock.release()

if __name__ == '__main__':
    lock = threading.Lock()
    thread1 = XiaoAi(lock)
    thread2 = TianMao(lock)
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
</code></pre>
<ul>
<li>condition启动顺序很重要,在调用with cond之后才能调用wait或者notify方法</li>
<li>condition有两层锁， 一把底层锁会在线程调用了wait方法的时候释放， 上面的锁会在每次调用wait的时候分配一把并放入到cond的等待队列中，等到notify方法的唤醒<br />
xiaoai.start()</li>
</ul>
<pre><code class="language-python">import threading

class XiaoAi(threading.Thread):
    def __init__(self, cond):
        super().__init__(name=&quot;xiaoai&quot;)
        self.cond = cond

    def run(self):
        with self.cond:
            self.cond.wait()
            print('{}: 在 '.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print('{}: 好阿 '.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print('{}: 君住长江尾 '.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print('{}: 共饮长江水 '.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print('{}: 此恨何时已 '.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print('{}: 定不负相思意 '.format(self.name))
            self.cond.notify()

class TianMao(threading.Thread):
    def __init__(self, cond):
        super().__init__(name=&quot;天猫精灵&quot;)
        self.cond = cond

    def run(self):
        with self.cond:
            print('{}: 小爱同学 '.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print('{}: 我们来对古诗吧 '.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print('{}: 我住长江头 '.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print('{}: 日日思君不见君 '.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print('{}: 此水几时休 '.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print('{}: 只愿君心似我心 '.format(self.name))
            self.cond.notify()
            self.cond.wait()

if __name__ == '__main__':
    from concurrent import futures
    cond = threading.Condition()
    xiaoai = XiaoAi(cond)
    tianmao = TianMao(cond)

    xiaoai.start()
    tianmao.start()
</code></pre>
<h4><a id="threadpoolexcutor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ThreadPoolExcutor</h4>
<pre><code class="language-python">from concurrent.futures import ThreadPoolExecutor, as_completed, wait, FIRST_COMPLETED
from concurrent.futures import Future
from multiprocessing import Pool


import time

def get_html(times):
    time.sleep(times)
    print('get page {} process'.format(times))
    return times

executor = ThreadPoolExecutor(max_workers=2)
</code></pre>
<h5><a id="%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>执行任务获取结果</h5>
<pre><code class="language-python">task1 = executor.submit(get_html, (3))
task2 = executor.submit(get_html, (2))
#
print(task1.result())
print(task2.cancel()) //取消结果
</code></pre>
<h5><a id="%E5%A4%9A%E4%BB%BB%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多任务</h5>
<pre><code class="language-python">urls = [3, 2, 4]

all_task = [executor.submit(get_html, (url)) for url in urls]

for future in as_completed(all_task):
    data = future.result()
    print('get {} page'.format(data))


#通过excutor获取已经完成的task
for data in executor.map(get_html, urls):
    print('get {} page'.format(data))
</code></pre>
<h5><a id="wait%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>wait获取结果</h5>
<pre><code class="language-python">#wait
wait(all_task, return_when=FIRST_COMPLETED)
print('main')
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-09T07:06:10+08:00" itemprop="datePublished">2019/12/09 07:06 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15758463705532.html" itemprop="url">
		GIL</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概念</h4>
<ul>
<li>全局解释器锁</li>
<li>CPython</li>
<li>GIL使得同一时刻只有一个线程在一个CPU上执行字节码</li>
<li>无法将多个线程映射到多个CPU上执行</li>
</ul>
<h4><a id="%E9%87%8A%E6%94%BE%E7%9A%84%E6%97%B6%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>释放的时机</h4>
<ul>
<li>根据执行字节码的行数或者执行的时间片来进行释放</li>
<li>遇到IO操作的时候释放</li>
</ul>
<h4><a id="%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程调度</h4>
<ul>
<li>对于IO操作来说，多线程和多进程性能差别不大</li>
</ul>
<h4><a id="thread-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>thread_demo</h4>
<pre><code class="language-python">import time
import threading


def get_detail_html(url):
    print(&quot;get detail html started&quot;)
    time.sleep(2)
    print(&quot;get detail html end&quot;)


def get_detail_url(url):
    print(&quot;get detail url started&quot;)
    time.sleep(2)
    print(&quot;get detail url end&quot;)

if __name__ == &quot;__main__&quot;:
   thread1 = threading.Thread(target=get_detail_html, args=(&quot;&quot;,))
   thread2 = threading.Thread(target=get_detail_url, args=(&quot;&quot;,))
   thread1.setDaemon(True)
   # thread2.setDaemon(True)
   start_time = time.time()
   thread1.start()
   thread2.start()

   print(&quot;last time : {}&quot;.format(time.time() - start_time))
</code></pre>
<h4><a id="thread-join" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>thread_join</h4>
<pre><code class="language-python">def get_detail_html(url):
    print(&quot;get detail html started&quot;)
    time.sleep(2)
    print(&quot;get detail html end&quot;)


def get_detail_url(url):
    print(&quot;get detail url started&quot;)
    time.sleep(4)
    print(&quot;get detail url end&quot;)

if __name__ == &quot;__main__&quot;:
   thread1 = threading.Thread(target=get_detail_html, args=(&quot;&quot;,))
   thread2 = threading.Thread(target=get_detail_url, args=(&quot;&quot;,))
   # thread1.setDaemon(True)
   # thread2.setDaemon(True)
   start_time = time.time()
   thread1.start()
   thread2.start()
   thread1.join()
   thread2.join()

   print(&quot;last time : {}&quot;.format(time.time() - start_time))
</code></pre>
<ul>
<li>deque在字节码的层面是安全的</li>
</ul>
<h4><a id="%E9%9B%86%E6%88%90thread%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>集成Thread来实现多线程</h4>
<pre><code class="language-python">import time
import threading

class GetDetailHtml(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)

    def run(self):
        print(&quot;get detail html started&quot;)
        time.sleep(2)
        print(&quot;get detail html end&quot;)

class GetDetailUrl(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)

    def run(self):
        print(&quot;get detail url started&quot;)
        time.sleep(4)
        print(&quot;get detail url end&quot;)

if __name__ == &quot;__main__&quot;:
    thread1 = GetDetailHtml(&quot;get_detail_html&quot;)
    thread2 = GetDetailUrl(&quot;get_detail_url&quot;)
    start_time = time.time()
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()

    print(&quot;last time : {}&quot;.format(time.time() - start_time))

</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-02T07:11:52+08:00" itemprop="datePublished">2019/12/02 07:11 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html'>设计模式之美</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15752419123800.html" itemprop="url">
		组合和继承</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%BB%84%E5%90%88%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组合的优势</h4>
<ul>
<li>利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题</li>
</ul>
<h4><a id="%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8A%A3%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>继承的劣势</h4>
<ul>
<li>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承</li>
</ul>
<h4><a id="%E7%BB%84%E5%90%88%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组合的优势</h4>
<ul>
<li>继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。</li>
</ul>
<h4><a id="%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88%E7%9A%84%E5%88%A4%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>继承和组合的判断</h4>
<ul>
<li>如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承</li>
</ul>
<h4><a id="cpp-demo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cpp_demo</h4>
<pre><code class="language-C++">#include &lt;iostream&gt;
class Flyable {
public:
    virtual void fly() = 0;
};

class Tweetable {
public:
    virtual void tweet() = 0;
};

class EggLayable {
public:
    virtual void layEgg() = 0;
};

class FlyAbility : public Flyable {
public:
    void fly() {
        std::cout &lt;&lt; &quot;Fly Ability &quot; &lt;&lt; std::endl;
    }
};

class TweetAbility: public Tweetable {
public:
    void tweet() {
        std::cout &lt;&lt; &quot;TweetAbility&quot; &lt;&lt; std::endl;
    }
};

class EggLayAbility: public EggLayable {
public:
    void layEgg() {
        std::cout &lt;&lt; &quot;EggLayAbility&quot; &lt;&lt; std::endl;
    }
};

class Ostrich : public Tweetable, public  EggLayable {
private:
    EggLayAbility* eggLayAbility;
    TweetAbility* tweetAbility;
public:
    void tweet() {
        tweetAbility-&gt;tweet();
    }

    void layEgg() {
        eggLayAbility-&gt;layEgg();
    }

    Ostrich() {
        eggLayAbility = new EggLayAbility();
        tweetAbility = new TweetAbility();
    }
};

int main() {
    Ostrich* os = new Ostrich();
    os-&gt;tweet();
    os-&gt;layEgg();
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-12-02T06:43:28+08:00" itemprop="datePublished">2019/12/02 06:43 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E.html'>设计模式之美</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15752402085375.html" itemprop="url">
		基于接口而非实现编程</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设计原则</h4>
<ul>
<li>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</li>
</ul>
<h4><a id="%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设计要点</h4>
<ul>
<li>函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。</li>
<li>封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。</li>
<li>为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>
<li>抽象意识、封装意识、接口意识</li>
<li></li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_34.html">Prev</a>  
	 <a class="next" href="all_36.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>