<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	       凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-23T07:06:45+08:00" itemprop="datePublished">2019/05/23 07:06 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15585664053810.html" itemprop="url">
		Slub分配器</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="kmem-cache-alloc-node" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kmem_cache_alloc_node</h4>
<ul>
<li>创建 task_struct 的时候，我们不用到内存里面去分配，先在缓存里面看看有没有直接可用的，这就是kmem_cache_alloc_node的作用</li>
<li>进程结束，task_struct 也不用直接被销毁，而是放回到缓存中，这就是kmem_cache_free的作用</li>
</ul>
<h4><a id="kmem-cache" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kmem_cache</h4>
<pre><code class="language-plain_text">struct kmem_cache {
   struct kmem_cache_cpu __percpu *cpu_slab;
   struct kmem_cache_node *node[MAX_NUMNODES];
}
</code></pre>
<h4><a id="kmem-cache-cpu" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kmem_cache_cpu</h4>
<ul>
<li>分配缓存的快速通道</li>
<li></li>
</ul>
<h4><a id="kmem-cache-node" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kmem_cache_node</h4>
<ul>
<li>分配缓存的普通通道</li>
</ul>
<h4><a id="%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存分配</h4>
<ul>
<li><a href="https://www.cnblogs.com/luoahong/p/10907734.html">https://www.cnblogs.com/luoahong/p/10907734.html</a></li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-21T08:46:18+08:00" itemprop="datePublished">2019/05/21 08:46 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15583995782246.html" itemprop="url">
		进程空间管理</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用户态和内核态</h4>
<ul>
<li><img src="media/15583995782246/89723dc967b59f6f49419082f6ab7659.jpg" alt="89723dc967b59f6f49419082f6ab7659" /></li>
</ul>
<h4><a id="%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4%E9%83%A8%E7%BD%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进程空间部署</h4>
<ul>
<li><img src="media/15583995782246/f83b8d49b4e74c0e255b5735044c1eb1.jpg" alt="f83b8d49b4e74c0e255b5735044c1eb1" /></li>
</ul>
<h5><a id="%E5%90%84%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>各区域的位置信息</h5>
<ul>
<li>total_vm 是总共映射的页的数目。</li>
<li>locked_vm 就是被锁定不能换出，pinned_vm 是不能换出，也不能移动。</li>
<li>data_vm 是存放数据的页的数目，exec_vm 是存放可执行文件的页的数目，stack_vm 是栈所占的页的数目。</li>
<li>start_code 和 end_code 表示可执行代码的开始和结束位置，start_data 和 end_data 表示已初始化数据的开始位置和结束位置。</li>
<li>start_brk 是堆的起始位置，brk 是堆当前的结束位置。前面咱们讲过 malloc 申请一小块内存的话，就是通过改变 brk 位置实现的。</li>
<li>start_stack 是栈的起始位置，栈的结束位置在寄存器的栈顶指针中。</li>
<li>arg_start 和 arg_end 是参数列表的位置， env_start 和 env_end 是环境变量的位置。它们都位于栈中最高地址的地方。</li>
</ul>
<pre><code class="language-plain_text">unsigned long mmap_base;	/* base of mmap area */
unsigned long total_vm;		/* Total pages mapped */
unsigned long locked_vm;	/* Pages that have PG_mlocked set */
unsigned long pinned_vm;	/* Refcount permanently increased */
unsigned long data_vm;		/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */
unsigned long exec_vm;		/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */
unsigned long stack_vm;		/* VM_STACK */
unsigned long start_code, end_code, start_data, end_data;
unsigned long start_brk, brk, start_stack;
unsigned long arg_start, arg_end, env_start, env_end;
</code></pre>
<h5><a id="%E5%90%84%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>各区域的属性信息</h5>
<ul>
<li>每一块区域使用vm_area_struct来描述信息</li>
<li>vm_area_struct来描述位置信息</li>
<li>解析ELF</li>
<li>建立内存映射</li>
</ul>
<h6><a id="load-elf-binary" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>load_elf_binary</h6>
<ul>
<li>调用 setup_new_exec，设置内存映射区 mmap_base；</li>
<li>调用 setup_arg_pages，设置栈的 vm_area_struct，这里面设置了 mm-&gt;arg_start 是指向栈底的，current-&gt;mm-&gt;start_stack 就是栈底；</li>
<li>elf_map 会将 ELF 文件中的代码部分映射到内存中来；</li>
<li>set_brk 设置了堆的 vm_area_struct，这里面设置了 current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，也即堆里面还是空的；</li>
<li>load_elf_interp 将依赖的 so 映射到内存中的内存映射区域。</li>
<li>内存映射图<br />
<img src="media/15583995782246/7af58012466c7d006511a7e16143314c.jpeg" alt="7af58012466c7d006511a7e16143314" /></li>
</ul>
<h5><a id="%E4%BF%AE%E6%94%B9%E6%98%A0%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改映射</h5>
<ul>
<li>函数的调用</li>
<li>malloc申请堆内的空间 brk 或者 mmap</li>
</ul>
<h4><a id="%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>堆内存分配</h4>
<ul>
<li>sys_brk的新堆顶地址和旧的堆顶地址进行合并</li>
<li>考虑需要不需要分配页的问题</li>
<li>如果是释放，直接释放</li>
<li>如果是分配堆内存 当前的堆顶和下一个 vm_area_struct 之间还能不能分配一个完整的页</li>
<li>do_brk 进一步分配堆空间，从旧堆顶开始，分配计算出的新旧堆顶之间的页数。</li>
</ul>
<h4><a id="%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E9%A1%B5%E7%9A%84%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>伙伴系统页的分配</h4>
<ul>
<li>把所有的空闲页分组为 11 个页块链表，每个块链表分别包含很多个大小的页块，有 1、2、4、8、16、32、64、128、256、512 和 1024 个连续页的页块</li>
<li>在一个循环中先看当前节点的 zone。如果找不到空闲页，则再看备用节点的 zone</li>
<li>先去free_area找与当前2^order匹配的队列</li>
<li>找不到去更大的2^order队列中找，然后把多余的页面放入其他页面链表</li>
</ul>
<h4><a id="%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>物理内存的总结</h4>
<ul>
<li><img src="media/15583995782246/3fa8123990e5ae2c86859f70a8351f4f.jpeg" alt="3fa8123990e5ae2c86859f70a8351f4f" /></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-13T08:16:34+08:00" itemprop="datePublished">2019/05/13 08:16 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html'>计算机组成原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15577065945094.html" itemprop="url">
		ELF和静态连接</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%BC%96%E8%AF%91%EF%BC%8C%E9%93%BE%E6%8E%A5%E5%92%8C%E8%A3%85%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译，链接和装载</h4>
<ul>
<li>第一个部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。</li>
<li>第二部分，我们通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU 从内存中读取指令和数据，来开始真正执行程序。<br />
<img src="media/15577065945094/997341ed0fa9018561c7120c19cfa2a7.jpg" alt="997341ed0fa9018561c7120c19cfa2a7" /></li>
</ul>
<h4><a id="elf%E6%A0%BC%E5%BC%8F%E5%92%8C%E9%93%BE%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ELF格式和链接</h4>
<ul>
<li>程序最终是通过装载器变成指令和数据的</li>
<li>gcc -g -c add_lib.c link_example.c</li>
<li>objdump -d -M intel -S add_lib.o</li>
<li>objdump -d -M intel -S link_example.o</li>
<li>gcc -o link-example add_lib.o link_example.o</li>
<li>objdump -d -M intel -S link-example</li>
</ul>
<h4><a id="elf%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ELF文件</h4>
<ul>
<li>首先是.text Section，也叫作代码段或者指令段（Code Section），用来保存程序的代码和指令；</li>
<li>接着是.data Section，也叫作数据段（Data Section），用来保存程序里面设置好的初始化数据信息；</li>
<li>然后就是.rel.text Secion，叫作重定位表（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；</li>
<li>最后是.symtab Section，叫作符号表（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。<br />
<img src="media/15577065945094/276a740d0eabf5f4be905fe7326d9fb3-2.jpg" alt="276a740d0eabf5f4be905fe7326d9fb3-2" /></li>
</ul>
<h4><a id="%E9%93%BE%E6%8E%A5%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>链接器</h4>
<ul>
<li>把所有符号表里的信息收集起来，构成一个全局的符号表</li>
<li>根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正</li>
<li>把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码</li>
</ul>
<h4><a id="%E8%A3%85%E8%BD%BD%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>装载器</h4>
<ul>
<li>解析 ELF 文件，把对应的指令和数据，加载到内存里面供 CPU 执行</li>
</ul>
<h4><a id="linux%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%83%BD%E5%9C%A8win%E6%89%A7%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>linux程序不能在win执行</h4>
<ul>
<li>两个操作系统下可执行文件的格式不一样</li>
<li>Linux 下的 ELF 文件格式，而 Windows 的可执行文件格式是一种叫作PE（Portable Executable Format）的文件格式。Linux 下的装载器只能解析 ELF 格式而不能解析 PE 格式</li>
</ul>
<h4><a id="%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展阅读</h4>
<ul>
<li>《程序员的自我修养——链接、装载和库》</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-21T07:58:32+08:00" itemprop="datePublished">2019/05/21 07:58 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html'>计算机组成原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15583967124783.html" itemprop="url">
		动态连接</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案</h4>
<ul>
<li>PLT 和 GOT，动态链接的解决方案</li>
<li>程序链接表（Procedure Link Table）</li>
<li>全局偏移表（GOT，Global Offset Table）</li>
<li>共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的</li>
<li>PLT--&gt;GOT</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-15T07:45:06+08:00" itemprop="datePublished">2019/05/15 07:45 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html'>计算机组成原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15578775068733.html" itemprop="url">
		程序装载</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E8%A3%85%E8%BD%BD%E5%99%A8%E7%9A%84%E9%9C%80%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>装载器的需求</h4>
<ul>
<li>可执行程序加载后占用的内存空间应该是连续的</li>
<li>我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置</li>
</ul>
<h4><a id="%E8%AF%BE%E5%A4%96%E9%98%85%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>课外阅读</h4>
<ul>
<li>程序员的自我修养 1 4 6章</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-20T07:29:21+08:00" itemprop="datePublished">2019/05/20 07:29 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15583085610757.html" itemprop="url">
		物理内存分配</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%BB%8F%E5%85%B8%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>经典内存使用方式</h4>
<ul>
<li><img src="media/15583085610757/fa6c2b6166d02ac37637d7da4e4b579b.jpeg" alt="fa6c2b6166d02ac37637d7da4e4b579b" /></li>
</ul>
<h4><a id="smp%E5%92%8Cnuma%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SMP和NUMA模式</h4>
<ul>
<li><img src="media/15583085610757/8f158f58dda94ec04b26200073e15449.jpeg" alt="8f158f58dda94ec04b26200073e15449" /></li>
</ul>
<h4><a id="numa%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NUMA模型</h4>
<ul>
<li>内存被分成了多个节点，每个节点再被分成一个一个的页面。由于页需要全局唯一定位，页还是需要有全局唯一的页号的。但是由于物理内存不是连起来的了，页号也就不再连续了。于是内存模型就变成了非连续内存模型</li>
<li>CPU访问内存不用过总线</li>
</ul>
<h4><a id="%E8%8A%82%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>节点</h4>
<ul>
<li>pglist_data</li>
<li>每一个节点都有自己的 ID：node_id；</li>
<li>node_mem_map 就是这个节点的 struct page 数组，用于描述这个节点里面的所有的页；</li>
<li>node_start_pfn 是这个节点的起始页号；</li>
<li>node_spanned_pages 是这个节点中包含不连续的物理内存地址的页面数；</li>
<li>node_present_pages 是真正可用的物理页面的数目。</li>
</ul>
<h4><a id="dma%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DMA机制</h4>
<ul>
<li>DMA 是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过 CPU 控制完成，但是这会占用 CPU，影响 CPU 处理其他事情，所以有了 DMA 模式。CPU 只需向 DMA 控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，这样就可以解放 CPU。</li>
</ul>
<h4><a id="%E5%8C%BA%E5%9F%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>区域</h4>
<ul>
<li>spanned_pages = zone_end_pfn - zone_start_pfn，也即 spanned_pages 指的是不管中间有没有物理内存空洞，反正就是最后的页号减去起始的页号。</li>
<li>present_pages = spanned_pages - absent_pages(pages in holes)，也即 present_pages 是这个 zone 在物理内存中真实存在的所有 page 数目。</li>
<li>managed_pages = present_pages - reserved_pages，也即 managed_pages 是这个 zone 被伙伴系统管理的所有的 page 数目，</li>
<li>per_cpu_pageset</li>
</ul>
<h4><a id="%E9%A1%B5%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>页面</h4>
<ul>
<li>匿名页  一整页的内存，或者直接和虚拟地址空间建立映射关系，我们把这种称为匿名页（Anonymous Page）</li>
<li>文件页 关联一个文件，然后再和虚拟地址空间建立映射关系，这样的文件，我们称为内存映射文件（Memory-mapped File）。</li>
</ul>
<h4><a id="%E5%8C%BF%E5%90%8D%E9%A1%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>匿名页</h4>
<ul>
<li>struct address_space *mapping 就是用于内存映射，如果是匿名页，最低位为 1；如果是映射文件，最低位为 0；</li>
<li>pgoff_t index 是在映射区的偏移量；</li>
<li>atomic_t _mapcount，每个进程都有自己的页表，这里指有多少个页表项指向了这个页；</li>
<li>struct list_head lru 表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中；</li>
<li>compound 相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页</li>
</ul>
<h4><a id="%E6%96%87%E4%BB%B6%E9%A1%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件页</h4>
<ul>
<li>分配小块内存，存储进程描述结构的对象</li>
<li>slub allocator</li>
</ul>
<h4><a id="%E9%A1%B5%E7%9A%84%E5%88%86%E9%85%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>页的分配</h4>
<ul>
<li>分配大内存使用伙伴系统</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-15T07:35:47+08:00" itemprop="datePublished">2019/05/15 07:35 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html'>操作系统原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15578769474390.html" itemprop="url">
		内存管理</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%AE%A1%E7%90%86%E8%A7%92%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>管理角度</h4>
<ul>
<li>
<p>第一，物理内存的管理，相当于会议室管理员管理会议室。</p>
</li>
<li>
<p>第二，虚拟地址的管理，也即在项目组的视角，会议室的虚拟地址应该如何组织。</p>
</li>
<li>
<p>第三，虚拟地址和物理地址如何映射，也即会议室管理员如果管理映射表</p>
</li>
</ul>
<h4><a id="%E5%86%85%E5%AD%98%E6%A0%88%E7%A9%BA%E9%97%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存栈空间</h4>
<ul>
<li>Text Segment</li>
<li>Data Segment</li>
<li>BSS Segment</li>
</ul>
<h4><a id="%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存分段机制</h4>
<p><img src="media/15578769474390/9697ae17b9f561e78514890f9d58d4eb.jpg" alt="9697ae17b9f561e78514890f9d58d4eb" /></p>
<h4><a id="%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存分页机制</h4>
<ul>
<li>32位系统</li>
<li><img src="media/15578769474390/b6960eb0a7eea008d33f8e0c4facc8b8.jpg" alt="b6960eb0a7eea008d33f8e0c4facc8b8" /></li>
<li>64位系统<br />
<img src="media/15578769474390/42eff3e7574ac8ce2501210e25cd2c0b.jpg" alt="42eff3e7574ac8ce2501210e25cd2c0b" /></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-11-20T16:50:36+08:00" itemprop="datePublished">2018/11/20 16:50 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Golang.html'>Golang</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15427038364970.html" itemprop="url">
		原子操作</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="cas%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CAS的使用场景</h4>
<ul>
<li>共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，或者说更加宽松的做法。</li>
</ul>
<h4><a id="%E5%8E%9F%E5%AD%90%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%B8%89%E4%B8%AA%E5%86%B3%E7%AD%96%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原子锁和互斥锁的三个决策条件</h4>
<ul>
<li>变量类型 原子值中不要存储引用的类型，容易造成安全漏洞</li>
<li>操作频率</li>
<li>操作时间</li>
</ul>
<h4><a id="atomic-value" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>atomic.Value</h4>
<ul>
<li>复制该类型的值会产生一个完全分离的新值。这个新值相当于被复制的那个值的一个快照。</li>
<li>它的动态值是nil，但动态类型却不是nil，那么它的值就不等于nil,可以被存储原子值</li>
<li>我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。</li>
</ul>
<h4><a id="%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用注意事项</h4>
<ul>
<li>不要把内部使用的原子值暴露给外界。比如，声明一个全局的原子变量并不是一个正确的做法。这个变量的访问权限最起码也应该是包级私有的。</li>
<li>如果不得不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数，让外界间接地使用到它。注意，这种情况下不要把原子值传递到外界，不论是传递原子值本身还是它的指针值。</li>
<li>如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性。若不合法，则应该直接返回对应的错误值，从而避免 panic 的发生。</li>
<li>如果可能的话，我们可以把原子值封装到一个数据类型中，比如一个结构体类型。这样，我们既可以通过该类型的方法更加安全地存储值，又可以在该类型中包含可存储值的合法类型信息。</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-05-10T08:06:08+08:00" itemprop="datePublished">2019/05/10 08:06 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html'>计算机组成原理</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15574467683931.html" itemprop="url">
		函数调用</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E7%94%9F%E6%88%90%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生成汇编代码</h4>
<ul>
<li>gcc -g -c function_example.c</li>
<li>objdump -d -M intel -S func.o</li>
</ul>
<h4><a id="%E5%87%BD%E6%95%B0%E5%8E%8B%E6%A0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数压栈</h4>
<ul>
<li>每次程序调用函数之前，我们都把调用返回后的地址写在一个乒乓球上，然后塞进这个球桶。这个操作其实就是我们常说的压栈。如果函数执行完了，我们就从球桶里取出最上面的那个乒乓球，很显然，这就是出栈。</li>
</ul>
<h4><a id="%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数栈帧</h4>
<ul>
<li>整个函数所占用的所有内存空间，就是函数的栈帧（Stack Frame）</li>
<li>rbp 帧指针</li>
<li>rsp 栈顶指针</li>
</ul>
<h4><a id="%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数内联</h4>
<ul>
<li>把一个实际调用的函数产生的指令，直接插入到的位置，来替换对应的函数调用指令</li>
<li>编译器进行自动优化的场景， 函数内联（Inline）</li>
<li><img src="media/15574467683931/dca83475560147d4dd492ff283ae0c85.jpeg" alt="dca83475560147d4dd492ff283ae0" /></li>
</ul>
<h4><a id="%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数调用栈</h4>
<ul>
<li>初始化栈帧</li>
<li>执行过程的计算</li>
<li>恢复栈，返回</li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_59.html">Prev</a>  
	 <a class="next" href="all_61.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>