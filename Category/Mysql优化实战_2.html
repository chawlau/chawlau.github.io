<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Mysql优化实战 -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-12-21T10:50:13+08:00" itemprop="datePublished">2018/12/21 10:50 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15453606137574.html" itemprop="url">
		如何正确的显示随机信息</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%8E%9F%E5%A7%8B%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原始算法</h4>
<pre><code class="language-plain_text">mysql&gt; select word from words order by rand() limit 3;
</code></pre>
<h4><a id="%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%951" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化算法1</h4>
<pre><code class="language-plain_text">mysql&gt; select max(id),min(id) into @M,@N from t ;
set @X= floor((@M-@N+1)*rand() + @N);
select * from t where id &gt;= @X limit 1;
</code></pre>
<ul>
<li>有概率不均匀的问题</li>
</ul>
<h4><a id="%E7%AE%97%E6%B3%952" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>算法2</h4>
<pre><code class="language-plain_text">mysql&gt; select count(*) into @C from t;
set @Y = floor(@C * rand());
set @sql = concat(&quot;select * from t limit &quot;, @Y, &quot;,1&quot;);
prepare stmt from @sql;
execute stmt;
DEALLOCATE prepare stmt;
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-12-29T10:01:01+08:00" itemprop="datePublished">2018/12/29 10:01 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15460488614529.html" itemprop="url">
		幻读</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概念</h4>
<ul>
<li>幻读仅仅指新插入的行</li>
<li>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</li>
</ul>
<h4><a id="%E5%BD%93%E5%89%8D%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>当前读</h4>
<ul>
<li>for update</li>
</ul>
<h4><a id="%E5%B9%BB%E8%AF%BB%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>幻读引发的问题</h4>
<ul>
<li>数据一致性是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性</li>
</ul>
<h4><a id="%E9%97%B4%E9%9A%99%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>间隙锁</h4>
<ul>
<li>保护两个值之间的空隙不允许插入新的值</li>
<li>在可重复读的级别下生效，读提交的情况下间隙锁不会生效</li>
<li>读提交下操作数据的锁范围更小，这个选择是合理的</li>
<li>binlog_format=row配合间隙锁解决数据和日志不一致</li>
<li>binlog和实际操作的结果数据不一致</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-01-17T16:59:12+08:00" itemprop="datePublished">2019/01/17 16:59 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15477155524350.html" itemprop="url">
		Mysql高可用</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="seconds-behind-master" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>seconds_behind_master</h4>
<ul>
<li>每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master。</li>
</ul>
<h4><a id="%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主备延迟</h4>
<ul>
<li>备库机器性能比较差</li>
<li>备库压力大</li>
<li>一主多从</li>
<li>通过binlog输出到外部系统如hadoop</li>
<li>大事务 一次性删除太多历史数据 大表DDL</li>
<li>备库的并行复制能力</li>
</ul>
<h4><a id="%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可靠性优先策略</h4>
<ul>
<li>双M结构下主从切换，然后等切换成主库的备库的seconds_behind_master=0,把备库改成可读写状态</li>
<li><img src="media/15477155524350/54f4c7c31e6f0f807c2ab77f78c8844a.png" alt="54f4c7c31e6f0f807c2ab77f78c8844a" /></li>
</ul>
<h4><a id="%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可用性优先策略</h4>
<ul>
<li>双M主备的切换过程中，不等主备同步，直接把连接切到备库</li>
<li>如果binglog是statement会导致主备不一致，如果是row则会抛出异常不会执行</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-01-17T17:45:12+08:00" itemprop="datePublished">2019/01/17 17:45 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15477183125806.html" itemprop="url">
		备库长时间延迟</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="coordinator%E5%88%86%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>coordinator分发</h4>
<ul>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中</li>
<li>同一个事务不能被拆开，必须放到同一个worker中。</li>
</ul>
<h4><a id="%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>并行复制策略</h4>
<ul>
<li>按表分发策略</li>
<li>worker线程维护库名+表名 + 冲突 (该线程修改这个表的事物数目)</li>
<li>如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;</li>
<li>如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；</li>
<li>如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker</li>
<li>不足 如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</li>
</ul>
<h4><a id="%E6%8C%89%E8%A1%8C%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>按行分发策略</h4>
<ul>
<li>如果两个事务没有更新相同的行，它们在备库上可以并行执行。显然，这个模式要求 binlog 格式必须是 row。</li>
<li>每个worker的hash表的key是库名 + 表名 + 唯一键的名字 + 唯一的键的值</li>
<li>要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；</li>
<li>表必须有主键；</li>
<li>不能有外键。表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。</li>
<li>不足</li>
<li>耗费内存。比如一个语句要删除 100 万行数据，这时候 hash 表就要记录 100 万个项。</li>
<li>耗费 CPU。解析 binlog，然后计算 hash 值，对于大事务，这个成本还是很高的。</li>
</ul>
<h4><a id="%E7%A4%BE%E5%8C%BA%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>社区并行复制策略</h4>
<ul>
<li>按库分发</li>
</ul>
<h4><a id="maradb" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>maradb</h4>
<ul>
<li>利用特性</li>
<li>能够在同一组里提交的事务，一定不会修改同一行；</li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li>
<li>复制策略</li>
<li>在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；</li>
<li>commit_id 直接写到 binlog 里面；</li>
<li>传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；</li>
<li>这一组全部执行完成后，coordinator 再去取下一批。</li>
</ul>
<h4><a id="mysql5-7%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mysql5.7并行复制策略</h4>
<ul>
<li>LOGICAL_CLOCK</li>
<li>同时处于 prepare 状态的事务，在备库执行时是可以并行的；</li>
<li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。</li>
<li>binlog_group_commit_sync_delay</li>
<li>binlog_group_commit_sync_no_delay_count</li>
<li>也可以提升从库的复制并发度</li>
<li>binlog-transaction-dependency-tracking</li>
<li>COMMIT_ORDER，表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</li>
<li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</li>
<li>WRITESET_SESSION，是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
<li>优势</li>
<li>writeset 是在主库生成后直接写入到 binlog 里面的，这样在备库执行的时候，不需要解析 binlog 内容（event 里的行数据），节省了很多计算量；</li>
<li>不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个 worker，更省内存；</li>
<li>由于备库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也是可以的。</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-02-01T09:03:36+08:00" itemprop="datePublished">2019/02/01 09:03 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15489830169180.html" itemprop="url">
		Join语句优化</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="multi-range-read" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multi-Range Read</h4>
<ul>
<li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li>
<li>将 read_rnd_buffer 中的 id 进行递增排序；</li>
<li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回</li>
<li>read_rnd_buffer由read_rnd_buffer_length</li>
<li>优化核心原因</li>
<li>MRR 能够提升性能的核心在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</li>
</ul>
<h4><a id="batched-key-access" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Batched Key Access</h4>
<ul>
<li>NLJ的优化一次性驱动表多取出索引值跟被驱动表进行多行匹配</li>
<li>BNL优化把</li>
<li>表 t2 中满足条件的数据放在临时表 tmp_t 中；</li>
<li>给临时表 tmp_t 的字段 b 加上索引；</li>
<li>让表 t1 和 tmp_t 做 join 操作。</li>
</ul>
<h4><a id="sql%E6%93%8D%E7%BB%83%E8%AF%AD%E5%8F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SQL操练语句</h4>
<pre><code class="language-plain_text">explain select * from t2 where a&gt;=100 and a&lt;=200;
explain select * from t1 join t2 on (t1.b=t2.b) where t2.b&gt;=1 and t2.b&lt;=2000;
优化BNL
create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;
insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;
select * from t1 join temp_t on (t1.b=temp_t.b);
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-02-04T11:20:09+08:00" itemprop="datePublished">2019/02/04 11:20 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15492504094153.html" itemprop="url">
		临时表</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%86%85%E5%AD%98%E8%A1%A8%E5%92%8C%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存表和临时表区别</h4>
<ul>
<li>内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在</li>
<li>而临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎</li>
</ul>
<h4><a id="%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>临时表特点</h4>
<ul>
<li>建表语法是 create temporary table …。</li>
<li>一个临时表只能被创建它的 session 访问，对其他线程不可见。所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的。</li>
<li>临时表可以与普通表同名。</li>
<li>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li>
<li>show tables 命令不显示临时表。</li>
</ul>
<h4><a id="%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%AD%98%E5%82%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>临时表存储</h4>
<ul>
<li>文件名的后缀是.frm，前缀是“#sql{进程 id}<em>{线程 id}</em> 序列号”</li>
<li>MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建 ibd 文件了。</li>
<li>临时表库名+表名+server_id+thread_id</li>
</ul>
<h4><a id="%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主从同步</h4>
<ul>
<li>创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个 DROP TEMPORARY TABLE 传给备库执行。</li>
<li>果执行 drop table t_normal，系统记录 binlog 就会写成：</li>
</ul>
<pre><code class="language-plain_text">DROP TABLE `t_normal` /* generated by server */
</code></pre>
<ul>
<li>从库区别主库同名临时通过server_id+thread_id+database+table</li>
</ul>
<h4><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h4>
<ul>
<li>在 binlog_format='row’的时候，临时表的操作不记录到 binlog 中，也省去了不少麻烦</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-02-10T09:11:59+08:00" itemprop="datePublished">2019/02/10 09:11 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15497611194576.html" itemprop="url">
		内部临时表</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存临时表</h4>
<ul>
<li>tmp_table_size控制内存临时表大小</li>
</ul>
<h4><a id="group-by%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>group by优化</h4>
<ul>
<li>优化原因</li>
<li>内存临时表还是磁盘临时表，group by 逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个 group by 语句执行起来就会很慢</li>
<li>generated column 添加索引</li>
<li>直接排序，使用磁盘临时表进行辅助, 通过SQL_BIG_RESULT来提示优化器</li>
</ul>
<h4><a id="%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%BD%BF%E7%94%A8%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存临时表使用事项</h4>
<ul>
<li>如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</li>
<li>尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</li>
<li>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</li>
<li>如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-02-11T14:37:51+08:00" itemprop="datePublished">2019/02/11 14:37 下午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15498670713472.html" itemprop="url">
		自增主键</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E4%BD%9C%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>作用</h4>
<ul>
<li>自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。</li>
</ul>
<h4><a id="%E8%87%AA%E5%A2%9E%E5%80%BC%E7%9A%84%E4%BF%9D%E5%AD%98%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自增值的保存策略</h4>
<ul>
<li>MyISAM 引擎的自增值保存在数据文件中。</li>
<li>InnoDB 引擎的自增值，其实是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力</li>
</ul>
<h4><a id="%E8%87%AA%E5%A2%9E%E5%80%BC%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自增值算法</h4>
<ul>
<li>从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。</li>
</ul>
<h4><a id="%E8%87%AA%E5%A2%9Eid%E4%B8%8D%E8%BF%9E%E7%BB%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自增ID不连续</h4>
<ul>
<li>唯一键冲突</li>
<li>事物回滚</li>
<li>同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>
</ul>
<h4><a id="%E8%87%AA%E5%A2%9E%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自增锁的优化</h4>
<ul>
<li>主库不使用语句锁如果自增健不连续，但是从库执行语句会导致从库的自增值仍然是一致的，会导致主从不一致</li>
<li>解决思路</li>
<li>一种思路是，让原库的批量插入数据语句，固定生成连续的 id 值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。</li>
<li>另一种思路是，在 binlog 里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是 innodb_autoinc_lock_mode 设置为 2，同时 binlog_format 设置为 row。</li>
</ul>
<h4><a id="%E6%89%B9%E9%87%8F%E7%94%B3%E8%AF%B7%E8%87%AA%E5%A2%9Eid%E7%9A%84%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>批量申请自增ID的策略</h4>
<ul>
<li>同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>
<li></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2019-08-28T07:15:06+08:00" itemprop="datePublished">2019/08/28 07:15 上午</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Mysql%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98.html'>Mysql优化实战</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15669477064349.html" itemprop="url">
		删库之后怎么办</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h4><a id="%E5%88%86%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分类</h4>
<ul>
<li>使用 delete 语句误删数据行；</li>
<li>使用 drop table 或者 truncate table 语句误删数据表；</li>
<li>使用 drop database 语句误删数据库；</li>
<li>使用 rm 命令误删整个 MySQL 实例</li>
</ul>
<h4><a id="%E8%AF%AF%E5%88%A0%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>误删行</h4>
<ul>
<li>binlog_format=row 和 binlog_row_image=FULL</li>
<li>对于 insert 语句，对应的 binlog event 类型是 Write_rows event，把它改成 Delete_rows event 即可；</li>
<li>同理，对于 delete 语句，也是将 Delete_rows event 改为 Write_rows event；而如果是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即</li>
<li>sql_safe_updates on</li>
</ul>
<h4><a id="%E8%AF%AF%E5%88%A0%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>误删库</h4>
<ul>
<li>如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用–stop-position 参数执行到误操作之前的日志，然后再用–start-position 从误操作之后的日志继续执行；</li>
<li>如果实例使用了 GTID 模式，就方便多了。假设误操作命令的 GTID 是 gtid1，那么只需要执行 set gtid_next=gtid1;begin;commit; 先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句</li>
</ul>
<h4><a id="%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>加速方法</h4>
<ul>
<li>只同步误操作的表，使用并行复制技术</li>
<li>延迟复制从库CHANGE MASTER TO MASTER_DELAY = N</li>
<li></li>
</ul>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="Mysql优化实战_1.html">Prev</a>  
	 <a class="next" href="Mysql优化实战_3.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>