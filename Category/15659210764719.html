<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	链表 -        凌云阁
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="       凌云阁" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="https://i.loli.net/2020/02/22/Si1K7sluept2ZgR.jpg" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">       凌云阁</a></h1>
					<p class="subtitle">生命的意义是成为你自己！</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="_self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<a target="_blank" class="facebook" href="www.facebook.com" title="Facebook">Facebook</a>






<a target="_blank" class="weibo" href="www.weibo.com" title="weibo">Weibo</a>
<a target="_blank" class="twitter" target="_blank" href="www.twitter.com" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="www.github.com/chawlau" title="GitHub">GitHub</a>


								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">链表</h1>
		<div class="entry-content" itemprop="articleBody">
			<h4><a id="%E5%8F%8D%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>反转</h4>
<ul>
<li>leet_206</li>
</ul>
<pre><code class="language-C++">Reverse a singly linked list.

Example:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
      ListNode* pre = nullptr;
      while (head) {
        ListNode* next = head-&gt;next;
        head-&gt;next= pre;
        pre = head;
        head = next;
      }
      return pre;
    }
};
</code></pre>
<ul>
<li>leet_92</li>
</ul>
<pre><code class="language-C++">Reverse a linked list from position m to n. Do it in one-pass.

Note: 1 ≤ m ≤ n ≤ length of list.

Example:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

static int x = []() {std::ios::sync_with_stdio(false); cin.tie(0); return 0; }();

class Solution 
{
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) 
    {
        if (head == nullptr || head-&gt;next == nullptr ||
            m &gt;= n || m &lt; 0 || n &lt; 0)
        {
            return head;
        }
        ListNode* h = new ListNode(-1);
        h-&gt;next = head;
        ListNode* pre = h;
        ListNode* cur = head;
        int i = 1;
        for (; i &lt; m &amp;&amp; cur != nullptr; ++i)
        {
            pre = cur;
            cur = cur-&gt;next;
        }
        ListNode* t1 = pre;
        ListNode* t2 = cur;
        for (; i &lt;= n &amp;&amp; cur != nullptr; ++i)
        {
            ListNode* lat = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = lat;
        }
        t1-&gt;next = pre;
        t2-&gt;next = cur;
        return h-&gt;next;
    }
};
</code></pre>
<ul>
<li>leet_83</li>
</ul>
<pre><code class="language-C++">Given a sorted linked list, delete all duplicates such that each element appear only  once.

Example 1:

Input: 1-&gt;1-&gt;2
Output: 1-&gt;2
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode *cur = head;
        while (cur &amp;&amp; cur-&gt;next) {
            if (cur-&gt;val == cur-&gt;next-&gt;val) {
                cur-&gt;next = cur-&gt;next-&gt;next;
            } else {
                cur = cur-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
<ul>
<li>leet_86</li>
</ul>
<pre><code class="language-C++">Given a linked list and a value  x , partition it such that all nodes less than  x  come before nodes greater than or equal to  x.

You should preserve the original relative order of the nodes in each of the two partitions.

For example,
Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and  x  = 3,
return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.
就是将所有小于给定值的节点取出组成一个新的链表，此时原链表中剩余的节点的值都大于或等于给定值，只要将原链表直接接在新链表后即可
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
      ListNode node1(0);
      ListNode node2(0);
      ListNode* p1 = &amp;node1;
      ListNode* p2 = &amp;node2;
      while (head) {
        if (head-&gt;val &lt; x) {
          p1-&gt;next = head;
          p1 = p1-&gt;next;
        } else {
          p2-&gt;next = head;
          p2 = p2-&gt;next;
        }
        head = head-&gt;next;
      }
      p2-&gt;next = nullptr;
      p1-&gt;next = node2.next;
      return node1.next;
    }
};
</code></pre>
<ul>
<li>leet_328</li>
</ul>
<pre><code class="language-C++">Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example 1:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL
func oddEvenList(head *ListNode) *ListNode {
	if head == nil {
		return head
	}
	
	odd := head
	evenHead := head.Next
	even := evenHead
	
	for even != nil &amp;&amp; even.Next != nil {
		odd.Next = even.Next
		odd = odd.Next
		even = odd.Next
		even = even.Next
	}
	odd.Next = evenHead
	return head
}
</code></pre>
<ul>
<li>leet_2</li>
</ul>
<pre><code class="language-C++">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
Explanation: 342 + 465 = 807.
class Solution {
public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode node(0), *p = &amp;node;
    int extra = 0;
    while (l1 || l2 || extra) {
      if (l1) extra += l1-&gt;val, l1 = l1-&gt;next;
      if (l2) extra += l2-&gt;val, l2 = l2-&gt;next;
      p-&gt;next = new ListNode(extra % 10);
      extra /= 10;
      p = p-&gt;next;
    }
    return node.next;

  }
};
</code></pre>
<ul>
<li>leet_445</li>
</ul>
<pre><code class="language-C++">Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

Example:

Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 8 -&gt; 0 -&gt; 7
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    stack&lt;int&gt; v1, v2;
    while (l1) v1.push(l1-&gt;val), l1 = l1-&gt;next;
    while (l2) v2.push(l2-&gt;val), l2 = l2-&gt;next;

    int extra = 0;

    ListNode dummy, *pre = nullptr;
    while (!v1.empty() || !v2.empty() || extra) {
        if (!v1.empty()) extra += v1.top(), v1.pop();
        if (!v2.empty()) extra += v2.top(), v2.pop();

        ListNode* p = new ListNode(extra % 10);
        extra /= 10;
        p-&gt;next = pre;
        pre = p;
    }
    return pre;
    }
};
</code></pre>
<h4><a id="%E8%AE%BE%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设立虚拟头节点</h4>
<ul>
<li>leet_203</li>
</ul>
<pre><code class="language-C++">Remove all elements from a linked list of integers that have value val.

Example
Given: 1 -- &gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6
Return: 1 -- &gt; 2 --&gt; 3 --&gt; 4 --&gt; 5
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) 
    {
        ListNode* h = new ListNode(-1);
        h-&gt;next = head;
        ListNode *cur = h;
        while (cur-&gt;next != nullptr)
        {
            ListNode* delNode = cur-&gt;next;
            if (delNode-&gt;val == val)
            {
                cur-&gt;next = delNode-&gt;next;
                delete delNode;
            }
            else
            {
                cur = cur-&gt;next;
            }
        }
        ListNode* retNode = h-&gt;next;
        delete h;
        return retNode;
    }
  };
</code></pre>
<ul>
<li>leet_82</li>
</ul>
<pre><code class="language-C++">class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head || !head-&gt;next) return head;
        ListNode *dummy = new ListNode(-1), *pre = dummy;
        dummy-&gt;next = head;
        while (pre-&gt;next) {
            ListNode *cur = pre-&gt;next;
            while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) {
                cur = cur-&gt;next;
            }
            if (cur != pre-&gt;next) pre-&gt;next = cur-&gt;next;
            else pre = pre-&gt;next;
        }
        return dummy-&gt;next;
    }
};
</code></pre>
<ul>
<li>leet_21</li>
</ul>
<pre><code class="language-C++">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
class Solution {
public:
  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

    ListNode node(0), *p = &amp;node;
    while (l1 &amp;&amp; l2) {
      if (l1-&gt;val &lt; l2-&gt;val) {
        p-&gt;next = l1;
        l1 = l1-&gt;next;
      } else {
        p-&gt;next = l2;
        l2 = l2-&gt;next;
      }
      p = p-&gt;next;
    }

    p-&gt;next = l1 ? l1 : l2;
    return node.next;
  }
};
</code></pre>
<ul>
<li>leet_25</li>
</ul>
<pre><code class="language-C++">Example:

Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5

For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5

For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
      ListNode dumy(0), *pre = &amp;dumy, *cur = &amp;dumy;
      dumy.next = head;
      int num = 0;
      while (cur = cur-&gt;next)  num++;
      while (num &gt;= k) {
        cur = pre-&gt;next;
        for (int i = 1; i &lt; k; i++) {
          ListNode* t = cur-&gt;next;
          cur-&gt;next = t-&gt;next;
          t-&gt;next = pre-&gt;next;
          pre-&gt;next = t;
        }
        pre = cur;
        num -= k;
      }
      return dumy.next;
    }
};
</code></pre>
<ul>
<li>leet_147</li>
</ul>
<pre><code class="language-C++">Sort a linked list using insertion sort.
Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode* dummy = new ListNode(0);
        dummy -&gt; next = head;
        ListNode *pre = dummy, *cur = head;
        while (cur) {
            if ((cur -&gt; next) &amp;&amp; (cur -&gt; next -&gt; val &lt; cur -&gt; val)) {
                while ((pre -&gt; next) &amp;&amp; (pre -&gt; next -&gt; val &lt; cur -&gt; next -&gt; val)) {
                    pre = pre -&gt; next;
                }
                ListNode* temp = pre -&gt; next;
                pre -&gt; next = cur -&gt; next;
                cur -&gt; next = cur -&gt; next -&gt; next;
                pre -&gt; next -&gt; next = temp;
                pre = dummy;
            }
            else {
                cur = cur -&gt; next;
            }
        }
        return dummy -&gt; next;
    }
};
</code></pre>
<ul>
<li>leet_148</li>
</ul>
<pre><code class="language-Go">Sort a linked list in  O ( n  log  n ) time using constant space complexity.

Example 1:

Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
Example 2:

Input: -1-&gt;5-&gt;3-&gt;4-&gt;0
Output: -1-&gt;0-&gt;3-&gt;4-&gt;5
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head-&gt;next) return head;
        ListNode *slow = head, *fast = head, *pre = head;
        while (fast &amp;&amp; fast-&gt;next) {
            pre = slow;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        pre-&gt;next = NULL;
        return merge(sortList(head), sortList(slow));
    }
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode *dummy = new ListNode(-1);
        ListNode *cur = dummy;
        while (l1 &amp;&amp; l2) {
            if (l1-&gt;val &lt; l2-&gt;val) {
                cur-&gt;next = l1;
                l1 = l1-&gt;next;
            } else {
                cur-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            cur = cur-&gt;next;
        }
        if (l1) cur-&gt;next = l1;
        if (l2) cur-&gt;next = l2;
        return dummy-&gt;next;
    }
};
</code></pre>
<ul>
<li>leet_237</li>
</ul>
<pre><code class="language-C++">Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val = node-&gt;next-&gt;val;
        ListNode *tmp = node-&gt;next;
        node-&gt;next = tmp-&gt;next;
        delete tmp;
    }
};
</code></pre>
<h4><a id="%E5%8F%8C%E8%8A%82%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双节点</h4>
<ul>
<li>leet_61</li>
</ul>
<pre><code class="language-C++">Given a list, rotate the list to the right by  k  places, where  k  is non-negative.

For example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and  k  = 2,
return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.
class Solution {
public:
    ListNode *rotateRight(ListNode *head, int k) {
        if (!head) return NULL;
        int n = 0;
        ListNode *cur = head;
        while (cur) {
            ++n;
            cur = cur-&gt;next;
        }
        k %= n;
        ListNode *fast = head, *slow = head;
        for (int i = 0; i &lt; k; ++i) {
            if (fast) fast = fast-&gt;next;
        }
        if (!fast) return head;
        while (fast-&gt;next) {
            fast = fast-&gt;next;
            slow = slow-&gt;next;
        }
        fast-&gt;next = head;
        fast = slow-&gt;next;
        slow-&gt;next = NULL;
        return fast;
    }
};
</code></pre>
<ul>
<li>leet_143</li>
</ul>
<pre><code class="language-Go">Given a singly linked list  L :  L 0→ L 1→…→ L n -1→ L n,
reorder it to:  L 0→ L n → L 1→ L n -1→ L 2→ L n -2→…

You may not modify the values in the list's nodes, only nodes itself may be changed.

Example 1:

Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.
Example 2:

Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.
func middleNode(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast.Next != nil &amp;&amp; fast.Next.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
	}
	return slow
}

func reverse(head *ListNode) *ListNode {
	var pre *ListNode = nil
	for head != nil {
		next := head.Next
		head.Next = pre
		pre = head
		head = next
	}
	return pre
}

func mergeList(l1, l2 *ListNode){
	var p1, p2 *ListNode
	for l1 != nil &amp;&amp; l2 != nil {
		p1 = l1.Next
		p2 = l2.Next

		l1.Next = l2
		l1 = p1
		l2.Next = l1
		l2 = p2
	}
}
func reorderList(head *ListNode) {
	if head == nil {
		return
	}
	mid := middleNode(head)
	l1 := head
	l2 := mid.Next
	mid.Next = nil
	l2 = reverse(l2)
	mergeList(l1, l2)
}
</code></pre>
<ul>
<li>leet_234</li>
</ul>
<pre><code class="language-C++">Given a singly linked list, determine if it is a palindrome.

Example 1:

Input: 1-&gt;2
Output: false
Example 2:

Input: 1-&gt;2-&gt;2-&gt;1
Output: true
class Solution {
  public:
  ListNode* reverse(ListNode* head) {
    ListNode* pre = nullptr, *next = nullptr;

    while (head) {
      next = head-&gt;next;
      head-&gt;next = pre;
      pre = head;
      head = next;
    }

    return pre;
  }

  bool isPalindrome(ListNode* head) {
    if (!head || !head-&gt;next) return true;
    
    ListNode* fast = head, *slow = head;
    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {
      slow = slow-&gt;next;
      fast = fast-&gt;next-&gt;next;
    }

    ListNode* mid = slow-&gt;next;
    ListNode* rhead = reverse(mid);
    while (rhead) {
      if (rhead-&gt;val != head-&gt;val) return false;
      rhead = rhead-&gt;next;
      head = head-&gt;next;
    }
    return true;
  }
};
</code></pre>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    



</body>
</html>